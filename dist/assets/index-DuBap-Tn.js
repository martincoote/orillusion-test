var fo=Object.defineProperty;var Ao=(n,t,e)=>t in n?fo(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var s=(n,t,e)=>Ao(n,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))r(a);new MutationObserver(a=>{for(const i of a)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function e(a){const i={};return a.integrity&&(i.integrity=a.integrity),a.referrerPolicy&&(i.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?i.credentials="include":a.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(a){if(a.ep)return;a.ep=!0;const i=e(a);fetch(a.href,i)}})();const v=class v{constructor(t=1,e=1,r=1,a=1){s(this,"r",0);s(this,"g",0);s(this,"b",0);s(this,"a",0);this.setTo(t,e,r,a)}convertToHDRRGB(){return this.r=this.r*Math.pow(2.4,this.a),this.g=this.g*Math.pow(2.4,this.a),this.b=this.b*Math.pow(2.4,this.a),this}unSerialized(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}hexToRGB(t){return this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}hexToRGBA(t){return this.a=(t>>24&255)/255,this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}static random(t=1){let e=new v;return e.a=t,e.r=t*Math.random(),e.g=t*Math.random(),e.b=t*Math.random(),e}static randomRGB(t=.5,e=.5,r=.5,a=.5,i=.5,o=.5){let l=new v;return l.a=1,l.r=a+t*Math.random(),l.g=i+e*Math.random(),l.b=o+r*Math.random(),l}static randomGray(t=.5,e=.5){let r=Math.random()*e+t,a=new v;return a.a=1,a.r=r,a.g=r,a.b=r,a}setTo(t,e,r,a){this.r=Math.max(t,0),this.g=Math.max(e,0),this.b=Math.max(r,0),this.a=Math.max(a,0)}setHex(t){if(typeof t!="string"||v.NON_HEX_CHARS.test(t)||!v.VALID_HEX_SIZE.test(t))throw new TypeError("Expected a valid hex string");t=t.replace(/^#/,"");let e=1;t.length===8&&(e=Number.parseInt(t.slice(6,8),16)/255,t=t.slice(0,6)),t.length===4&&(e=Number.parseInt(t.slice(3,4).repeat(2),16)/255,t=t.slice(0,3)),t.length===3&&(t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]);const r=Number.parseInt(t,16),a=r>>16,i=r>>8&255,o=r&255,l=e;this.a=l,this.r=a/255,this.g=i/255,this.b=o/255}getHex(){let t=e=>{e*=255;let r=e.toString(16);return r.length===1&&(r="0"+r),r};return t(this.r)+t(this.g)+t(this.b)+t(this.a)}get rgb(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0]}set rgb(t){this.setTo(t[0]/255,t[1]/255,t[2]/255,this.a)}get rgba(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0,this.a*255>>>0]}set rgba(t){this.setTo(t[0]/255,t[1]/255,t[2]/255,t[3]/255)}clone(){return new v().copyFrom(this)}copyFrom(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}copyFromArray(t,e=255){return this.r=t[0]/e,this.g=t[1]/e,this.b=t[2]/e,this.a=t[3]/e,this}copyFromVector(t){return this.r=t.x,this.g=t.y,this.b=t.z,this.a=t.w,this}static hexRGBColor(t,e=null){return e=e||new v,e.hexToRGB(t),e}static lerp(t,e,r,a){let i=a||new v;return i.r=(r.r-e.r)*t+e.r,i.g=(r.g-e.g)*t+e.g,i.b=(r.b-e.b)*t+e.b,i.a=(r.a-e.a)*t+e.a,i}};s(v,"COLOR_RED",new v(1,0,0,1)),s(v,"COLOR_GREEN",new v(0,1,0,1)),s(v,"COLOR_BLUE",new v(0,0,1,1)),s(v,"COLOR_WHITE",new v(1,1,1,1)),s(v,"COLOR_0",new v),s(v,"COLOR_1",new v),s(v,"COLOR_2",new v),s(v,"HEX_CHARACTERS","a-f\\d"),s(v,"MATCH_3OR4_HEX",`#?[${v.HEX_CHARACTERS}]{3}[${v.HEX_CHARACTERS}]?`),s(v,"MATCH_6OR8_HEX",`#?[${v.HEX_CHARACTERS}]{6}([${v.HEX_CHARACTERS}]{2})?`),s(v,"NON_HEX_CHARS",new RegExp(`[^#${v.HEX_CHARACTERS}]`,"gi")),s(v,"VALID_HEX_SIZE",new RegExp(`^${v.MATCH_3OR4_HEX}$|^${v.MATCH_6OR8_HEX}$`,"i")),s(v,"PRIMARY",4149685),s(v,"PRIMARYDARK",3162015),s(v,"ACCENT",16728193),s(v,"WHITE",16777215),s(v,"IVORY",16777200),s(v,"LIGHTYELLOW",16777184),s(v,"YELLOW",16776960),s(v,"SNOW",16775930),s(v,"FLORALWHITE",16775920),s(v,"LEMONCHIFFON",16775885),s(v,"CORNSILK",16775388),s(v,"SEASHELL",16774638),s(v,"LAVENDERBLUSH",16773365),s(v,"PAPAYAWHIP",16773077),s(v,"BLANCHEDALMOND",16772045),s(v,"MISTYROSE",16770273),s(v,"BISQUE",16770244),s(v,"MOCCASIN",16770229),s(v,"NAVAJOWHITE",16768685),s(v,"PEACHPUFF",16767673),s(v,"GOLD",16766720),s(v,"PINK",16761035),s(v,"LIGHTPINK",16758465),s(v,"ORANGE",16753920),s(v,"LIGHTSALMON",16752762),s(v,"DARKORANGE",16747520),s(v,"CORAL",16744272),s(v,"HOTPINK",16738740),s(v,"TOMATO",16737095),s(v,"ORANGERED",16729344),s(v,"DEEPPINK",16716947),s(v,"FUCHSIA",16711935),s(v,"MAGENTA",16711935),s(v,"RED",16711680),s(v,"OLDLACE",16643558),s(v,"LIGHTGOLDENRODYELLOW",16448210),s(v,"LINEN",16445670),s(v,"ANTIQUEWHITE",16444375),s(v,"SALMON",16416882),s(v,"GHOSTWHITE",16316671),s(v,"MINTCREAM",16121850),s(v,"WHITESMOKE",16119285),s(v,"BEIGE",16119260),s(v,"WHEAT",16113331),s(v,"SANDYBROWN",16032864),s(v,"AZURE",15794175),s(v,"HONEYDEW",15794160),s(v,"ALICEBLUE",15792383),s(v,"KHAKI",15787660),s(v,"LIGHTCORAL",15761536),s(v,"PALEGOLDENROD",15657130),s(v,"VIOLET",15631086),s(v,"DARKSALMON",15308410),s(v,"LAVENDER",15132410),s(v,"LIGHTCYAN",14745599),s(v,"BURLYWOOD",14596231),s(v,"PLUM",14524637),s(v,"GAINSBORO",14474460),s(v,"CRIMSON",14423100),s(v,"PALEVIOLETRED",14381203),s(v,"GOLDENROD",14329120),s(v,"ORCHID",14315734),s(v,"THISTLE",14204888),s(v,"LIGHTGREY",13882323),s(v,"TAN",13808780),s(v,"CHOCOLATE",13789470),s(v,"PERU",13468991),s(v,"INDIANRED",13458524),s(v,"MEDIUMVIOLETRED",13047173),s(v,"SILVER",12632256),s(v,"DARKKHAKI",12433259),s(v,"ROSYBROWN",12357519),s(v,"MEDIUMORCHID",12211667),s(v,"DARKGOLDENROD",12092939),s(v,"FIREBRICK",11674146),s(v,"POWDERBLUE",11591910),s(v,"LIGHTSTEELBLUE",11584734),s(v,"PALETURQUOISE",11529966),s(v,"GREENYELLOW",11403055),s(v,"LIGHTBLUE",11393254),s(v,"DARKGRAY",11119017),s(v,"BROWN",10824234),s(v,"SIENNA",10506797),s(v,"DARKORCHID",10040012),s(v,"PALEGREEN",10025880),s(v,"DARKVIOLET",9699539),s(v,"MEDIUMPURPLE",9662683),s(v,"LIGHTGREEN",9498256),s(v,"DARKSEAGREEN",9419919),s(v,"SADDLEBROWN",9127187),s(v,"DARKMAGENTA",9109643),s(v,"DARKRED",9109504),s(v,"BLUEVIOLET",9055202),s(v,"LIGHTSKYBLUE",8900346),s(v,"SKYBLUE",8900331),s(v,"GRAY",8421504),s(v,"OLIVE",8421376),s(v,"PURPLE",8388736),s(v,"MAROON",8388608),s(v,"AQUAMARINE",8388564),s(v,"CHARTREUSE",8388352),s(v,"LAWNGREEN",8190976),s(v,"MEDIUMSLATEBLUE",8087790),s(v,"LIGHTSLATEGRAY",7833753),s(v,"SLATEGRAY",7372944),s(v,"OLIVEDRAB",7048739),s(v,"SLATEBLUE",6970061),s(v,"DIMGRAY",6908265),s(v,"MEDIUMAQUAMARINE",6737322),s(v,"CORNFLOWERBLUE",6591981),s(v,"CADETBLUE",6266528),s(v,"DARKOLIVEGREEN",5597999),s(v,"INDIGO",4915330),s(v,"MEDIUMTURQUOISE",4772300),s(v,"DARKSLATEBLUE",4734347),s(v,"STEELBLUE",4620980),s(v,"ROYALBLUE",4286945),s(v,"TURQUOISE",4251856),s(v,"MEDIUMSEAGREEN",3978097),s(v,"LIMEGREEN",3329330),s(v,"DARKSLATEGRAY",3100495),s(v,"SEAGREEN",3050327),s(v,"FORESTGREEN",2263842),s(v,"LIGHTSEAGREEN",2142890),s(v,"DODGERBLUE",2003199),s(v,"MIDNIGHTBLUE",1644912),s(v,"AQUA",65535),s(v,"CYAN",65535),s(v,"SPRINGGREEN",65407),s(v,"LIME",65280),s(v,"MEDIUMSPRINGGREEN",64154),s(v,"DARKTURQUOISE",52945),s(v,"DEEPSKYBLUE",49151),s(v,"DARKCYAN",35723),s(v,"TEAL",32896),s(v,"GREEN",32768),s(v,"DARKGREEN",25600),s(v,"BLUE",255),s(v,"MEDIUMBLUE",205),s(v,"DARKBLUE",139),s(v,"NAVY",128),s(v,"BLACK",0);let Y=v;class Ae{static start(t){this._startTime=performance.now(),this._timeLabel=t}static end(){console.log(this._timeLabel,performance.now()-this._startTime)}}s(Ae,"time",0),s(Ae,"frame",0),s(Ae,"delta",0),s(Ae,"_startTime",0),s(Ae,"_timeLabel","");class pt{constructor(t=null,e=null){s(this,"target");s(this,"currentTarget");s(this,"type");s(this,"data");s(this,"param");s(this,"time",0);s(this,"delay",0);s(this,"mouseCode",0);s(this,"ctrlKey");s(this,"metaKey");s(this,"altKey");s(this,"shiftKey");s(this,"targetTouches");s(this,"changedTouches");s(this,"touches");s(this,"_stopImmediatePropagation",!1);s(this,"view");this.type=t,this.data=e}stopImmediatePropagation(){this._stopImmediatePropagation=!0}reset(){this._stopImmediatePropagation=!1}get isStopImmediatePropagation(){return this._stopImmediatePropagation}}class Na{constructor(t=null,e=null,r=null,a=null,i=0){s(this,"id",0);s(this,"current");this.type=t,this.thisObject=e,this.handler=r,this.param=a,this.priority=i}equalCurrentListener(t,e,r,a){return this.type==t&&this.thisObject==r&&this.handler==e&&this.param==a}dispose(){this.handler=null,this.thisObject=null,this.param=null,this.priority=0}}s(Na,"event_id_count",0);class ra{constructor(){s(this,"listeners",{});s(this,"data")}dispatchEvent(t){var e=this.listeners[t.type];if(e!=null){e=e.slice();for(var r=0;r<e.length;r++){var a=e[r];if(a.handler){try{t.param=a.param,t.currentTarget=a,a.thisObject,a.handler.call(a.thisObject,t)}catch{}if(t.isStopImmediatePropagation)break}}}}destroy(){for(var t in this.listeners)for(var e=this.listeners[t];e.length>0;){var r=e[0];r.handler=null,r.thisObject=null,e.splice(0,1)}}addEventListener(t,e,r,a=null,i=0){if(this.listeners[t]==null&&(this.listeners[t]=[]),!this.hasEventListener(t,e,r)){var o=new Na(t,r,e,a,i);return o.id=++Na.event_id_count,o.current=this,this.listeners[t].push(o),this.listeners[t].sort(function(l,h){return h.priority-l.priority}),o.id}for(let l=0;l<this.listeners[t].length;l++){let h=this.listeners[t][l];if(h.equalCurrentListener(t,e,r,a))return h.id}return 0}removeEventListener(t,e,r){if(this.hasEventListener(t,e,r))for(var a=0;a<this.listeners[t].length;a++){var i=this.listeners[t][a];if(i.equalCurrentListener(t,e,r,i.param)){i.handler=null,i.thisObject=null,this.listeners[t].splice(a,1);return}}}removeEventListenerAt(t){for(var e in this.listeners)for(var r=0;r<this.listeners[e].length;r++){var a=this.listeners[e][r];if(a.id==t)return a.handler=null,a.thisObject=null,this.listeners[e].splice(r,1),!0}return!1}removeAllEventListener(t=null){let e;if(t){if(this.listeners[t]){for(var r=0;r<this.listeners[t].length;r++)e=this.listeners[t][r],e.dispose(),this.listeners[t].splice(r,1);delete this.listeners[t]}}else for(let a in this.listeners){for(var r=0;r<this.listeners[a].length;r++)e=this.listeners[a][r],e.dispose(),this.listeners[a].splice(r,1);delete this.listeners[a]}}containEventListener(t){return this.listeners[t]==null?!1:this.listeners[t].length>0}hasEventListener(t,e=null,r=null){if(this.listeners[t]==null)return!1;if(r&&e)for(var a=0;a<this.listeners[t].length;a++){var i=this.listeners[t][a];if(i.equalCurrentListener(t,e,r,i.param))return!0}return!1}}class ha extends pt{constructor(){super(...arguments);s(this,"keyCode",0)}}s(ha,"KEY_DOWN","onKeyDown"),s(ha,"KEY_UP","onKeyUp");class G extends pt{constructor(){super(...arguments);s(this,"pointerId");s(this,"pointerType","onPointer");s(this,"isPrimary");s(this,"pressure");s(this,"mouseX");s(this,"mouseY");s(this,"movementX");s(this,"movementY");s(this,"deltaX");s(this,"deltaY");s(this,"deltaZ")}reset(){super.reset(),this.mouseX=0,this.mouseY=0,this.movementX=0,this.movementY=0,this.deltaX=0,this.deltaY=0,this.deltaZ=0}}s(G,"PICK_OVER","onPickOver"),s(G,"PICK_CLICK","onPickClick"),s(G,"PICK_OUT","onPickOut"),s(G,"PICK_MOVE","onPickMove"),s(G,"PICK_UP","onPickUp"),s(G,"PICK_DOWN","onPickDown"),s(G,"POINTER_RIGHT_CLICK","onPointerRightClick"),s(G,"POINTER_CLICK","onPointerClick"),s(G,"POINTER_MOVE","onPointerMove"),s(G,"POINTER_DOWN","onPointerDown"),s(G,"POINTER_UP","onPointerUp"),s(G,"POINTER_OUT","onPointerOut"),s(G,"POINTER_OVER","onPointerOver"),s(G,"POINTER_WHEEL","onPointerWheel");class ye extends pt{constructor(){super(...arguments);s(this,"pointerId");s(this,"pointerType","onPickGUI");s(this,"isPrimary");s(this,"pressure");s(this,"mouseX");s(this,"mouseY");s(this,"movementX");s(this,"movementY");s(this,"deltaX");s(this,"deltaY");s(this,"deltaZ")}reset(){super.reset(),this.mouseX=0,this.mouseY=0,this.movementX=0,this.movementY=0,this.deltaX=0,this.deltaY=0,this.deltaZ=0}}s(ye,"PICK_OVER_GUI","onPickOverGUI"),s(ye,"PICK_CLICK_GUI","onPickClickGUI"),s(ye,"PICK_OUT_GUI","onPickOutGUI"),s(ye,"PICK_UP_GUI","onPickUpGUI"),s(ye,"PICK_DOWN_GUI","onPickDownGUI");const T=class T{constructor(t=0,e=0,r=0,a=0){s(this,"x",0);s(this,"y",0);s(this,"z",0);s(this,"w",1);s(this,"index",0);this.set(t,e,r,a),this.index=T._index++}static get ZERO(){return new T(0,0,0)}static get ONE(){return new T(1,1,1)}static get LEFT(){return new T(-1,0,0)}static get RIGHT(){return new T(1,0,0)}static get UP(){return new T(0,1,0)}static get DOWN(){return new T(0,-1,0)}static get BACK(){return new T(0,0,-1)}static get FORWARD(){return new T(0,0,1)}set a(t){this.w=t}set r(t){this.x=t}set g(t){this.y=t}set b(t){this.z=t}get a(){return this.w}get r(){return this.x}get g(){return this.y}get b(){return this.z}get length(){return Math.sqrt(this.lengthSquared)}get lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}get position(){return this}static getTowPointbyDir(t,e,r,a,i){i==T.Z_AXIS?(e.x=t.y,e.y=-t.x,r.x=-t.y,r.y=t.x,e.scaleBy(a*.5),r.scaleBy(a*.5)):i==T.Y_AXIS&&(e.x=t.z,e.z=-t.x,r.x=-t.z,r.z=t.x,e.scaleBy(a*.5),r.scaleBy(a*.5))}static pointToLine(t,e,r){let a=0,i,o,l;if(i=T.distance(t,e),o=T.distance(t,r),l=T.distance(e,r),l<=1e-6||o<=1e-6)return a=0,a;if(i<=1e-6||l*l>=i*i+o*o)return a=o,a;if(o*o>=i*i+l*l)return a=l,a;let h=(i+o+l)/2;return a=2*Math.sqrt(h*(h-i)*(h-o)*(h-l))/i,a}static dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static getPoints(t,e){let r=[];for(let a=0;a<t;a++){const i=new T(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);r.push(i)}return r}static getPointNumbers(t,e){let r=[];for(let a=0;a<t;a++)r.push(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);return r}static getAngle(t,e){let r=t.dotProduct(e)/(t.length*e.length);return Math.acos(r)*180/Math.PI}static sqrMagnitude(t){return t.x*t.x+t.y*t.y+t.z*t.z}static getZYAngle(t,e){return this.calAngle(t.y,t.z,e.y,e.z)}static sub(t,e,r=null){return r=r||new T,r.x=t.x-e.x,r.y=t.y-e.y,r.z=t.z-e.z,r}static add(t,e,r=null){return r=r||new T,r.x=t.x+e.x,r.y=t.y+e.y,r.z=t.z+e.z,r}static smoothDamp(t,e,r,a,i,o){return null}static distance(t,e){var r=t.x-e.x,a=t.y-e.y,i=t.z-e.z;return Math.sqrt(r*r+a*a+i*i)}static squareDistance(t,e){var r=t.x-e.x,a=t.y-e.y,i=t.z-e.z;return r*r+a*a+i*i}static distanceXZ(t,e){var r=t.x-e.x,a=0,i=t.z-e.z;return Math.sqrt(r*r+a*a+i*i)}set(t,e,r,a=1){return this.x=t,this.y=e,this.z=r,this.w=a,this}add(t,e=null){e||(e=new T);var r=this.x,a=this.y,i=this.z,o=this.w,l=t.x,h=t.y,c=t.z,u=t.w;return e.setTo(r+l,a+h,i+c,o+u),e}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}min(t,e=this){return e.x=Math.min(this.x,t.x),e.y=Math.min(this.y,t.y),e.z=Math.min(this.z,t.z),e}max(t,e=this){return e.x=Math.max(this.x,t.x),e.y=Math.max(this.y,t.y),e.z=Math.max(this.z,t.z),e}distanceToSquared(t){let e=this.x-t.x,r=this.y-t.y,a=this.z-t.z;return e*e+r*r+a*a}addXYZW(t,e,r,a,i=null){i||(i=new T);var o=this.x,l=this.y,h=this.z,c=this.w,u=t,d=e,f=r,A=a;return i.setTo(o+u,l+d,h+f,c+A),i}clone(){return new T(this.x,this.y,this.z,this.w)}copyFrom(t){var e=this;return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}decrementBy(t){this.x-=t.x,this.y-=t.y,this.z-=t.z}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}equals(t,e=!1){return this.x==t.x&&this.y==t.y&&this.z==t.z&&(!e||this.w==t.w)}incrementBy(t){this.x+=t.x,this.y+=t.y,this.z+=t.z}divide(t){return t instanceof T?new T(this.x/t.x,this.y/t.y,this.z/t.z):(this.x=this.x/t,this.y=this.y/t,this.z=this.z/t,this)}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}normalize(t=1){let e=this;if(this.length!=0){var r=t/this.length;return this.x*=r,this.y*=r,this.z*=r,e}return e}applyQuaternion(t){const e=this.x,r=this.y,a=this.z,i=t.x,o=t.y,l=t.z,h=t.w,c=h*e+o*a-l*r,u=h*r+l*e-i*a,d=h*a+i*r-o*e,f=-i*e-o*r-l*a;return this.x=c*h+f*-i+u*-l-d*-o,this.y=u*h+f*-o+d*-i-c*-l,this.z=d*h+f*-l+c*-o-u*-i,this}applyMatrix4(t){return t.transformPoint(this,this)}scaleBy(t){return this.x*=t,this.y*=t,this.z*=t,this}mul(t){let e=new T;return e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}scale(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}scaleToRef(t,e){return e||(e=new T),e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}setTo(t,e,r,a=1){this.x=t,this.y=e,this.z=r,this.w=a}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}subtract(t,e=null){return e||(e=new T),e.setTo(this.x-t.x,this.y-t.y,this.z-t.z),e}multiply(t,e=null){e||(e=new T);var r=this.x,a=this.y,i=this.z,o=t.x,l=t.y,h=t.z;return e.setTo(r*o,a*l,i*h),e}divided(t,e=null){e||(e=new T);var r=this.x,a=this.y,i=this.z,o=t.x,l=t.y,h=t.z;return e.setTo(r/o,a/l,i/h),e}div(t,e){e||(e=new T);var r=this.x,a=this.y,i=this.z,o=this.w;return e.setTo(r/t,a/t,i/t,o/t),e}lerp(t,e,r){var a=t.x,i=t.y,o=t.z,l=t.w,h=e.x,c=e.y,u=e.z,d=e.w;this.x=(h-a)*r+a,this.y=(c-i)*r+i,this.z=(u-o)*r+o,this.w=(d-l)*r+l}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}toString(){return"<"+this.x+", "+this.y+", "+this.z+">"}normalizeToWay2D_XY(){let t=Math.abs(this.x),e=Math.abs(this.y);t>e?this.x>0?this.copyFrom(T.RIGHT):this.copyFrom(T.LEFT):this.y>0?this.copyFrom(T.DOWN):this.copyFrom(T.UP)}toArray(){return[this.x,this.y,this.z]}copyToBytes(t){t.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this.x,!0),t.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,this.y,!0),t.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,this.z,!0)}crossProduct(t,e=null){return e=e||new T,e.x=this.y*t.z-this.z*t.y,e.y=this.z*t.x-this.x*t.z,e.z=this.x*t.y-this.y*t.x,e.w=1,e}crossVectors(t,e){return t.crossProduct(e,this),this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}setFromArray(t,e=0){this.x=t[e],this.y=t[e+1],this.z=t[e+2]}divideScalar(t){return this.multiplyScalar(1/t)}clampLength(t,e){let r=this.length;return this.divideScalar(r||1).multiplyScalar(Math.max(t,Math.min(e,r)))}setScalar(t){return this.x=t,this.y=t,this.z=t,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}static calAngle(t,e,r,a){const i=l(r,a,t,e);let o=Math.acos(i)*180/Math.PI;return r<t&&(o=-o),o;function l(c,u,d,f){let A=[c-d,u-f];return h(A,[0,-1])}function h(c,u){let d=c[0]*u[0]+c[1]*u[1],f=Math.sqrt(c[0]*c[0]+c[1]*c[1])*Math.sqrt(u[0]*u[0]+u[1]*u[1]);return d/f}}static pointInsideTriangle(t,e,r,a){return T.HELP_0.setTo(t.x,t.z,0),T.HELP_1.setTo(e.x,e.z,0),T.HELP_2.setTo(r.x,r.z,0),T.HELP_3.setTo(a.x,a.z,0),T.pointInsideTriangle2d()}static pointInsideTriangle2d(){return T.productXY(T.HELP_1,T.HELP_2,T.HELP_3)>=0?T.productXY(T.HELP_1,T.HELP_2,T.HELP_0)>=0&&T.productXY(T.HELP_2,T.HELP_3,T.HELP_0)>=0&&T.productXY(T.HELP_3,T.HELP_1,T.HELP_0)>=0:T.productXY(T.HELP_1,T.HELP_2,T.HELP_0)<=0&&T.productXY(T.HELP_2,T.HELP_3,T.HELP_0)<=0&&T.productXY(T.HELP_3,T.HELP_1,T.HELP_0)<=0}static productXY(t,e,r){var a=(t.x-r.x)*(e.y-r.y)-(t.y-r.y)*(e.x-r.x);return a>-1e-5&&a<1e-5&&(a=0),a}static serialize(t){return new T(t.x,t.y,t.z,t.w)}};s(T,"MAX",new T(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)),s(T,"MIN",new T(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE)),s(T,"SAFE_MAX",new T(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),s(T,"SAFE_MIN",new T(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER)),s(T,"X_AXIS",new T(1,0,0)),s(T,"neg_X_AXIS",new T(-1,0,0)),s(T,"Y_AXIS",new T(0,1,0)),s(T,"Z_AXIS",new T(0,0,1)),s(T,"HELP_0",new T),s(T,"HELP_1",new T),s(T,"HELP_2",new T),s(T,"EPSILON",1e-5),s(T,"HELP_3",new T),s(T,"HELP_4",new T),s(T,"HELP_5",new T),s(T,"HELP_6",new T),s(T,"_index",0);let g=T;class go{constructor(t){s(this,"canvasX");s(this,"canvasY");s(this,"identifier");s(this,"clientX");s(this,"clientY");s(this,"pageX");s(this,"pageY");s(this,"screenX");s(this,"screenY");this.canvasX=t.clientX,this.canvasY=t.clientY,this.identifier=t.identifier,this.clientX=t.clientX,this.clientY=t.clientY,this.pageX=t.pageX,this.pageY=t.pageY,this.screenX=t.screenX,this.screenY=t.screenY}}class po extends ra{constructor(){super(...arguments);s(this,"canvasX",0);s(this,"canvasY",0);s(this,"isMouseDown",!1);s(this,"canvas");s(this,"mouseX",0);s(this,"mouseY",0);s(this,"wheelDelta",0);s(this,"mouseOffsetX",0);s(this,"mouseOffsetY",0);s(this,"mouseLastX",0);s(this,"mouseLastY",0);s(this,"_time",0);s(this,"_keyStatus");s(this,"_mouseStatus");s(this,"_isTouchStart");s(this,"_keyEvent3d");s(this,"_pointerEvent3D");s(this,"_windowsEvent3d");s(this,"mouseLock",!1);s(this,"_oldPosition1",null);s(this,"_oldPosition2",null);s(this,"_downTime",0)}initCanvas(e){this.canvas=e;let r=0,a=0,i=0,o=0;e.onpointerdown=h=>{r=performance.now(),a=h.clientX,i=h.clientY,o=h.button,this.mouseStart(h),e.setPointerCapture(h.pointerId)},e.onpointerup=h=>{this.mouseEnd(h),h.button===o&&performance.now()-r<300&&Math.abs(a-h.clientX)<20&&Math.abs(i-h.clientY)<20&&(h.button===0?this.mouseClick(h):this.rightClick(h)),e.releasePointerCapture(h.pointerId)},e.onpointerenter=h=>{this.mouseOver(h)},e.onpointermove=h=>{this.mouseMove(h)},e.onpointercancel=h=>{e.releasePointerCapture(h.pointerId),this.mouseEnd(h)},e.addEventListener("wheel",h=>this.mouseWheel(h),{passive:!1}),window.addEventListener("keydown",h=>this.keyDown(h),!0),window.addEventListener("keyup",h=>this.keyUp(h),!0),e.oncontextmenu=function(){return!1};let l=this.canvas.getBoundingClientRect();this.canvasX=l.left,this.canvasY=l.top,this._keyStatus={},this._mouseStatus={},this._isTouchStart=!1,this._keyEvent3d=new ha,this._pointerEvent3D=new G,this._windowsEvent3d=new pt}useMouseLock(){this.mouseLock||(this.canvas.requestPointerLock(),this.mouseLock=!0,document.addEventListener("mousemove",e=>this.onMouseLockMove(e),!1))}releaseMouseLock(){this.mouseLock=!1,document.exitPointerLock(),document.removeEventListener("mousemove",e=>this.onMouseLockMove(e),!1)}onMouseLockMove(e){this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=e.movementX,this.mouseOffsetY=e.movementY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=G.POINTER_MOVE,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.movementX=e.movementX,this._pointerEvent3D.movementY=e.movementY,this.dispatchEvent(this._pointerEvent3D)}onPinch(e,r,a,i){this._oldPosition1=new g(e,r),this._oldPosition2=new g(a,i)}onSwipe(e,r){this.mouseX=e,this.mouseY=r,this._oldPosition1=null,this._oldPosition2=null,this._time=new Date().getTime()}GetTargetTouches(e){for(var r=new Array,a=0;a<e.length;a++){var i=new go(e[a]);r.push(i)}return r}rightClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=G.POINTER_RIGHT_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}mouseClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=G.POINTER_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}mouseEnd(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._mouseStatus[this._pointerEvent3D.mouseCode]=!1,this._pointerEvent3D.type=G.POINTER_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseStart(e){this.isMouseDown=!0,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId?e.pointerId:0,this._pointerEvent3D.pointerType=e.pointerType?e.pointerType:0,this._pointerEvent3D.isPrimary=e.isPrimary?e.isPrimary:0,this._pointerEvent3D.pressure=e.pressure?e.pressure:0,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.type=G.POINTER_DOWN,this.dispatchEvent(this._pointerEvent3D)}mouseMove(e){this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=G.POINTER_MOVE,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.movementX=e.movementX,this._pointerEvent3D.movementY=e.movementY,this.dispatchEvent(this._pointerEvent3D)}mouseOver(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=G.POINTER_OVER,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseWheel(e){e.preventDefault(),this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,"wheelDelta"in e?(this._pointerEvent3D.delay=e.wheelDelta,this.wheelDelta=e.wheelDelta):"delta"in e&&(this.wheelDelta=e.delta),this._pointerEvent3D.reset(),this._pointerEvent3D.type=G.POINTER_WHEEL,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.deltaX=e.deltaX,this._pointerEvent3D.deltaY=e.deltaY,this._pointerEvent3D.deltaZ=e.deltaZ,this.dispatchEvent(this._pointerEvent3D)}keyDown(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyEvent3d.ctrlKey=e.ctrlKey,this._keyEvent3d.altKey=e.altKey,this._keyEvent3d.shiftKey=e.shiftKey,this._keyStatus[e.keyCode]||(this._keyStatus[e.keyCode]=!0,this._keyEvent3d.type=ha.KEY_DOWN,this.dispatchEvent(this._keyEvent3d))}keyUp(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyStatus[e.keyCode]=!1,this._keyEvent3d.type=ha.KEY_UP,this.dispatchEvent(this._keyEvent3d)}GetSlideAngle(e,r){return Math.atan2(r,e)*180/Math.PI}GetSlideDirection(e,r,a,i){var o=r-i,l=a-e,h=0;if(Math.abs(l)<2&&Math.abs(o)<2)return h;var c=this.GetSlideAngle(l,o);return c>=-45&&c<45?h=4:c>=45&&c<135?h=1:c>=-135&&c<-45?h=2:(c>=135&&c<=180||c>=-180&&c<-135)&&(h=3),h}}const mo="0.8.5-dev.5";class pr extends pt{}s(pr,"RESIZE","resize");class Uo extends ra{constructor(){super(...arguments);s(this,"adapter");s(this,"device");s(this,"context");s(this,"aspect");s(this,"presentationSize",[0,0]);s(this,"presentationFormat");s(this,"canvas");s(this,"windowWidth");s(this,"windowHeight");s(this,"canvasConfig");s(this,"_pixelRatio",1);s(this,"_resizeEvent")}get pixelRatio(){return this._pixelRatio}async init(e){if(this.canvasConfig=e,e&&e.canvas){if(this.canvas=e.canvas,this.canvas===null)throw new Error("no Canvas");this.canvas.style.width||(this.canvas.style.width=this.canvas.width+"px"),this.canvas.style.height||(this.canvas.style.height=this.canvas.height+"px")}else this.canvas=document.createElement("canvas"),this.canvas.style.position="absolute",this.canvas.style.top="0px",this.canvas.style.left="0px",this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.zIndex=e!=null&&e.zIndex?e.zIndex.toString():"0",document.body.appendChild(this.canvas);if(e&&e.backgroundImage?(this.canvas.style.background=`url(${e.backgroundImage})`,this.canvas.style["background-size"]="cover",this.canvas.style["background-position"]="center"):this.canvas.style.background="transparent",this.canvas.style["touch-action"]="none",this.canvas.style["object-fit"]="cover",navigator.gpu===void 0)throw new Error("Your browser does not support WebGPU!");if(this.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),this.adapter==null)throw new Error("Your browser does not support WebGPU!");if(this.device=await this.adapter.requestDevice({requiredFeatures:["bgra8unorm-storage","depth-clip-control","depth32float-stencil8","indirect-first-instance","rg11b10ufloat-renderable"],requiredLimits:{minUniformBufferOffsetAlignment:256,maxStorageBufferBindingSize:this.adapter.limits.maxStorageBufferBindingSize}}),this.device==null)throw new Error("Your browser does not support WebGPU!");return this.device.label="device",this.presentationFormat=navigator.gpu.getPreferredCanvasFormat(),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:this.presentationFormat,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"premultiplied",colorSpace:"srgb"}),this._resizeEvent=new pr(pr.RESIZE,{width:this.windowWidth,height:this.windowHeight}),new ResizeObserver(()=>{this.updateSize(),rt.destroyTexture()}).observe(this.canvas),this.updateSize(),!0}updateSize(){var a;this._pixelRatio=((a=this.canvasConfig)==null?void 0:a.devicePixelRatio)||window.devicePixelRatio||1,this._pixelRatio=Math.min(this._pixelRatio,2);let e=Math.floor(this.canvas.clientWidth*this._pixelRatio),r=Math.floor(this.canvas.clientHeight*this._pixelRatio);(e!=this.windowWidth||r!=this.windowHeight)&&(this.canvas.width=this.windowWidth=e,this.canvas.height=this.windowHeight=r,this.presentationSize[0]=this.windowWidth,this.presentationSize[1]=this.windowHeight,this.aspect=this.windowWidth/this.windowHeight,this._resizeEvent.data.width=this.windowWidth,this._resizeEvent.data.height=this.windowHeight,this.dispatchEvent(this._resizeEvent))}}let R=new Uo;var de=(n=>(n[n.Default=1]="Default",n[n.IgnoreDepthPass=2]="IgnoreDepthPass",n[n.Sky=6]="Sky",n[n.Particle=10]="Particle",n[n.SkinnedMesh=16]="SkinnedMesh",n[n.MorphTarget=32]="MorphTarget",n[n.Terrain=64]="Terrain",n[n.UI=128]="UI",n[n.Reflection=256]="Reflection",n[n.ReflectionDebug=512]="ReflectionDebug",n[n.Graphic3D=1024]="Graphic3D",n))(de||{});class Mt{static addMask(t,e){return t|e}static removeMask(t,e){return t&~e}static hasMask(t,e){return(t&e)==e}}const ne=class ne{constructor(t=0,e=0){s(this,"x",0);s(this,"y",0);this.x=t,this.y=e}static getAngle(t,e){return Math.atan2(e.y-t.y,e.x-t.x)}static slerp(t,e,r){let a=new ne,i=t.dot(e);if(i<0&&(e.x=-e.x,e.y=-e.y,i=-i),i>.9995)return a.x=t.x+r*(e.x-t.x),a.y=t.y+r*(e.y-t.y),a;let o=Math.acos(i),l=Math.sin(o),h=Math.sin((1-r)*o)/l,c=Math.sin(r*o)/l;return a.x=h*t.x+c*e.x,a.y=h*t.y+c*e.y,a}static lerp(t,e,r){return ne.HELP_0.copyFrom(t),ne.HELP_1.copyFrom(e),ne.HELP_0.scale(r),ne.HELP_1.scale(1-r),new ne(ne.HELP_0.x+ne.HELP_1.x,ne.HELP_0.y+ne.HELP_1.y)}set(t=0,e=0){return this.x=t,this.y=e,this}distance(t){return Math.sqrt(Math.pow(this.x-t.x,2)+Math.pow(this.y-t.y,2))}add(t,e){return e=e||new ne,e.x=this.x+t.x,e.y=this.y+t.y,e}sub(t,e){return e=e||new ne,e.x=this.x-t.x,e.y=this.y-t.y,e}scale(t){return this.x=this.x*t,this.y=this.y*t,this}multiply(t,e){return e=e||new ne,e.x=this.x*t,e.y=this.y*t,e}multiplyScaler(t){return this.x*=t,this.y*=t,this}divide(t,e){return e=e||new ne,e.x=this.x/t,e.y=this.y/t,e}neg(t){return t||(t=new ne),t.x=-t.x,t.y=-t.y,t}abs(){return Math.sqrt(this.x*this.x+this.y*this.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}getAngle(t){return Math.atan2(t.y-this.y,t.x-this.x)}unt(t){t=t||new ne;let e=this.abs();return t.x=this.x/e,t.y=this.y/e,t}angleTo(t){let e=t.x-this.x,r=t.y-this.y;return Math.atan2(r,e)}equals(t){return Math.abs(this.x-t.x)<1e-6&&Math.abs(this.y-t.y)<1e-6}pal(t){let e=this.unt(),r=t.unt();return e.equals(r)?1:e.equals(r.neg())?-1:0}clone(){return new ne(this.x,this.y)}copyFrom(t){return this.x=t.x,this.y=t.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}dot(t){return this.x*t.x+this.y*t.y}normalize(){let t=this.abs();return this.x=this.x/t,this.y=this.y/t,this}addInPlace(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}};s(ne,"HELP_0",new ne),s(ne,"HELP_1",new ne),s(ne,"HELP_2",new ne),s(ne,"ZERO",new ne(0,0)),s(ne,"SAFE_MAX",new ne(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),s(ne,"SAFE_MIN",new ne(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER));let Ie=ne;const K=class K{constructor(t=0,e=0,r=0,a=0){s(this,"x",0);s(this,"y",0);s(this,"z",0);s(this,"w",1);this.x=t,this.y=e,this.z=r,this.w=a}get width(){return this.z}get height(){return this.w}static crossVectors(t,e,r){r=r||new K;var a=t.x,i=t.y,o=t.z,l=e.x,h=e.y,c=e.z;return r.x=i*c-o*h,r.y=o*l-a*c,r.z=a*h-i*l,r}static distance(t,e){let r=t.x-e.x,a=t.y-e.y,i=t.z-e.z,o=t.w-e.w;return Math.sqrt(r*r+a*a+i*i+o*o)}set(t,e,r,a){return this.x=t,this.y=e,this.z=r,this.w=a,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}copyFrom(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}clone(){return new K(this.x,this.y,this.z,this.w)}};s(K,"X_AXIS",new K(1,0,0)),s(K,"Y_AXIS",new K(0,1,0)),s(K,"Z_AXIS",new K(0,0,1)),s(K,"HELP_0",new K),s(K,"HELP_1",new K),s(K,"HELP_2",new K),s(K,"EPSILON",1e-5),s(K,"HELP_3",new K),s(K,"HELP_4",new K),s(K,"HELP_5",new K),s(K,"HELP_6",new K),s(K,"ZERO",new K),s(K,"ONE",new K(1,1,1,1)),s(K,"LEFT",new K(-1,0,0)),s(K,"RIGHT",new K(1,0,0)),s(K,"UP",new K(0,-1,0)),s(K,"DOWN",new K(0,1,0)),s(K,"BACK",new K(0,0,-1)),s(K,"FORWARD",new K(0,0,1));let j=K;function As(n,t){let e=n.__NonSerialize__;e||(e=n.__NonSerialize__={},e.__NonSerialize__=!0),e[t]=!0}function gs(n,t){let e;for(;n&&(n=n.__proto__,n&&(e=n.__NonSerialize__),!e););return e&&e[t]}function ca(n,t,e,r,a){let i=n.__EditorInspector__;i||(i=n.__EditorInspector__=new Map);let o=i.get(n.constructor.name);o||(o=new Map,i.set(n.constructor.name,o)),o.set(t,{p1:e,p2:r,p3:a})}function Tt(n,t,e,r,a){let i=window.__Component__;i||(i=window.__Component__={}),i[t]=n}function Bo(n){let t=window.__Component__;return t[n]?t[n]:null}function Mr(n,t,e,r,a){let i=window.__shader__;i||(i=window.__shader__={}),i[t]=n}function Fo(n){let t=window.__shader__;return t[n]?t[n]:null}var Co=Object.defineProperty,ps=(n,t,e,r)=>{for(var a=void 0,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(t,e,a)||a);return a&&Co(t,e,a),a},Gt;const Bi=(Gt=class{constructor(){s(this,"__refection");s(this,"__size",0)}getValueType(){if(!this.__refection){let t=this;this.__refection=[];for(const e in t)if(!gs(this,e)){const r=t[e];let a={name:e,type:r.constructor.name};this.__refection.push(a)}}return this.__refection}static getValueSize(t){switch(t.constructor.name){case"Boolean":return 1*4;case"Number":return 1*4;case"f32":return 1*4;case"i32":return 1*4;case"u32":return 1*4;case"Float32Array":return t.byteLength;case"Vector2":return 2*4;case"Vector3":return 3*4;case"Vector4":return 4*4;case"Color":return 4*4;case"Array":let e=0;for(let r=0,a=t.length;r<a;r++)e+=Gt.getValueSize(t[r]);return e}return 0}static Ref(t){return this.Get(t).getValueType()}static Get(t){let e=Gt.__cacheStruct.get(t.prototype);return e||(e=new t,Gt.__cacheStruct.set(t.prototype,e)),e}static GetSize(t){let e=this.Get(t);if(e.__size==0){for(const r in e)if(!gs(e,r)){const a=e[r];e.__size+=Gt.getValueSize(a)}e.__size>4&&(e.__size=Math.ceil(e.__size/4)*4)}return e.__size}},s(Gt,"__cacheStruct",new Map),Gt);ps([As],Bi.prototype,"__refection"),ps([As],Bi.prototype,"__size");let xa=Bi;class Qo{constructor(){s(this,"byteOffset");s(this,"byteSize");s(this,"offset",0);s(this,"dataBytes")}get x(){return this.dataBytes.getFloat32(0*Float32Array.BYTES_PER_ELEMENT,!0)}set x(t){this.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,t,!0)}get y(){return this.dataBytes.getFloat32(1*Float32Array.BYTES_PER_ELEMENT,!0)}set y(t){this.dataBytes.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,t,!0)}get z(){return this.dataBytes.getFloat32(2*Float32Array.BYTES_PER_ELEMENT,!0)}set z(t){this.dataBytes.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,t,!0)}get w(){return this.dataBytes.getFloat32(3*Float32Array.BYTES_PER_ELEMENT,!0)}set w(t){this.dataBytes.setFloat32(3*Float32Array.BYTES_PER_ELEMENT,t,!0)}setX(t){this.x=t}setXY(t,e){this.x=t,this.y=e}setXYZ(t,e,r){this.x=t,this.y=e,this.z=r}setXYZW(t,e,r,a){this.x=t,this.y=e,this.z=r,this.w=a}setVector2Array(t){for(let e=0;e<t.length;e++){const r=t[e];this.dataBytes.setFloat32((e*2+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((e*2+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0)}}setVector3Array(t){for(let e=0;e<t.length;e++){const r=t[e];this.dataBytes.setFloat32((e*3+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((e*3+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((e*3+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0)}}setVector4Array(t){for(let e=0;e<t.length;e++){const r=t[e];this.dataBytes.setFloat32((e*4+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((e*4+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((e*4+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0),this.dataBytes.setFloat32((e*4+3)*Float32Array.BYTES_PER_ELEMENT,r.w,!0)}}setColorArray(t){for(let e=0;e<t.length;e++){const r=t[e];this.dataBytes.setFloat32((e*4+0)*Float32Array.BYTES_PER_ELEMENT,r.r,!0),this.dataBytes.setFloat32((e*4+1)*Float32Array.BYTES_PER_ELEMENT,r.g,!0),this.dataBytes.setFloat32((e*4+2)*Float32Array.BYTES_PER_ELEMENT,r.b,!0),this.dataBytes.setFloat32((e*4+3)*Float32Array.BYTES_PER_ELEMENT,r.a,!0)}}setInt8(t,e=0){this.dataBytes.setInt8(e*Int8Array.BYTES_PER_ELEMENT,t)}getInt8(t=0){return this.dataBytes.getInt8(t*Int8Array.BYTES_PER_ELEMENT)}setInt16(t,e=0){this.dataBytes.setInt16(e*Int16Array.BYTES_PER_ELEMENT,t,!0)}getInt16(t=0){return this.dataBytes.getInt16(t*Int16Array.BYTES_PER_ELEMENT,!0)}setInt32(t,e=0){this.dataBytes.setInt32(e*Int32Array.BYTES_PER_ELEMENT,t,!0)}getInt32(t=0){return this.dataBytes.getInt32(t*Int32Array.BYTES_PER_ELEMENT,!0)}setFloat(t,e=0){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t,!0)}getFloat(t=0){return this.dataBytes.getFloat32(t*Float32Array.BYTES_PER_ELEMENT,!0)}setUint8(t,e=0){this.dataBytes.setUint8(e*Uint8Array.BYTES_PER_ELEMENT,t)}getUint8(t=0){return this.dataBytes.getUint8(t*Uint8Array.BYTES_PER_ELEMENT)}setUint16(t,e=0){this.dataBytes.setUint16(e*Uint16Array.BYTES_PER_ELEMENT,t,!0)}getUint16(t=0){return this.dataBytes.getUint16(t*Uint16Array.BYTES_PER_ELEMENT,!0)}setUint32(t,e=0){this.dataBytes.setUint32(e*Uint32Array.BYTES_PER_ELEMENT,t,!0)}getUint32(t=0){return this.dataBytes.getUint32(t*Uint32Array.BYTES_PER_ELEMENT,!0)}setArray(t,e){for(let r=0;r<e.length;r++){const a=e[r];this.dataBytes.setFloat32((t+r)*Float32Array.BYTES_PER_ELEMENT,a,!0)}}setFloat32Array(t,e){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Float32Array.BYTES_PER_ELEMENT,e.length).set(e)}setFloatArray(t,e){let r;e instanceof Float32Array?r=e:r=new Float32Array(e),new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Float32Array.BYTES_PER_ELEMENT,r.length).set(r)}setArrayBuffer(t,e){e instanceof Uint8Array?this.setUint8Array(t,e):e instanceof Uint16Array?this.setUint16Array(t,e):e instanceof Uint32Array?this.setUint32Array(t,e):e instanceof Int8Array?this.setInt8Array(t,e):e instanceof Int16Array?this.setInt16Array(t,e):e instanceof Int32Array?this.setInt32Array(t,e):e instanceof Float32Array&&this.setFloat32Array(t,e)}setInt8Array(t,e){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Int8Array.BYTES_PER_ELEMENT).set(e)}setInt16Array(t,e){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Int16Array.BYTES_PER_ELEMENT).set(e)}setInt32Array(t,e){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Int32Array.BYTES_PER_ELEMENT).set(e)}setUint8Array(t,e){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Uint8Array.BYTES_PER_ELEMENT).set(e)}setUint16Array(t,e){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Uint16Array.BYTES_PER_ELEMENT).set(e)}setUint32Array(t,e){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Uint32Array.BYTES_PER_ELEMENT).set(e)}setData(t,e){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e,!0)}setVector2(t,e){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e.x,!0),this.dataBytes.setFloat32((t+1)*Float32Array.BYTES_PER_ELEMENT,e.y,!0)}setVector3(t,e){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e.x,!0),this.dataBytes.setFloat32((t+1)*Float32Array.BYTES_PER_ELEMENT,e.y,!0),this.dataBytes.setFloat32((t+2)*Float32Array.BYTES_PER_ELEMENT,e.z,!0)}setVector4(t,e){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e.x,!0),this.dataBytes.setFloat32((t+1)*Float32Array.BYTES_PER_ELEMENT,e.y,!0),this.dataBytes.setFloat32((t+2)*Float32Array.BYTES_PER_ELEMENT,e.z,!0),this.dataBytes.setFloat32((t+3)*Float32Array.BYTES_PER_ELEMENT,e.w,!0)}setColor(t,e){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e.r,!0),this.dataBytes.setFloat32((t+1)*Float32Array.BYTES_PER_ELEMENT,e.g,!0),this.dataBytes.setFloat32((t+2)*Float32Array.BYTES_PER_ELEMENT,e.b,!0),this.dataBytes.setFloat32((t+3)*Float32Array.BYTES_PER_ELEMENT,e.a,!0)}getData(t){return this.dataBytes.getFloat32(t*Float32Array.BYTES_PER_ELEMENT,!0)}writeFloat(t){this.dataBytes.setFloat32(this.offset,t,!0),this.offset+=Float32Array.BYTES_PER_ELEMENT}writeInt8(t){this.dataBytes.setInt8(this.offset,t),this.offset+=Int8Array.BYTES_PER_ELEMENT}writeInt16(t){this.dataBytes.setInt16(this.offset,t,!0),this.offset+=Int16Array.BYTES_PER_ELEMENT}writeInt32(t){this.dataBytes.setInt32(this.offset,t,!0),this.offset+=Int32Array.BYTES_PER_ELEMENT}writeUint8(t){this.dataBytes.setUint8(this.offset,t),this.offset+=Uint8Array.BYTES_PER_ELEMENT}writeUint16(t){this.dataBytes.setUint16(this.offset,t,!0),this.offset+=Uint16Array.BYTES_PER_ELEMENT}writeUint32(t){this.dataBytes.setUint32(this.offset,t,!0),this.offset+=Uint32Array.BYTES_PER_ELEMENT}writeVector2(t){this.writeFloat(t.x),this.writeFloat(t.y)}writeVector3(t){this.writeFloat(t.x),this.writeFloat(t.y),this.writeFloat(t.z)}writeVector4(t){this.writeFloat(t.x),this.writeFloat(t.y),this.writeFloat(t.z),this.writeFloat(t.w)}writeRGBColor(t){this.writeFloat(t.r),this.writeFloat(t.g),this.writeFloat(t.b)}writeArray(t){for(let e=0;e<t.length;e++){const r=t[e];this.writeFloat(r)}}writeFloat32Array(t){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeInt8Array(t){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeInt16Array(t){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeInt32Array(t){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeUint8Array(t){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeUint16Array(t){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeUint32Array(t){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}reset(){this.offset=0}destroy(){this.byteOffset=null,this.byteSize=null,this.offset=null,this.dataBytes=null}}class Ma{constructor(){s(this,"shareDataBuffer");s(this,"_byteOffset",0)}allocation(t){this.shareDataBuffer&&this.shareDataBuffer.byteLength<t?this._byteOffset=0:this.shareDataBuffer=new ArrayBuffer(t)}allocation_node(t){if(this._byteOffset+t>this.shareDataBuffer.byteLength)return console.error("memory not enough!",this._byteOffset,t,this.shareDataBuffer.byteLength),null;let e=new Qo;return e.byteOffset=this._byteOffset,e.byteSize=t,e.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,e.byteSize),this._byteOffset+=e.byteSize,e}allocation_memory(t){return this._byteOffset+t.byteSize>this.shareDataBuffer.byteLength?(console.error("memory not enough!",this._byteOffset,t.byteSize,this.shareDataBuffer.byteLength),null):(t.byteOffset=this._byteOffset,t.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,t.byteSize),this._byteOffset+=t.byteSize,t)}reset(){this._byteOffset=0}destroy(t){this.shareDataBuffer=null,this._byteOffset=0}}class kr{constructor(){s(this,"bufferType");s(this,"buffer");s(this,"memory");s(this,"memoryNodes");s(this,"seek");s(this,"outFloat32Array");s(this,"byteSize");s(this,"usage");s(this,"visibility",GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE);s(this,"mapAsyncBuffersOutstanding",0);s(this,"mapAsyncReady");s(this,"_readBuffer");s(this,"_dataView");s(this,"_readFlag",!1);this.mapAsyncReady=[]}debug(){}reset(t=!1,e=0,r){this.seek=0,this.memory.reset(),t&&this.createBuffer(this.usage,e,r)}setBoolean(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(t,r)),r.setX(e?1:0)}readBoole(t){let e=this.memoryNodes.get(t);return e?e.getFloat()!=0:null}setFloat(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(t,r)),r.setX(e)}getFloat(t){let e=this.memoryNodes.get(t);return e?e.getFloat():null}setInt8(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(t,r)),r.setInt8(e)}getInt8(t){let e=this.memoryNodes.get(t);return e?e.getInt8():null}setInt16(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(t,r)),r.setInt16(e)}getInt16(t){let e=this.memoryNodes.get(t);return e?e.getInt16():null}setInt32(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(t,r)),r.setInt32(e)}getInt32(t){let e=this.memoryNodes.get(t);return e?e.getInt32():null}setUint8(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(t,r)),r.setUint8(e)}getUint8(t){let e=this.memoryNodes.get(t);return e?e.getUint8():null}setUint16(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(t,r)),r.setUint16(e)}getUint16(t){let e=this.memoryNodes.get(t);return e?e.getUint16():null}setUint32(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(t,r)),r.setUint32(e)}getUint32(t){let e=this.memoryNodes.get(t);return e?e.getUint32():null}setVector2(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(2*4),this.memoryNodes.set(t,r)),r.setXY(e.x,e.y)}getVector2(t){let e=this.memoryNodes.get(t);return e?new Ie(e.x,e.y):null}setVector3(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(3*4),this.memoryNodes.set(t,r)),r.setXYZ(e.x,e.y,e.z)}getVector3(t){let e=this.memoryNodes.get(t);return e?new g(e.x,e.y,e.z):null}setVector4(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(t,r)),r.setXYZW(e.x,e.y,e.z,e.w)}getVector4(t){let e=this.memoryNodes.get(t);return e?new j(e.x,e.y,e.z,e.w):null}setVector4Array(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(4*4*e.length),this.memoryNodes.set(t,r)),r.setVector4Array(e)}setColor(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(t,r)),r.setXYZW(e.r,e.g,e.b,e.a)}getColor(t){let e=this.memoryNodes.get(t);return e?new Y(e.x,e.y,e.z,e.w):null}setColorArray(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(4*4*e.length),this.memoryNodes.set(t,r)),r.setColorArray(e)}setMatrix(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(16*4),this.memoryNodes.set(t,r)),r.setFloatArray(0,e.rawData)}setMatrixArray(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(16*4*e.length),this.memoryNodes.set(t,r));for(let a=0;a<e.length;a++){const i=e[a];r.setFloatArray(a*16,i.rawData)}}setArray(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(e.length*4),this.memoryNodes.set(t,r)),r.setArray(0,e)}setFloat32Array(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(e.length*4),this.memoryNodes.set(t,r)),r.setFloat32Array(0,e)}setInt32Array(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(e.length*4),this.memoryNodes.set(t,r)),r.setInt32Array(0,e)}setUint32Array(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(e.length*4),this.memoryNodes.set(t,r)),r.setUint32Array(0,e)}setStruct(t,e,r,a){let i=xa.Ref(t);xa.GetSize(t);let o=e,l=this.memoryNodes.get(o);l.reset();let h=r;a&&(h=h[a]);for(let c=0;c<i.length;c++){const u=i[c];let d=h[u.name];this.writeValue(l,u,d)}}writeValue(t,e,r){switch(e.type){case"Boolean":t.writeFloat(r);break;case"Number":t.writeFloat(r);break;case"Float32Array":t.writeFloat32Array(r);break;case"Float64Array":t.writeFloat32Array(new Float32Array(r));break;case"Vector2":t.writeVector2(r);break;case"Vector3":t.writeVector3(r);break;case"Vector4":t.writeVector4(r);break;case"Color":t.writeRGBColor(r);break;case"Array":t.writeArray(r);break}}setStructArray(t,e,r){let a=e.length;for(let i=0;i<a;i++){const o=e[i];this.setStruct(t,i,o,r)}}clean(){this._dataView.fill(0,0,this._dataView.length)}apply(){R.device.queue.writeBuffer(this.buffer,0,this.memory.shareDataBuffer)}mapAsyncWrite(t,e){let r;t instanceof Float64Array?r=new Float32Array(t):r=t;let a=R.device;if(r.length>0){let i=null;for(;this.mapAsyncReady.length&&(i=this.mapAsyncReady.shift(),i.usedSize!=r.byteLength);)i.destroy(),this.mapAsyncBuffersOutstanding--,i=null;i||(i=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),i.usedSize=r.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>20&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let o=new Float32Array(r.buffer,r.byteOffset,e);new Float32Array(i.getMappedRange(0,e*4)).set(o),i.unmap();const l=a.createCommandEncoder();l.copyBufferToBuffer(i,0,this.buffer,0,e*4),a.queue.submit([l.finish()]),i.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(i))}}destroy(){this.memoryNodes&&this.memoryNodes.forEach(t=>{t.destroy()}),this.bufferType=null,this.seek=null,this.byteSize=null,this.usage=null,this.visibility=null,this.outFloat32Array=null,this.buffer&&this.buffer.destroy(),this.buffer=null,this.memory&&this.memory.destroy(),this.memory=null,this._readBuffer&&this._readBuffer.destroy()}createBuffer(t,e,r,a){let i=R.device;this.buffer&&this.destroy(),this.byteSize=e*4,this.usage=t,this.buffer=i.createBuffer({label:a,size:this.byteSize,usage:t,mappedAtCreation:!1}),this.memory=new Ma,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer),this.memory.allocation(this.byteSize),r&&(this.memory.allocation_node(r.length*4).setArrayBuffer(0,r),this.apply())}resizeBuffer(t,e){this.createBuffer(this.usage,t,e)}createNewBuffer(t,e){let r=R.device,a=e*4,i=t;return this.buffer&&this.destroy(),r.createBuffer({size:a,usage:i,mappedAtCreation:!1})}createBufferByStruct(t,e,r){let a=xa.GetSize(e),i=a*r,o=R.device;this.buffer=o.createBuffer({label:"StructStorageGPUBuffer",size:i,usage:t,mappedAtCreation:!1}),this.memory=new Ma,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer),this.memory.allocation(i);for(let l=0;l<r;l++){let h=l,c=this.memoryNodes.get(h);c||(c=this.memory.allocation_node(a),this.memoryNodes.set(h,c))}}readBuffer(t=!1){this.outFloat32Array||(this.outFloat32Array=new Float32Array(this.memory.shareDataBuffer.byteLength/4)),this._readBuffer||(this._readBuffer=R.device.createBuffer({size:this.memory.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}));let e=this.read();return t?e:this.outFloat32Array}async read(){if(!this._readFlag){this._readFlag=!0;let t=R.device.createCommandEncoder();t.copyBufferToBuffer(this.buffer,0,this._readBuffer,0,this.memory.shareDataBuffer.byteLength),R.device.queue.submit([t.finish()]),await this._readBuffer.mapAsync(GPUMapMode.READ);const e=this._readBuffer.getMappedRange();this.outFloat32Array.set(new Float32Array(e),0),this._readBuffer.unmap(),this._readFlag=!1}return this.outFloat32Array}}var ir=(n=>(n[n.IndicesGPUBuffer=0]="IndicesGPUBuffer",n[n.VertexGPUBuffer=1]="VertexGPUBuffer",n[n.UniformGPUBuffer=2]="UniformGPUBuffer",n[n.StorageGPUBuffer=3]="StorageGPUBuffer",n[n.ComputeGPUBuffer=4]="ComputeGPUBuffer",n[n.MaterialDataUniformGPUBuffer=5]="MaterialDataUniformGPUBuffer",n[n.StructStorageGPUBuffer=6]="StructStorageGPUBuffer",n))(ir||{});class Xe extends kr{constructor(t,e=0,r){super(),this.bufferType=ir.StorageGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|e,t,r,"StorageGPUBuffer")}}class aa extends kr{constructor(t,e){super(),this.bufferType=ir.UniformGPUBuffer,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,t,e,"UniformGPUBuffer")}genUniformNodes(){}}class ct{static getMorphTargetShaderBinding(t,e){return`
            fn blendMorphTargetPosition(vertexID:i32, posIn:vec3<f32>) -> vec3<f32>{
                let offset:i32 = vertexID * 3;
                var pos = posIn * morphTargetConfig.morphBaseInfluence;
                pos += vec3<f32>(morphTargetOpPositions[offset], morphTargetOpPositions[offset + 1], morphTargetOpPositions[offset + 2]);
                return pos;
            }

            #if USE_MORPHNORMALS
                fn blendMorphTargetNormal(vertexID:i32, normalIn:vec3<f32>) -> vec3<f32>{
                    let offset:i32 = vertexID * 3;
                    var normal = normalIn * morphTargetConfig.morphBaseInfluence;
                    normal += vec3<f32>(morphTargetOpNormals[offset], morphTargetOpNormals[offset + 1], morphTargetOpNormals[offset + 2]);
                    return normal;
                }
            #endif

            struct MorphTargetConfigData {
                morphBaseInfluence:f32,
                morphTargetCount:f32,
                totalVertexCount:f32,
                computeWorkGroupXY:f32,
            };
            
            @group(${t}) @binding(${e})
            var<uniform> morphTargetConfig: MorphTargetConfigData;
            
            @group(${t}) @binding(${e+1})
            var<storage,read> morphTargetOpPositions: array<f32>;

            #if USE_MORPHNORMALS
                @group(${t}) @binding(${e+2})
                var<storage,read> morphTargetOpNormals: array<f32>;
            #endif
`}static getMorphTargetCalcVertex(){return`
            vertexPosition = blendMorphTargetPosition(i32(vertex.vIndex), vertexPosition);

            #if USE_MORPHNORMALS
                vertexNormal = blendMorphTargetNormal(i32(vertex.vIndex), vertexNormal);
            #endif
        `}}s(ct,"CsMain",`
        struct MorphTargetConfigData {
            morphBaseInfluence:f32,
            morphTargetCount:f32,
            totalVertexCount:f32,
            computeWorkGroupXY:f32,
        };

        @group(0) @binding(0) var<uniform> morphTargetConfig: MorphTargetConfigData;
        @group(0) @binding(1) var<storage, read> morphTargetInfluence : array<f32>;
        @group(0) @binding(2) var<storage, read> morphTargetPositions : array<f32>;
        @group(0) @binding(3) var<storage, read_write> morphTargetOpPositions : array<f32>;
        
        #if USE_MORPHNORMALS
            @group(0) @binding(4) var<storage, read> morphTargetNormals : array<f32>;
            @group(0) @binding(5) var<storage, read_write> morphTargetOpNormals : array<f32>;
        #endif
        
        @compute @workgroup_size( 8 , 8 , 1 )
        fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
        {
            let vertexIndex:i32 = i32(globalInvocation_id.y) * i32(morphTargetConfig.computeWorkGroupXY) + i32(globalInvocation_id.x);
        
            let morphTargetCount:i32 = i32(morphTargetConfig.morphTargetCount);
            let totalVertexCount:i32 = i32(morphTargetConfig.totalVertexCount);
            var vertexPosition:vec3<f32> = vec3<f32>(0.0);
            var vertexNormal:vec3<f32> = vec3<f32>(0.0);
            if(vertexIndex < totalVertexCount)
            {
                for(var i:i32 = 0; i < morphTargetCount; i ++){
                    let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                    let morphPosition = vec3<f32>(morphTargetPositions[offset], morphTargetPositions[offset + 1], morphTargetPositions[offset + 2]);
                    vertexPosition += morphTargetInfluence[i] * morphPosition;
                }

                var writeOffset = vertexIndex * 3;
                //op position
                morphTargetOpPositions[writeOffset] = vertexPosition.x;
                morphTargetOpPositions[writeOffset + 1] = vertexPosition.y;
                morphTargetOpPositions[writeOffset + 2] = vertexPosition.z;

                #if USE_MORPHNORMALS
                    for(var i:i32 = 0; i < morphTargetCount; i ++){
                        let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                        let morphNormal = vec3<f32>(morphTargetNormals[offset], morphTargetNormals[offset + 1], morphTargetNormals[offset + 2]);
                        vertexNormal += morphTargetInfluence[i] * morphNormal;
                    }

                    //op normal
                    morphTargetOpNormals[writeOffset] = vertexNormal.x;
                    morphTargetOpNormals[writeOffset + 1] = vertexNormal.y;
                    morphTargetOpNormals[writeOffset + 2] = vertexNormal.z;
                #endif
            }
        }
`);let Ft=function(n=16,t=16){var e="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),r=[],a;if(t=t||e.length,n)for(a=0;a<n;a++)r[a]=e[0|Math.random()*t];else{var i;for(r[8]=r[13]=r[18]=r[23]="-",r[14]="4",a=0;a<36;a++)r[a]||(i=0|Math.random()*16,r[a]=e[a==19?i&3|8:i])}return r.join("")},ms=1e6,qs=function(){return ms++,ms},$s=(...n)=>function(...t){n.forEach(e=>e.apply(this,t))};var je=(n=>(n[n.Number=0]="Number",n[n.Vector2=1]="Vector2",n[n.Vector3=2]="Vector3",n[n.Vector4=3]="Vector4",n[n.Color=4]="Color",n[n.Float32Array=5]="Float32Array",n))(je||{});class vr{constructor(t){s(this,"size");s(this,"memoryInfo");s(this,"bindOnChange");s(this,"_data");s(this,"_type",je.Number);s(this,"_x",0);s(this,"_y",0);s(this,"_z",0);s(this,"_w",0);this.data=t}get data(){return this._data}set data(t){this._data=t,this._type=je.Number,t instanceof Ie?(this.size=2,this._x=t.x,this._y=t.y,this._type=je.Vector2):t instanceof g?(this.size=3,this._x=t.x,this._y=t.y,this._z=t.z,this._type=je.Vector3):t instanceof j?(this.size=4,this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._type=je.Vector4):t instanceof Y?(this.size=4,this._x=t.r,this._y=t.g,this._z=t.b,this._w=t.a,this._type=je.Color):t instanceof Float32Array?(this.size=t.length,this._type=je.Float32Array):(this.size=1,this._x=t,this._data=t,this._type=je.Number)}getColor(t){return t?t.copyFrom(this._data):t=this._data,t}get color(){return new Y(this._data.r,this._data.g,this._data.b,this._data.a)}set color(t){(this._x!=t.r||this._y!=t.g||this._z!=t.b||this._w!=t.a)&&(this._data.r=t.r,this._data.g=t.g,this._data.b=t.b,this._data.a=t.a,this._x=t.r,this._y=t.g,this._z=t.b,this._w=t.a,this.onChange())}get value(){return this._x}set value(t){this._x!=t&&(this._data=t,this._x=t,this.onChange())}get vector2(){return this._data}set vector2(t){(this._x!=t.x||this._y!=t.y)&&(this._data.x=t.x,this._data.y=t.y,this._x=t.x,this._y=t.y,this.onChange())}get vector3(){return this._data}set vector3(t){(this._x!=t.x||this._y!=t.y||this._z!=t.z)&&(this._data.x=t.x,this._data.y=t.y,this._data.z=t.z,this._x=t.x,this._y=t.y,this._z=t.z,this.onChange())}get vector4(){return this._data}set vector4(t){(this._x!=t.x||this._y!=t.y||this._z!=t.z||this._w!=t.w)&&(this._data.x=t.x,this._data.y=t.y,this._data.z=t.z,this._data.w=t.w,this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this.onChange())}onChange(){this.bindOnChange&&this.bindOnChange()}float32Array(t){this._data.set(t),this.onChange()}update(){switch(this._type){case je.Number:this.memoryInfo.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this._data,!0);break;case je.Vector2:this.memoryInfo.setVector2(0,this._data);break;case je.Vector3:this.memoryInfo.setVector3(0,this._data);break;case je.Vector4:this.memoryInfo.setVector4(0,this._data);break;case je.Color:this.memoryInfo.setColor(0,this._data);break;case je.Float32Array:this.memoryInfo.setFloat32Array(0,this._data);break}}}class en{constructor(){s(this,"instanceID");s(this,"shaderVariant");s(this,"vsEntryPoint","main");s(this,"fsEntryPoint","main");s(this,"bindGroups");s(this,"shaderReflection");s(this,"defineValue");s(this,"constValues");s(this,"uniforms");s(this,"materialDataUniformBuffer");s(this,"_bufferDic");s(this,"_shaderChange",!0);s(this,"_valueChange",!1);this.instanceID=Ft(),this.defineValue={},this.constValues={},this.uniforms={},this._bufferDic=new Map}noticeShaderChange(){this._shaderChange=!0}noticeValueChange(){this._valueChange=!0}setStorageBuffer(t,e){this._bufferDic.has(t)?this._bufferDic.set(t,e):(this._bufferDic.set(t,e),this.noticeBufferChange(t))}setStructStorageBuffer(t,e){this._bufferDic.has(t)?(this._bufferDic.set(t,e),this.noticeBufferChange(t)):this._bufferDic.set(t,e)}setUniformBuffer(t,e){this._bufferDic.has(t)?(this._bufferDic.set(t,e),this.noticeBufferChange(t)):this._bufferDic.set(t,e)}setDefine(t,e){(this.defineValue[t]==null||this.defineValue[t]!=e)&&(this.defineValue[t]=e,this.noticeValueChange(),this.noticeShaderChange()),this.defineValue[t]=e}hasDefine(t){return this.defineValue[t]!=null}deleteDefine(t){delete this.defineValue[t],this.noticeShaderChange()}setUniformFloat(t,e){this.uniforms[t]?this.uniforms[t].value=e:(this.uniforms[t]=new vr(e),this.noticeValueChange())}setUniformVector2(t,e){this.uniforms[t]?this.uniforms[t].vector2=e:(this.uniforms[t]=new vr(e),this.noticeValueChange())}setUniformVector3(t,e){this.uniforms[t]?this.uniforms[t].vector3=e:this.uniforms[t]=new vr(e)}setUniformVector4(t,e){this.uniforms[t]?this.uniforms[t].vector4=e:this.uniforms[t]=new vr(e)}setUniformColor(t,e){this.uniforms[t]?this.uniforms[t].color=e:this.uniforms[t]=new vr(e)}setUniformArray(t,e){this.uniforms[t]?this.uniforms[t].float32Array(e):this.uniforms[t]=new vr(e)}setUniform(t,e){this.uniforms[t]?this.uniforms[t].data=e:this.uniforms[t]=new vr(e)}getUniform(t){return this.uniforms[t].data}getUniformFloat(t){return this.uniforms[t].data}getUniformVector2(t){return this.uniforms[t].data}getUniformVector3(t){return this.uniforms[t].data}getUniformVector4(t){return this.uniforms[t].data}getUniformColor(t){return this.uniforms[t].color}getBuffer(t){return this._bufferDic[t].data}noticeBufferChange(t){}applyUniform(){this.materialDataUniformBuffer&&this._valueChange&&this.materialDataUniformBuffer.apply()}destroy(t){}}var _r=(n=>(n[n.u32=1]="u32",n[n.f32=1]="f32",n[n["vec2<f32>"]=2]="vec2<f32>",n[n["vec3<f32>"]=3]="vec3<f32>",n[n["vec4<f32>"]=4]="vec4<f32>",n[n.float32=1]="float32",n[n.float32x2=2]="float32x2",n[n.float32x3=3]="float32x3",n[n.float32x4=4]="float32x4",n))(_r||{});let Bt={clamp_to_edge:"clamp-to-edge",repeat:"repeat",mirror_repeat:"mirror-repeat"},tr={less:"less",less_equal:"less-equal",always:"always"},nt={none:"none",front:"front",back:"back"},Tr={linear:"linear"},vo={triangle_list:"triangle-list"},H={rgba8unorm:"rgba8unorm",rgba8uint:"rgba8uint",bgra8unorm:"bgra8unorm",rgba16float:"rgba16float",rgba32float:"rgba32float",depth24plus:"depth24plus",depth32float:"depth32float"},Ra={float32:"float32",float32x2:"float32x2",float32x3:"float32x3",float32x4:"float32x4"},So=[null,Ra.float32,Ra.float32x2,Ra.float32x3,Ra.float32x4],Ro=`
        var<private> colorSet : array<vec3<f32>, 9> = array<vec3<f32>, 9>(
            vec3<f32>(1.0, 0.0, 0.0),
            vec3<f32>(1.0, 0.5, 0.0),
            vec3<f32>(0.5, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.5),
            vec3<f32>(0.0, 0.5, 1.0),
            vec3<f32>(0.0, 0.0, 1.0),
            vec3<f32>(0.5, 0.0, 1.0),
            vec3<f32>(1.0, 0.0, 0.5)
        );

        #if DEBUG_CLUSTER
        fn debugCluster(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              var tileID : u32 = getClusterId3().z;
              let clusterDebug = vec4<f32>(colorSet[tileID % 9u], 1.0);
              // ORI_FragmentOutput.color = clusterDebug ;
            #endif
          }
      
          fn debugClusterBox(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              let clusterId3 : vec3<u32> = getClusterId3();
              let px = f32(clusterId3.x) / clustersUniform.clusterTileX ;
              let py = f32(clusterId3.y) / clustersUniform.clusterTileY ;
              let pz = f32(clusterId3.z) / clustersUniform.clusterTileZ ;
              // ORI_FragmentOutput.color = vec4<f32>(px,py,pz, 1.0);

              var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
              // ORI_FragmentOutput.color = vec4<f32>(screenUV.x,screenUV.y,0.0, 1.0);

              // let clusterId : u32 = getClusterIndex();
              // let cluster = clusterBuffer[clusterId];
        
              // let midPoint : vec3<f32> = (cluster.maxPoint.xyz - cluster.minPoint.xyz) * vec3<f32>(0.5);
              // let center : vec3<f32> = cluster.minPoint.xyz + midPoint;
              // let radius : f32 = length(midPoint) ;
        
              // let fragToBoundsCenter : vec3<f32> = ORI_VertexVarying.viewPosition.xyz - center;
              // let distToBoundsCenter : f32 = length(fragToBoundsCenter);
              // let normDist : f32 = distToBoundsCenter / radius;
              // ORI_FragmentOutput.color = vec4<f32>(normDist,normDist,normDist, 1.0);
            #endif
          }
      
          fn debugClusterLightCount(fragCoord:vec4<f32>){
            #if USE_LIGHT
            //LightIndex
              let cluster : LightIndex = getCluster();
              let lightCount : u32 = u32(cluster.count);
              let lightFactor : f32 = f32(lightCount) / f32(clustersUniform.maxNumLightsPerCluster);
              // ORI_FragmentOutput.color =  mix(vec4<f32>(0.0, 0.0,0.0, 1.0), vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(lightFactor, lightFactor, lightFactor, lightFactor));
            #endif
          }
          #endif
    `;class ka{}s(ka,"sky_vs_frag_wgsl",`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
      @location(auto) fragUV: vec2<f32>,
      @location(auto) vClipPos: vec4<f32>,
      @location(auto) vWorldPos: vec4<f32>,
      @location(auto) vWorldNormal: vec3<f32>,
      @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    @vertex
    fn main( 
      @builtin(instance_index) index : u32,
      @location(auto) position: vec3<f32>,
      @location(auto) normal: vec3<f32>,
      @location(auto) uv: vec2<f32>
    ) -> VertexOutput {
      ORI_VertexOut.fragUV = uv;
      let modelMat = models.matrix[u32(index)];
      let vm = modelMat;
      let normalMatrix = mat3x3<f32>(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	    ORI_VertexOut.vWorldNormal = normalize( normalMatrix * normal );
      ORI_VertexOut.vWorldPos = modelMat * vec4<f32>(position.xyz,1.0) ;
      
      var fixProjMat = globalUniform.projMat ;
      fixProjMat[2].z = 1.0 ;//99999.0 / (99999.0 - 1.0) ;
      fixProjMat[3].z = -1.0 ;//(-1.0 * 99999.0) / (99999.0 - 1.0) ;

      var fixViewMat = globalUniform.viewMat ;
      fixViewMat[3].x = 0.0 ;
      fixViewMat[3].y = 0.0 ;
      fixViewMat[3].z = 0.0 ;

      var clipPos = fixProjMat * fixViewMat * ORI_VertexOut.vWorldPos;
      clipPos.z = clipPos.w;
      ORI_VertexOut.vClipPos = clipPos ;
      ORI_VertexOut.member = clipPos;
      return ORI_VertexOut;
    }
  `),s(ka,"sky_fs_frag_wgsl",`
    #include "GlobalUniform"
    #include "MathShader"
    #include "BitUtil"
    #include "ColorUtil_frag"
    #include "FragmentOutput"

    struct uniformData {
        exposure: f32,
        roughness: f32
    };

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_cube<f32>;

    @group(2) @binding(0)
    var<uniform> global: uniformData;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>,@location(auto) vClipPos: vec4<f32>, @location(auto) vWorldPos: vec4<f32>, @location(auto) vWorldNormal: vec3<f32> , @builtin(position) fragCoord : vec4<f32> ) -> FragmentOutput {
        let maxLevel: u32 = textureNumLevels(baseMap);
        let dir = normalize(vWorldPos.xyz);
        var textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(dir.xyz), global.roughness * f32(maxLevel) ).xyz;
        #if IS_HDR_SKY
          textureColor = LinearToGammaSpace(textureColor);
        #endif

        // let o_Target: vec4<f32> = globalUniform.hdrExposure * vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure ;
        let o_Target: vec4<f32> = vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure;
        let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
        let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
        let ORI_NORMALMATRIX = transpose(inverse( nMat ));
       
        var vNormal = (ORI_NORMALMATRIX * -vWorldNormal );
        var gBuffer = packGBuffer(
          -globalUniform.far,
          vec3f(0.0),
          o_Target.rgb,
          vec3f(0.0),
          vNormal
        ) ;
      var fragmentOutput:FragmentOutput;
      #if USE_CASTREFLECTION
        fragmentOutput.gBuffer = gBuffer ;
      #else
        fragmentOutput.color = o_Target ;
        fragmentOutput.gBuffer = gBuffer ;
      #endif
      return fragmentOutput;
    }

    fn packGBuffer(depth:f32, albedo:vec3f,hdrLighting:vec3f,rmao:vec3f,normal:vec3f) -> vec4f{
        var gBuffer : vec4f ;
        var octUVNormal = (octEncode(normalize(normal)) + 1.0) * 0.5 ;

        var yc = f32(r11g11b9_to_float(vec3f(octUVNormal,0.0))) ;
        #if USE_CASTREFLECTION
          var rgbm = EncodeRGBM(hdrLighting);
          var zc = f32(pack4x8unorm(vec4f(rgbm.rgb,0.0))) ;
          var wc = f32(pack4x8unorm(vec4f(rmao.rg,rgbm.a,0.0)));
        #else
          var zc = f32(vec4fToFloat_7bits(vec4f(albedo.rgb,0.0)));
          var wc = f32(r22g8_to_float(vec2f(f32(0.0),rmao.g)));
        #endif
    
        gBuffer.x = depth  ;
        gBuffer.y = yc ;
        gBuffer.z = zc ;
        gBuffer.w = wc ;
        return gBuffer ;
    }
    `);let Eo=`
#include "BRDF_frag"
#include "ClusterLight"
#include "ShadowMapping_frag"

#if USE_IES_PROFILE
  #include "IESProfiles_frag"
#endif



const PI2 = 3.1415926 * 3.1415926 ;

fn sampleLighting(light:LightData,direction:vec3f,iblSpecularResult:vec3f , intensity :f32 , shadow:f32 ) -> vec3f{
  var ret = vec3f(0.0);
  var normalDir  = fragData.N;
  var viewDir    = fragData.V;

  var lightDir   = normalize(-direction.xyz);
  var halfDir    = normalize(lightDir + viewDir);
  var reflectDir = normalize(reflect(-viewDir,normalDir));

  var NdotH = max(0.00001,dot(normalDir,halfDir));
  var NdotL = max(0.00001,dot(normalDir,lightDir));
  var NdotV = max(0.00001,dot(normalDir,viewDir));
  var HdotL = max(0.00001,dot(halfDir,lightDir));

  var baseColor = fragData.Albedo.rgb ; 
  var metallic = fragData.Metallic ;
  var roughness = fragData.Roughness ;

  var lightColor = getHDRColor( light.lightColor.rgb , light.linear )  ;
  var att = max(0.0,intensity);
  
  var lighting:vec3f = lightContribution(NdotH,NdotL,NdotV,HdotL,fragData.Roughness,fragData.Albedo.rgb / 3.14, metallic ,shadow,fragData.F0,lightColor.rgb);
  // lighting = fragData.F0 / 3.1415926 * NdotL ;
  lighting = ACESToneMapping(lighting,att);
  // ret += lighting ;
  return lighting ;
}

fn directLighting( light:LightData , iblSpecularResult : vec3f) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    #if USE_LIGHT
      var L = normalize(light.direction.xyz) ;
      #if USE_BRDF
        var shadow = directShadowVisibility[(light.castShadow)] ;
        var att = light.intensity;
        color = sampleLighting(light,L,iblSpecularResult,att, shadow);
      #endif 
    #endif 
    return color;
}

fn directDulLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.85 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 * roughness,metallic) ;
      color += 0.15 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 * roughness,metallic) ;
    #endif 
  #endif 
  return color;
}

fn directHairLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 ,metallic) ;
      color += 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 ,metallic) ;
    #endif 
  #endif 
  return color;
}


fn pointLighting( WP:vec3<f32>, light:LightData , iblSpecularResult : vec3f ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir);
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    if( abs(dist) < light.range ){
        var L = dir ;
        var atten = 1.0 ;
        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001)  ;

        // if( light.castShadow >= 0 )
        // {
        //     #if USE_SHADOWMAPING
        //       for (var j: i32 = 0; j < 8; j += 1) {
        //           if(j == light.castShadow){
        //             atten *= pointShadows[j] ; 
        //           }
        //       }
        //     #endif
        // }

        var shadow = pointShadows[i32(light.castShadow)] ;

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        atten *= sphere_unit(light.range,light.intensity) ;

        color = sampleLighting(light,-L,iblSpecularResult,atten,shadow);
    } 
    return color ;
}

fn pointAtt( WP:vec3<f32>, light:LightData ) -> f32 {
  var atten = 0.0 ;
  let lightPos = light.position.xyz;
  var dir = lightPos.xyz - WP ;
  let dist = length(dir);
  if(dist != 0.0){
    dir *= 1.0 / dist ;
  }
  if( abs(dist) < light.range ){
      var L = dir ;
      atten = 1.0 - smoothstep(0.0,light.range,dist) ;
      atten *= 1.0 / max(light.radius,0.001)  ;
      var shadow = pointShadows[i32(light.castShadow)] ;
      #if USE_IES_PROFILE
          atten *= getLightIESProfileAtt(WP,light);
      #endif
      atten *= sphere_unit(light.range,light.intensity) ;
  } 
  return atten ;
}

fn getDistanceAtten(  light:LightData , dist : f32 ) -> f32 {
  return 1.0 - smoothstep(0.0,light.range,dist) ;
}

fn spotLighting( WP:vec3<f32>, light:LightData , iblSpecularResult : vec3f) -> vec3<f32> {
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir) ;
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }

    var color = vec3<f32>(0.0) ;
    if( abs(dist) < light.range * 2.0 ){
        var L = dir ;
        let theta = dot(-L, normalize(light.direction));
        let angle = acos(theta) ;
        var atten = 1.0 ;
        var lightColor = light.lightColor.rgb  ;

        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001) ;
        if(angle < light.outerCutOff){
          if(angle > light.innerCutOff){
            atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
          }
        }else{
            atten = 0.0 ;
        }

        var shadow = pointShadows[i32(light.castShadow)] ;

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        atten *= sphere_unit(light.range, light.intensity) ;

        color = sampleLighting(light,-L,iblSpecularResult,atten,shadow);
    }
    return  color ;
}

fn sphere_unit( radius:f32 , intensity:f32 ) -> f32 {
  return intensity / (4.0 * PI2 * radius * radius) ;
}
`,yo=`
  #include 'BitUtil'
  // fn getViewPosition(z:f32,uv:vec2f) -> vec3f {
  //   let pvMatrix = globalUniform.projMat * globalUniform.viewMat ;
  //   let worldPos = getWorldPosition(z,uv) ;
  //   var viewPos = pvMatrix * worldPos ;
  //   return viewPos.xyz;
  // }

  

  struct TBN_ret{
    tan:vec3f,
    bit:vec3f,
  }
  
  fn TBN( N:vec3f) -> mat3x3<f32>{
    //Returns the simple tangent space matrix
    var Nb : vec3f;
    var Nt : vec3f;
    if (abs(N.y)>0.999) {
        Nb = vec3f(1.0,0.0,0.0);
        Nt = vec3f(0.0,0.0,1.0);
    } else {
      Nb = normalize(cross(N,vec3f(0.0,1.0,0.0)));
      Nt = normalize(cross(Nb,N));
    }

    var mat3 = mat3x3<f32>(
      Nb.x,Nt.x,N.x,
      Nb.y,Nt.y,N.y,
      Nb.z,Nt.z,N.z
    );

    return mat3;
  }

  fn TBN_out( N : vec3f ) -> TBN_ret {
      var tbn_ret : TBN_ret;
      //Returns the simple tangent space directions
      if (abs(N.y)>0.999) {
          tbn_ret.tan = vec3f(1.0,0.0,0.0);
          tbn_ret.bit = vec3f(0.0,0.0,1.0);
      } else {
          tbn_ret.tan = normalize(cross(N,vec3f(0.0,1.0,0.0)));
          tbn_ret.bit = normalize(cross(tbn_ret.tan,N));
      }

      return tbn_ret;
  }


  fn ARand21( uv: vec2f) -> f32 {
      //Returns 1D noise from 2D
      return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2f(13.18273,51.2134)))*173.137);
  }

fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
  let x:f32 = position.x;
  let y:f32 = position.y;
  let z:f32 = position.z;

  let qx:f32 = q.x;
  let qy:f32 = q.y;
  let qz:f32 = q.z;
  let qw:f32 = q.w;

  let ix:f32 = qw * x + qy * z - qz * y;
  let iy:f32 = qw * y + qz * x - qx * z;
  let iz:f32 = qw * z + qx * y - qy * x;
  let iw:f32 = -qx * x - qy * y - qz * z;

  var ret: vec3<f32>;
  ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

  return ret;
}

fn inverse( m:mat3x3<f32>) -> mat3x3<f32>{
  var a00 = m[0][0];
  var a01 = m[0][1];
  var a02 = m[0][2];
  var a10 = m[1][0];
  var a11 = m[1][1];
  var a12 = m[1][2];
  var a20 = m[2][0];
  var a21 = m[2][1];
  var a22 = m[2][2];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  var det = a00 * b01 + a01 * b11 + a02 * b21 ;
  return mat3x3<f32>(
      vec3<f32>(b01/ det, (-a22 * a01 + a02 * a21)/ det, (a12 * a01 - a02 * a11)/ det),
      vec3<f32>(b11/ det, (a22 * a00 - a02 * a20)/ det, (-a12 * a00 + a02 * a10)/ det),
      vec3<f32>(b21/ det, (-a21 * a00 + a01 * a20)/ det, (a11 * a00 - a01 * a10)/ det)
  );
}

fn dir_to_faceId(pt:vec3<f32>) -> i32 {
    //**** nx px ny py nz pz
    var abs_x = abs(pt.x);
    var abs_y = abs(pt.y);
    var abs_z = abs(pt.z);
    var coord = max(max(abs_x, abs_y), abs_z);
    if(coord == -pt.x){  return 0;}
    if(coord == pt.x) { return 1;}

    if(coord == -pt.y){  return 2;}
    if(coord == pt.y) { return 3;}

    if(coord == -pt.z) { return 4;}
    return 5;
  }

  const us = 1.0 /6.0 ;
  fn uv_2_xyz(u:f32,v:f32) -> vec3f 
  {
    let face = floor(u / us);
    var uu = (u - face * us) / us ;

    var uc = 2.0 * uu - 1.0;
    var vc = 2.0 * v - 1.0;
    var xyz = vec3f(0,0,0);

    if(face == 0.0){
    // x,y,z = 1.0,vc,-uc
      xyz = vec3f(1.0,-vc,uc);
    }else if(face == 1.0){
    // x,y,z = -1.0,vc,uc
      xyz = vec3f(-1.0,-vc,-uc);
    }else if(face == 2.0){
    // x,y,z = uc,1.0,-vc
      xyz = vec3f(uc,1.0,-vc);
    }else if(face == 3.0){
    // x,y,z = uc,-1.0,vc
      xyz = vec3f(uc,-1.0,vc);
    }else if(face == 4.0){
    // x,y,z = uc,vc,1.0
      xyz = vec3f(-uc,-vc,1.0);
    }else if(face == 5.0){
    // x,y,z = -uc,vc,-1.0
      xyz = vec3f(uc,-vc,-1.0);
    }
    return xyz ;
  }

  fn convert_xyz_to_cube_uv(x:f32, y:f32, z:f32 ) -> vec2f
  {
    var dir = vec3f(x, y, z);
    var absX = abs(dir.x);
    var absY = abs(dir.y);
    var absZ = abs(dir.z);

    var isXPositive = 0;
    if(dir.x > 0.0){isXPositive = 1;}
    var isYPositive = 0;
    if(dir.y > 0.0){isYPositive = 1;}
    var isZPositive = 0;
    if(dir.z > 0.0){isZPositive = 1;}

    var maxAxis:f32 = 0.0;
    var uc:f32 = 0.0;
    var vc:f32 = 0.0;

    // POSITIVE X
    if (isXPositive == 1 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from +z to -z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = -z;
      vc = y;
    }
    // NEGATIVE X
    if (isXPositive ==0 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from -z to +z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = z;
      vc = y;
    }
    // POSITIVE Y
    if (isYPositive==1 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from +z to -z
      maxAxis = absY;
      uc = x;
      vc = -z;
    }
    // NEGATIVE Y
    if (isYPositive ==0 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -z to +z
      maxAxis = absY;
      uc = x;
      vc = z;
    }
    // POSITIVE Z
    if (isZPositive == 1&& absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = x;
      vc = y;
    }
    // NEGATIVE Z
    if (isZPositive ==0 && absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from +x to -x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = -x;
      vc = y;
    }

    // Convert range from -1 to 1 to 0 to 1
    var u = 0.5f * (uc / maxAxis + 1.0f);
    var v = 0.5f * (vc / maxAxis + 1.0f);

    return vec2f(u, v);
  }

    // Returns 1
    fn signNotZero( v1:vec2<f32>) -> vec2<f32> {
        var v:vec2<f32> = v1;
        if(v.x >= 0.0){
            v.x = 1.0;
        }else{
            v.x = -1.0;
        }
        if(v.y >= 0.0){
            v.y = 1.0;
        }else{
            v.y= -1.0;
        }
        return v;
    }

    fn octEncode( v:vec3<f32> ) -> vec2<f32> {
        var l1norm = abs(v.x) + abs(v.y) + abs(v.z);
        var result = v.xy * (1.0 / l1norm);
        if (v.z < 0.0) {
            result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
        }
        return result;
    }

    // Returns a unit vector. Argument o is an octahedral vector packed via octEncode,on the [-1, +1] square*/
    fn octDecode( o:vec2<f32> ) -> vec3<f32> {
        var v = vec3<f32>(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
        if (v.z < 0.0) {
            var tmp = (1.0 - abs(v.yx)) * signNotZero(v.xy);
            v.x = tmp.x;
            v.y = tmp.y;
        }
        return normalize(v);
    }

    fn Linear01Depth(z:f32,near:f32,far:f32)-> f32{
        let ZBufferZ = (-1.0+(far/near)) / far;
        let ZBufferW = near /far ;
        return 1.0 / (ZBufferZ * z + ZBufferW) ;
    }

    
    fn LinearizeDepth( depth:f32 , nearPlane:f32 , farPlane:f32 )-> f32 {
      var z = depth * 2.0 - 1.0;
      return (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));
    }

    fn logDepth(depth : f32, far:f32) -> f32 {
      return log2(depth + 1.0) * 2.0 / (log(far + 1.0) / 0.6931471805599453) * 0.5;
    }

    fn log2Depth(depth:f32, near:f32, far:f32) -> f32 {
      let Fcoef:f32 = 2.0 / log2(far + 1.0);
      var result:f32 = (log2(max(1e-6, 1.0 + depth)) * Fcoef - 1.0);
      result = (1.0 + result) / 2.0;
      return result * depth;
    }

    fn log2DepthFixPersp(depth:f32, near:f32, far:f32) -> f32 {
      let flogz:f32 = 1.0 + depth;
      let Fcoef_half:f32 = (2.0 / log2(far + 1.0)) * 0.5;
      var result:f32 = log2(flogz) * Fcoef_half;
      result = (1.0 + result) / 2.0;
      return result;
    }


    fn QuaternionToMatrix(q: vec4<f32>) -> mat4x4<f32> {
      // If q is guaranteed to be a unit quaternion, s will always
      // be 1.  In that case, this calculation can be optimized out.
      //float norm = GetNorm (q);
      //float s = (norm > 0.0) ? 2.0/norm : 0;

      var result: mat4x4<f32>;
  
      // Precalculate coordinate products
      let x = q.x * 2.0;
      let y = q.y * 2.0;
      let z = q.z * 2.0;
      let xx = q.x * x;
      let yy = q.y * y;
      let zz = q.z * z;
      let xy = q.x * y;
      let xz = q.x * z;
      let yz = q.y * z;
      let wx = q.w * x;
      let wy = q.w * y;
      let wz = q.w * z;
  
      // Calculate 3x3 matrix from orthonormal basis
      result[0][0] = 1.0 - (yy + zz);
      result[0][1] = xy + wz;
      result[0][2] = xz - wy;
      result[0][3] = 0.0;
  
      result[1][0] = xy - wz;
      result[1][1] = 1.0 - (xx + zz);
      result[1][2] = yz + wx;
      result[1][3] = 0.0;
  
      result[2][0] = xz + wy;
      result[2][1] = yz - wx;
      result[2][2] = 1.0 - (xx + yy);
      result[2][3] = 0.0;
  
      result[3][0] = 0.0;
      result[3][1] = 0.0;
      result[3][2] = 0.0;
      result[3][3] = 1.0;

      return result;
    }

    fn MakeScaleMatrix(scale: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          scale.x, 0.0, 0.0, 0.0,
          0.0, scale.y, 0.0, 0.0,
          0.0, 0.0, scale.z, 0.0,
          0.0, 0.0, 0.0, 1.0,
        );
    }

    fn MakeRotationMatrix(rotationQuaternion: vec4<f32>) -> mat4x4<f32> {
        return QuaternionToMatrix(rotationQuaternion);
    }

    fn MakeTranslationMatrix(translation: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          translation.x, translation.y, translation.z, 1.0,
        );
    }

    fn MakeMatrix4x4(scale: vec3<f32>, rotationQuaternion: vec4<f32>, translation: vec3<f32>) -> mat4x4<f32> {
        var scaleMat: mat4x4<f32> = MakeScaleMatrix(scale);
        var rotationMat: mat4x4<f32> = MakeRotationMatrix(rotationQuaternion);
        var translationMat: mat4x4<f32> = MakeTranslationMatrix(translation);
        return translationMat * scaleMat * rotationMat;
    }

    fn mixMatrix4x4(a: mat4x4<f32>, b: mat4x4<f32>, t:f32) -> mat4x4<f32> {
      return a * (1.0 - t) + b * t;
      // return mat4x4<f32>(
      //   mix(a[0], b[0], t),
      //   mix(a[1], b[1], t),
      //   mix(a[2], b[2], t),
      //   mix(a[3], b[3], t)
      // );
    }

    fn decodeDepth( color:vec4<f32> ) -> f32{
      var depth = 0.0 ;
      const bitShifts = vec4<f32>(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); 
      depth = dot(color, bitShifts);
      return depth;
    }

    fn encodeDepth( depth:f32 ) -> vec4<f32>{
      const bitSh  = vec4<f32>(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
      const bitMsk = vec4<f32>(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
      var comp:vec4<f32>;
      comp  = depth * bitSh;
      comp  = fract(comp);
      comp -= comp.xxyz * bitMsk;
      return comp;
    }

    fn calculateBillboardMatrix2(eye:vec3f,pos:vec3f,up:vec3f) -> mat3x3<f32> {
      
      let zAxis: vec3f = -normalize(pos.xyz - eye);
      var xAxis: vec3f = cross(up,zAxis);
      xAxis = normalize(cross(zAxis,xAxis));
      let yAxis = normalize(cross(zAxis, xAxis));
      return mat3x3<f32>(xAxis, yAxis, zAxis);
    }

    struct SH9Struct{
      SHAr:vec4f,
      SHAg:vec4f,
      SHAb:vec4f,
      SHBr:vec4f,
      SHBg:vec4f,
      SHBb:vec4f,
      SHC:vec4f,
    }

    fn ShadeSH9 ( normal:vec4f , sh9:SH9Struct) -> vec3f
    {
      var x1:vec3f = vec3f(0.0);
      var x2:vec3f = vec3f(0.0);
      var x3:vec3f = vec3f(0.0);
      
      // Linear + constant polynomial terms
      x1.r = dot(sh9.SHAr,normal);
      x1.g = dot(sh9.SHAg,normal);
      x1.b = dot(sh9.SHAb,normal);
      
      // 4 of the quadratic polynomials
      var vB = normal.xyzz * normal.yzzx;
      x2.r = dot(sh9.SHBr,vB);
      x2.g = dot(sh9.SHBg,vB);
      x2.b = dot(sh9.SHBb,vB);
      
      // Final quadratic polynomial
      var vC = normal.x*normal.x - normal.y*normal.y;
      x3 = sh9.SHC.rgb * vC;
      return x1 + x2 + x3;
    } 

    fn clipViewUV(viewRectangle:vec4f,size:vec2f,fragCoord:vec2f) -> vec2u {
        let subViewUV = (fragCoord - viewRectangle.xy) / viewRectangle.zw ;
        return vec2u(subViewUV*size) ;
    }

    fn insideRectangle( point:vec2f , rec:vec4f) -> bool {
      if( point.x > rec.x &&  point.y > rec.y &&  point.x < (rec.x + rec.z ) &&  point.y < (rec.y + rec.w ) ){
         return true ;
      }
      return false;
    }

    fn convert_cube_uv_to_xyz( index:i32,  u:f32,  v:f32) -> vec3f
    {
      var ret : vec3f ;
      // convert range 0 to 1 to -1 to 1
      var uc = 2.0f * u - 1.0f;
      var vc = 2.0f * v - 1.0f;
      switch (index)
      {
        case 0: {
          ret.x =  1.0f; 
          ret.y =    vc; 
          ret.z =   -uc; 
          break;
        }	// POSITIVE X
        case 1: {
          ret.x = -1.0f; 
          ret.y =    vc; 
          ret.z =    uc; 
          break;
        }	// NEGATIVE X
        case 2: {
          ret.x =    uc; 
          ret.y =  1.0f; 
          ret.z =   -vc; 
          break;
        }	// POSITIVE Y
        case 3: {
          ret.x =    uc; 
          ret.y = -1.0f; 
          ret.z =    vc; 
          break;
        }	// NEGATIVE Y
        case 4: {
          ret.x =    uc; 
          ret.y =    vc; 
          ret.z =  1.0f; 
          break;
        }	// POSITIVE Z
        case 5: {
          ret.x =   -uc; 
          ret.y =    vc; 
          ret.z = -1.0f; 
          break;
        }	// NEGATIVE Z
        default:{
          ret = vec3f(0.0);
        }
      }
      return ret ;
    }

    fn convert_cube_uv_to_normal( index:i32, u:f32, v:f32) -> vec3f
    {
      var ret : vec3f ;
      // convert range 0 to 1 to -1 to 1
      var uc = 2.0f * u - 1.0f;
      var vc = 2.0f * v - 1.0f;
      switch (index)
      {
        case 0: {
          ret.x =  1.0f; 
          ret.y =    vc; 
          ret.z =   -uc; 
          break;
        }	// POSITIVE X
        case 1: {
          ret.x = -1.0f; 
          ret.y =    vc; 
          ret.z =    uc; 
          break;
        }	// NEGATIVE X
        case 2: {
          ret.x =    uc; 
          ret.y =  1.0f; 
          ret.z =   -vc; 
          break;
        }	// POSITIVE Y
        case 3: {
          ret.x =    uc; 
          ret.y = -1.0f; 
          ret.z =    vc; 
          break;
        }	// NEGATIVE Y
        case 4: {
          ret.x =    uc; 
          ret.y =    vc; 
          ret.z =  1.0f; 
          break;
        }	// POSITIVE Z
        case 5: {
          ret.x =   -uc; 
          ret.y =    vc; 
          ret.z = -1.0f; 
          break;
        }	// NEGATIVE Z
        default:{
          ret = vec3f(0.0);
        }
      }
      return ret ;
    }

    fn UvToDir( uv1:vec2f) -> vec3f{
      var uv = uv1 ;
      uv *= vec2f(2.0*3.1415926535897932384626433832795, 3.1415926535897932384626433832795);
      var theta = uv.y;
      var phi = uv.x + 3.1415926535897932384626433832795 * 0.5 ;
      // var phi = uv.x ;
      var dir = vec3f(0.0,0.0,0.0);
      dir.x = sin(phi) * sin(theta) * -1;
      dir.y = cos(theta) * -1;
      dir.z = cos(phi) * sin(theta);
      return dir;
    }

    fn DirTOUV( a_coords:vec3f ) ->vec2f
    {
      var coords = normalize(a_coords);
      var lon = atan2(coords.z, coords.x);
      var lat = acos(coords.y);
      var sphereCoords = vec2f(lon, lat) * (1.0 / 3.1415926535897932384626433832795);
      return vec2f(sphereCoords.x * 0.5 + 0.5 , 1.0 - sphereCoords.y);
      // return vec2f(sphereCoords.y, (sphereCoords.x * 0.5 ));
    }
    
`,Io=`
          #if USE_CUSTOMUNIFORM
          #else
              struct MaterialUniform {
                  baseColor: vec4<f32>,
                  emissiveColor: vec4<f32>,
                  materialF0: vec4<f32>,
                  specularColor: vec4<f32>,

                  envIntensity: f32,
                  normalScale: f32,
                  roughness: f32,
                  metallic: f32,

                  ao: f32,
                  roughness_min: f32,
                  roughness_max: f32,
                  metallic_min: f32,

                  metallic_max: f32,
                  emissiveIntensity: f32,
                  alphaCutoff: f32,
                  ior: f32,

                  clearcoatColor: vec4<f32>,

                  clearcoatWeight: f32,
                  clearcoatFactor: f32,
                  clearcoatRoughnessFactor: f32,
                  clearcoatIor: f32,

                  baseMapOffsetSize:vec4<f32>,
                  normalMapOffsetSize:vec4<f32>,
                  emissiveMapOffsetSize:vec4<f32>,
                  roughnessMapOffsetSize:vec4<f32>,
                  metallicMapOffsetSize:vec4<f32>,
                  aoMapOffsetSize:vec4<f32>,
              };
        #endif
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;
      `,xo=`


#if USE_CUSTOMUNIFORM
#else
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,
      baseColor: vec4<f32>,
      alphaCutoff: f32,
    };
#endif


@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,bo=`
    #include "Common_frag"
    #include "GlobalUniform"

    fn UnLit(){
        let alpha = ORI_ShadingInput.BaseColor.a ;
        var viewColor = vec4<f32>(ORI_ShadingInput.BaseColor.rgb * alpha , alpha) ;
        let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
        let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
        let ORI_NORMALMATRIX = transpose(inverse( nMat ));
        var vNormal = normalize(ORI_NORMALMATRIX * (ORI_VertexVarying.vWorldNormal ));
        let gBuffer = packNHMDGBuffer(
            ORI_VertexVarying.fragCoord.z,
            vec3f(0.0),
            viewColor.rgb,
            // vec3f(0.5),
            vec3f(1.0,0.0,0.0),
            vNormal,
            alpha
          ) ;
  
          #if USE_CASTREFLECTION
            ORI_FragmentOutput.gBuffer = gBuffer ;
          #else
            ORI_FragmentOutput.gBuffer = gBuffer ;
            ORI_FragmentOutput.color = viewColor ;
          #endif
    }

    fn debugFragmentOut(){

    }
`;class pa{static groupBindingAndFunctions(t,e){return`
            struct JointsMatrix {
                matrix : array<mat4x4<f32>>
            };

            @group(${t}) @binding(${e})
            var<storage, read> jointsMatrixIndexTable: array<f32>;

            @group(${t}) @binding(${e+1})
            var<storage, read> jointsInverseMatrix: JointsMatrix;

            @group(${t}) @binding(${e+2})
            var<storage, read> jointsIndexMapingTable: array<f32>;

            const MAX_JOINT_NUM = 8;
            fn getSkeletonWorldMatrix(joints: array<f32, MAX_JOINT_NUM>, weights: array<f32, MAX_JOINT_NUM>, num: u32) -> mat4x4<f32> {
                var result: mat4x4<f32>;
                for(var i: u32 = 0; i < num; i = i + 1) {
                    let jointId = i32(joints[i]);
                    let jointIndex = u32(jointsIndexMapingTable[jointId]);
                    let jointMatrixIndex = u32(jointsMatrixIndexTable[jointIndex]);
                    let joint = models.matrix[jointMatrixIndex] * jointsInverseMatrix.matrix[jointId] * weights[i];
                    result += joint;
                }
                return result;
            }

            fn getSkeletonWorldMatrix_4(joints: vec4<f32>, weights: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints.x, joints.y, joints.z, joints.w,
                    0, 0, 0, 0,
                ), array<f32, MAX_JOINT_NUM>(
                    weights.x, weights.y, weights.z, weights.w,
                    0, 0, 0, 0,
                ), 4);
            }
    
            fn getSkeletonWorldMatrix_8(joints0: vec4<f32>, weights0: vec4<f32>, joints1: vec4<f32>, weights1: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints0.x, joints0.y, joints0.z, joints0.w,
                    joints1.x, joints1.y, joints1.z, joints1.w,
                ), array<f32, MAX_JOINT_NUM>(
                    weights0.x, weights0.y, weights0.z, weights0.w,
                    weights1.x, weights1.y, weights1.z, weights1.w,
                ), 8);
            }
        `}}let _o=`
    var<private> PI: f32 = 3.14159265359;
    #if USE_METAHUMAN
        ${ct.getMorphTargetShaderBinding(3,0)}
        ${pa.groupBindingAndFunctions(3,2)} 
    #else
        #if USE_MORPHTARGETS
            ${ct.getMorphTargetShaderBinding(3,0)}
        #endif

        #if USE_SKELETON
            ${pa.groupBindingAndFunctions(3,0)} 
        #endif
    #endif

    struct VertexAttributes{
        @builtin(instance_index) index : u32,
        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,

        #if USE_METAHUMAN
            #if USE_TANGENT
                @location(auto) TANGENT: vec4<f32>,
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #else
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #endif
        #else
            #if USE_TANGENT
                @location(auto) TANGENT: vec4<f32>,
            #endif

            #if USE_SKELETON
                #if USE_TANGENT
                    @location(auto) joints0: vec4<f32>,
                    @location(auto) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(auto) joints1: vec4<f32>,
                        @location(auto) weights1: vec4<f32>,
                    #endif
                #else
                    @location(auto) joints0: vec4<f32>,
                    @location(auto) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(auto) joints1: vec4<f32>,
                        @location(auto) weights1: vec4<f32>,
                    #endif
                #endif
            #endif

            #if USE_MORPHTARGETS
                #if USE_TANGENT
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #endif

        #endif
    }

    struct VertexOutput {
    @location(auto) index: f32,
    @location(auto) varying_UV0: vec2<f32>,
    @location(auto) varying_UV1: vec2<f32>,
    @location(auto) varying_ViewPos: vec4<f32>,
    @location(auto) varying_Clip: vec4<f32>,
    @location(auto) varying_WPos: vec4<f32>,
    @location(auto) varying_WNormal: vec3<f32>,
    @location(auto) varying_Color: vec4<f32>,

    #if USE_SHADOWMAPING
        @location(auto) varying_ShadowPos: vec4<f32>,
    #endif

    #if USE_TANGENT
        @location(auto) varying_Tangent: vec4<f32>,
    #endif
   

    @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    fn ORI_Vert(vertex:VertexAttributes){
    var vertexPosition = vertex.position;
    var vertexNormal = vertex.normal;

    #if USE_METAHUMAN
        ${ct.getMorphTargetCalcVertex()}    
        #if USE_JOINT_VEC8
            let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
            ORI_MATRIX_M *= skeletonNormal ;
        #else
            let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
            ORI_MATRIX_M *= skeletonNormal ;
        #endif
    #else 
        #if USE_MORPHTARGETS
            ${ct.getMorphTargetCalcVertex()}    
        #endif

        #if USE_SKELETON
            #if USE_JOINT_VEC8
                let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                ORI_MATRIX_M *= skeletonNormal ;
            #else
                let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                ORI_MATRIX_M *= skeletonNormal ;
            #endif
        #endif
    #endif
    
    ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));
   
    #if USE_TANGENT
        ORI_VertexOut.varying_Tangent = vec4f(normalize(ORI_NORMALMATRIX * vertex.TANGENT.xyz),vertex.TANGENT.w)  ;
    #endif

    var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
    var viewPosition = ORI_MATRIX_V * worldPos;
    var clipPosition = ORI_MATRIX_P * viewPosition ;

    #if USE_LOGDEPTH
        clipPosition.z = log2Depth(clipPosition.w, globalUniform.near, globalUniform.far);
    #endif

    ORI_CameraWorldDir = normalize(ORI_CAMERAMATRIX[3].xyz - worldPos.xyz) ;

    ORI_VertexOut.index = f32(vertex.index) ;

    ORI_VertexOut.varying_UV0 = vertex.uv.xy ;

    ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;

    ORI_VertexOut.varying_ViewPos = viewPosition ;
    ORI_VertexOut.varying_Clip = clipPosition ;
    ORI_VertexOut.varying_WPos = worldPos ;
    ORI_VertexOut.varying_WPos.w = f32(vertex.index);
    ORI_VertexOut.varying_WNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

    ORI_VertexOut.member = clipPosition ;
    }
`,To=`
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  rectClip: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,wo=`
    struct IrradianceVolumeData {
        //0
        orientationIndex:f32,
            hysteresis:f32,
            OctRTSideSize:f32,
            OctRTMaxSize:f32,

            //1
            startX:f32,
            startY:f32,
            startZ:f32,
            ProbeSpace:f32,

            //2
            gridXCount:f32,
            gridYCount:f32,
            gridZCount:f32,
            maxDistance:f32,

            //3
            depthSharpness:f32,
            ProbeSourceTextureSize:f32,
            ProbeSize:f32,
            bounceIntensity:f32,

            //4
            probeRoughness:f32,
            normalBias:f32,
            irradianceChebyshevBias:f32,
            rayNumber:f32,

            //5
            irradianceDistanceBias:f32,
            indirectIntensity:f32,
            ddgiGamma:f32,
            lerpHysteresis:f32,
            //6

            debugX:f32,
            debugY:f32,
            debugZ:f32,
            slot0:f32,

            //..
            v7:vec4<f32>,
    }
`,Do=`
    #include "MathShader"
    #include "FastMathShader"
    #include "InstanceUniform"

    var<private> ORI_MATRIX_P: mat4x4<f32>;
    var<private> ORI_MATRIX_V: mat4x4<f32>;
    var<private> ORI_MATRIX_M: mat4x4<f32>;
    var<private> ORI_MATRIX_PV: mat4x4<f32>;
    var<private> ORI_MATRIX_PVInv: mat4x4<f32>;
    var<private> ORI_MATRIX_World: mat4x4<f32>;
    var<private> ORI_CAMERAMATRIX: mat4x4<f32>;
    var<private> ORI_NORMALMATRIX: mat3x3<f32>;
    var<private> ORI_CameraWorldDir: vec3<f32>;
    var<private> ORI_ViewDir: vec3<f32>;

    fn TIME() -> vec3f {
        return vec3f(globalUniform.frame, globalUniform.time , globalUniform.delta);
    }

    fn TIME_frame() -> f32 {
        return globalUniform.frame ;
    }

    fn TIME_time() -> f32 {
        return globalUniform.time ;
    }

    fn TIME_delta() -> f32 {
        return globalUniform.delta ;
    }

    fn MOUSE() -> vec2f {
        return vec2f( globalUniform.mouseX, globalUniform.mouseY) ;
    }

    fn SCREEN() -> vec2f {
        return vec2f( globalUniform.windowWidth, globalUniform.windowHeight) ;
    }

    fn ProjectionParams() -> vec3f {
        return vec3f( globalUniform.near, globalUniform.far,1.0 + 1.0 / globalUniform.far) ;
    }

    fn vertex_inline(vertex:VertexAttributes){
        ORI_MATRIX_P = globalUniform.projMat ;
        ORI_MATRIX_V = globalUniform.viewMat ;
        ORI_MATRIX_PV = ORI_MATRIX_P * ORI_MATRIX_V ;
        ORI_MATRIX_PVInv = globalUniform.pvMatrixInv ;
        ORI_CAMERAMATRIX = globalUniform.cameraWorldMatrix ;

        ORI_MATRIX_M = models.matrix[u32(vertex.index)];
            
        #if USE_INSTANCEDRAW
            let modelID = instanceDrawID.matrixIDs[vertex.index];
            ORI_MATRIX_M = models.matrix[modelID];
        #endif
    }
`,Vo=`
  #include "GlobalUniform"
  #include "FragmentVarying"
  #include "FragmentOutput"
  #include "ShadingInput"
  #include "ColorUtil_frag"
  #include "BitUtil"

  var<private> ORI_FragmentOutput: FragmentOutput;
  var<private> ORI_VertexVarying: FragmentVarying;
  var<private> ORI_ShadingInput: ShadingInput;
  var<private> viewDir:vec3<f32>;
  var<private> modelIndex:u32;
  
  @fragment
  fn FragMain( vertex_varying:FragmentVarying ) -> FragmentOutput {
   
    modelIndex = u32(round(vertex_varying.index)) ; 

    ORI_VertexVarying = vertex_varying;
    ORI_VertexVarying.vWorldNormal = normalize(vertex_varying.vWorldNormal);
    ORI_FragmentOutput.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
    viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;

    frag();
    
    #if USE_DEBUG
      debugFragmentOut();
    #endif

    #if USE_DEFAULTFRAGOUT
      // let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
      // let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
      // let ORI_NORMALMATRIX = transpose(inverse( nMat ));
      // var vNormal = normalize(ORI_NORMALMATRIX * (ORI_VertexVarying.vWorldNormal));

      // let gBuffer = packNHMDGBuffer(
      //   ORI_VertexVarying.fragCoord.z,
      //   ORI_ShadingInput.BaseColor.rgb,
      //   ORI_ShadingInput.BaseColor.rgb,
      //   vec3f(ORI_ShadingInput.Roughness,ORI_ShadingInput.Metallic,ORI_ShadingInput.AmbientOcclusion),
      //   ORI_ShadingInput.Normal,
      //   ORI_ShadingInput.Opacity
      // ) ;
    #endif

    #if USE_OUTDEPTH
      #if USE_LOGDEPTH
        ORI_FragmentOutput.out_depth = log2DepthFixPersp(ORI_VertexVarying.fragPosition.w, globalUniform.near, globalUniform.far);
      #else
        ORI_FragmentOutput.out_depth = ORI_ShadingInput.FragDepth ;
      #endif
    #endif

    return ORI_FragmentOutput ;
  }


  fn packNHMDGBuffer(depth:f32, albedo:vec3f,hdrLighting:vec3f,rmao:vec3f,normal:vec3f,alpha:f32) -> vec4f  {
      var gBuffer : vec4f ;
      var octUVNormal = (octEncode(normalize( (normal) )) + 1.0) * 0.5 ;
      var yc = f32(r11g11b9_to_float(vec3f(octUVNormal,rmao.r))) ;
      #if USE_CASTREFLECTION
        var rgbm = EncodeRGBM(hdrLighting);
        var zc = f32(pack4x8unorm(vec4f(rgbm.rgb,0.0))) ;
        var wc = f32(pack4x8unorm(vec4f(rmao.rg,rgbm.a,0.0)));
      #else
        var zc = f32(vec4fToFloat_7bits(vec4f(albedo.rgb,alpha)));
        var wc = f32(r22g8_to_float(vec2f(f32(modelIndex)/f_r22g8.r,rmao.g)));
      #endif

      gBuffer.x = depth  ;
      gBuffer.y = yc ;
      gBuffer.z = zc ;
      gBuffer.w = wc ;
      return gBuffer ;
  }

  fn transformUV( uv:vec2f , offsetScale:vec4f ) -> vec2f{
     return uv * offsetScale.zw + offsetScale.xy ;
  }

`,No=`
    #include "WorldMatrixUniform"
    #include "VertexAttributes_vert"
    #include "GlobalUniform"
    #include "Inline_vert"
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }
`,Mo=`
    @group(1) @binding(auto)
    var brdflutMapSampler: sampler;
    @group(1) @binding(auto)
    var brdflutMap: texture_2d<f32>;
`,ko=`
    @group(1) @binding(auto)
    var prefilterMapSampler: sampler;
    @group(1) @binding(auto)
    var prefilterMap: texture_cube<f32>;
    @group(1) @binding(auto)
    var envMapSampler: sampler;
    @group(1) @binding(auto)
    var envMap: texture_cube<f32>;
`;class zt{}s(zt,"Cascades",4);let tn=`

  #include "MathShader"

  struct GlobalUniform {

    projMat: mat4x4<f32>,
    viewMat: mat4x4<f32>,
    cameraWorldMatrix: mat4x4<f32>,
    pvMatrixInv : mat4x4<f32>,
    viewToWorld : mat4x4<f32>,
    shadowMatrix: array<mat4x4<f32>, 8u>,

    csmShadowBias: vec4<f32>,

    csmMatrix: array<mat4x4<f32>,${zt.Cascades}>,
    
    shadowLights:mat4x4<f32>,

    reflectionProbeSize:f32,
    reflectionProbeMaxCount:f32,
    reflectionMapWidth:f32,
    reflectionMapHeight:f32,

    reflectionCount:f32,
    test2:f32,
    test3:f32,
    test4:f32,

    CameraPos: vec3<f32>,
    frame: f32,
    SH:  array<vec4f, 9u> ,

    time: f32,
    delta: f32,
    shadowBias: f32,
    skyExposure: f32,

    renderPassState:f32,
    quadScale: f32,
    hdrExposure: f32,
    renderState_left: i32,

    renderState_right: i32,
    renderState_split: f32,
    mouseX: f32,
    mouseY: f32,

    windowWidth: f32,
    windowHeight: f32,
    near: f32,
    far: f32,

    pointShadowBias: f32,
    shadowMapSize: f32,
    shadowSoft: f32,
    enableCSM:f32,


    csmMargin:f32,
    nDirShadowStart: i32,
    nDirShadowEnd: i32,
    nPointShadowStart: i32,

    nPointShadowEnd: i32,
    cameraForward:vec3f,

    frustumPlanes: array<vec4f, 6u>,

  };

  @group(0) @binding(0)
  var<uniform> globalUniform: GlobalUniform;

  fn getViewPosition(z:f32,uv:vec2f) -> vec3f {
    let pvMatrixInv = globalUniform.pvMatrixInv ;
    let clip = vec4<f32>((uv * 2.0 - 1.0) , z , 1.0);
    var viewPos = pvMatrixInv * clip ;
    return viewPos.xyz / viewPos.w ;
  }

  fn getWorldPosition(z:f32,uv:vec2f) -> vec3f {
    let viewToWorld = globalUniform.viewToWorld ;
    let clip = vec4<f32>((uv * 2.0 - 1.0) , z , 1.0);
    var worldPos = viewToWorld * clip ;
    worldPos = worldPos / worldPos.w ;
    return worldPos.xyz ;
  }

  var<private> NORMALMATRIX_INV : mat3x3<f32> ;
  var<private> NORMALMATRIX : mat3x3<f32> ;
  fn useNormalMatrix()  {
     let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
     let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
     NORMALMATRIX = transpose(inverse( nMat ));
  }

  fn useNormalMatrixInv()  {
    let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
    let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
    NORMALMATRIX_INV = transpose(( nMat ));
  }

  fn getWorldNormal(viewNormal:vec3f) -> vec3f {
    var worldNormal = NORMALMATRIX_INV * viewNormal ;
    return normalize(worldNormal.xyz);
  }

  fn getViewNormal(worldNormal:vec3f) -> vec3f {
    var viewNormal = globalUniform.viewMat * vec4f(worldNormal,0.0) ;
    return normalize(viewNormal.xyz);
  }
`,Po=`
    #if USE_INSTANCEDRAW
        struct InstanceUniform {
            matrixIDs : array<i32>
        };
        @group(2) @binding(7)
        var<storage, read> instanceDrawID : InstanceUniform;
    #endif
`,rn=`
    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;
`,Lo=`
  fn pow2(  x : f32 ) -> f32
  {
      return x * x;
  }

  fn pow2v3(  x : vec3f ) -> vec3f
  {
      return x * x;
  }


  fn pow3(  x : f32 ) -> f32
  {
      var xx = x*x;
      return x * xx;
  }

  fn pow4(  x : f32 ) -> f32
  {
      var xx = x*x;
      return xx * xx;
  }

  fn pow5(x: f32) -> f32 {
      var x2 = x * x;
      return x2 * x2 * x;
  }

  fn rcp( x:f32 ) -> f32
  {
      return 1.0 / x;
  }

  fn rsqrt3( a : vec3<f32> ) -> vec3<f32>
  {
    return pow(a, vec3<f32>(-0.5));
  }

  fn rsqrt( a : f32 ) -> f32
  {
    return pow(a, -0.5);
  }

  fn squareF( a : f32 ) -> f32
  {
    return a * a;
  }

  fn squareV2( a : vec2f ) -> vec2f
  {
    return a * a;
  }

  fn squareV3( a : vec3f ) -> vec3f
  {
    return a * a;
  }

  fn sqrtFast(  x : f32  ) -> f32 
  {
    var i = i32(x);
    i = 0x1FBD1DF5 + (i / 2 );
    return f32(i);
  }

  fn lengthFast(  v :vec3<f32> ) -> f32
  {
    var LengthSqr = dot(v,v);
    return sqrtFast( LengthSqr );
  }

  fn asinFast( x:f32 )-> f32
  {
      return (0.5 * PI) - acosFast(x);
  }

  fn acosFast( inX: f32 ) -> f32
  {
      var x = abs(inX);
      var res = -0.156583 * x + (0.5 * PI);
      res *= sqrt(1.0 - x);

    if(inX >= 0.0){
      return res ;
    }else{
      return PI - res ;
    }
  }

  fn acosFast4( inX : f32 )-> f32
  {
    var x1 = abs(inX);
    var x2 = x1 * x1;
    var x3 = x2 * x1;
    var s = 0.0 ;

    s = -0.2121144 * x1 + 1.5707288;
    s = 0.0742610 * x2 + s;
    s = -0.0187293 * x3 + s;
    s = sqrt(1.0 - x1) * s;

    // acos function mirroring
    // check per platform if compiles to a selector - no branch neeeded
    if(inX >= 0.0){
      return s ;
    }else{
      return PI - s ;
    }
  }
`,Oo=`

    fn perturbNormal(  worldPos:vec3<f32>,  surf_norm:vec3<f32>,  mapN:vec3<f32> , normalScale:f32 , face:f32 ) -> vec3<f32> {
        var q0 = vec3<f32>( dpdx( worldPos.x ), dpdx( worldPos.y ), dpdx( worldPos.z ) );
        var q1 = vec3<f32>( dpdy( worldPos.x ), dpdy( worldPos.y ), dpdy( worldPos.z ) );
        var st0 = dpdx( ORI_VertexVarying.fragUV0.xy );
        var st1 = dpdy( ORI_VertexVarying.fragUV0.xy );
        var N = surf_norm;
        var q0perp = cross( N, q0 );
        var q1perp = cross( q1, N );

        // #if USE_TANGENT
        //     var T = ORI_VertexVarying.TANGENT.xyz ;
        // #else
            var T = q1perp * st0.x + q0perp * st1.x;
        // #endif
        
        var B = q1perp * st0.y + q0perp * st1.y;

        var det = max( dot( T, T ), dot( B, B ) );
        var scale = 1.0 ;
        if( det != 0.0 ){
            scale = inverseSqrt( det ) ;
        }

        // #if USE_TANGENT
        //     scale = scale * ORI_VertexVarying.TANGENT.w ;
        // #endif

        scale *= normalScale;
        return normalize( (T * ( -mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z ) * face ) ;
    }

    fn unpackNormalMap( normal : vec3<f32> ) -> vec3<f32>
    {
        var normalTex = vec3<f32>( normal.xyz * 2.0 - 1.0 ) ;
        return (normalTex);
    }

    fn unPackNormal(normal : vec3<f32> , height:f32 ) -> vec3<f32>{
        var face = 1.0 ;
        if(ORI_VertexVarying.face){
            face = 1.0 ;
        }else{
            face = -1.0 ;
        }

        #if USE_RGNORMAL
            return unPackRGNormal(normal,height,face);
        #else
            var n = normal ;
            #if USE_NORMALFILPY
            n.y = 1.0 - n.y ; 
            #endif
            
            var mapNormal: vec3<f32> = n ;//unpackNormalMap(n) ;
            return perturbNormal(ORI_VertexVarying.vWorldPos.xyz , ORI_VertexVarying.vWorldNormal.xyz , mapNormal , height , face  ) ;
        #endif
    }

    fn unPackRGNormal(normal : vec3<f32> , height:f32 , face:f32) -> vec3<f32> {
        var d = normal.rg * 2.0 - 1.0 ;
        var l = 1.0 - saturate(dot(d,d));
        var s = sqrt(l);
        var rg = d * height ; 
        var mapNormal = vec3<f32>(rg,s);
        var outN = perturbNormal(ORI_VertexVarying.vWorldPos.xyz,ORI_VertexVarying.vWorldNormal,mapNormal,1.0,face) ;
        return outN ;
    }
`,Go=`
    struct FragmentVarying {
        @location(auto) index: f32,
        @location(auto) fragUV0: vec2<f32>,
        @location(auto) fragUV1: vec2<f32>,
        @location(auto) viewPosition: vec4<f32>,
        @location(auto) fragPosition: vec4<f32>,
        @location(auto) vWorldPos: vec4<f32>,
        @location(auto) vWorldNormal: vec3<f32>,
        @location(auto) vColor: vec4<f32>,

        #if USE_SHADOWMAPING
            @location(auto) vShadowPos: vec4<f32>,
        #endif

        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
        #endif
        
        @builtin(front_facing) face: bool,
        @builtin(position) fragCoord : vec4<f32>
    };
`,an=`
    #if USE_CASTREFLECTION
        struct FragmentOutput {
            @location(auto) gBuffer: vec4<f32>,
            #if USE_OUTDEPTH
                @builtin(frag_depth) out_depth: f32
            #endif
        };
    #else
        struct FragmentOutput {
            @location(auto) color: vec4<f32>,
            @location(auto) gBuffer: vec4<f32>,
            #if USE_OUTDEPTH
                @builtin(frag_depth) out_depth: f32
            #endif
        };
    #endif
`,Wo=`
    struct ShadingInput{
        BaseColor:vec4<f32>,

        Roughness:f32,
        Metallic:f32,
        Specular:f32,

        EmissiveColor:vec4<f32>,
        SurfaceColor:vec4<f32>,

        Normal:vec3<f32>,
        HairNormal:vec3<f32>,
        Tangent:vec4<f32>,

        WorldPositionOffset:vec3<f32>,
        AmbientOcclusion:f32,

        PixelDepthOffset:f32,

        Opacity:f32,
        OpacityMask:f32,

        Refraction:f32,
        FragDepth:f32,

        SSS:vec3f,

        // color:vec4f ,
        // normal:vec3f,
        // alpha:f32,
        // roughness:f32,
        // metallic:f32,
        // occlusion:f32,
        // specularColor:vec4f ,
        // specularIntensity:vec4f ,
        // emissiveColor:vec4f,
        // emissiveIntensity:f32,
        // shadow:f32,
        // ior:f32,
        // alphaClip:f32,

        // position:vec4f,
        // depth:f32
    }
`,Jo=`
    #if USE_IES_PROFILE 
        @group(1) @binding(auto)
        var iesTextureArrayMapSampler : sampler;
        @group(1) @binding(auto)
        var iesTextureArrayMap: texture_2d_array<f32> ;
    #endif

    fn getLightIESProfileAtt( wPos : vec3<f32> , light:LightData ) -> f32
    {
        #if USE_IES_PROFILE 
            let tangent = vec3<f32>(1.0,0.0,0.0);
            let lightBitangent = normalize( cross( tangent, light.direction ) );
            let lightMatrix = mat4x4( vec4<f32>(light.direction.xyz, 0.0), vec4<f32>(lightBitangent.xyz, 0.0), vec4<f32>(tangent.xyz, 0.0), vec4<f32>(0.0, 0.0, 0.0, 1.0) );
            let lightMatrixInv = transpose(lightMatrix);
            let lightPos = light.position.xyz;
            let l = lightPos - wPos; 
            let toLight = normalize(l);
            let localToLight = (vec4<f32>(toLight.xyz, 0.0) * lightMatrixInv).xyz;
            let dotProd = dot(toLight, light.direction);
            let angle = asin(dotProd);
            let normAngle = (angle / PI) + 0.5 ;
            let tangentAngle = atan2( -localToLight.z, -localToLight.x ); 
            let normTangentAngle = tangentAngle / (PI * 2.0) + 0.5 ;
            if(light.ies >= 0.0){
                return textureSampleLevel(iesTextureArrayMap, iesTextureArrayMapSampler, vec2<f32>(normAngle , normTangentAngle) , i32(light.ies) , 0.0).r ;
            }else{
                return 1.0;
            }
        #else 
            return 1.0;
        #endif
    }

`,zo=`
    @group(1) @binding(auto) var shadowMapSampler: sampler;
    @group(1) @binding(auto) var shadowMap: texture_depth_2d_array;
    @group(1) @binding(auto) var pointShadowMapSampler: sampler;
    @group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array;

    var<private> directShadowVisibility: array<f32, 8>;
    var<private> pointShadows: array<f32, 8>;
    var<private> shadowWeight: f32 = 1.0 ;

    fn useShadow(){
        directShadowVisibility = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        pointShadows = array<f32, 8>(1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        directShadowMaping(globalUniform.shadowBias);
        pointShadowMapCompare(globalUniform.pointShadowBias);
    }

    fn calcBasicBias(shadowWorldSize:f32, shadowDepthTexSize:f32, near:f32, far:f32) -> f32{
      var bias = shadowWorldSize / shadowDepthTexSize;
      bias = bias / (far - near);
      return bias * 2.0;
    }

    const dirCount:i32 = 8 ;
    const pointCount:i32 = 8 ;
    const csmCount:i32 = ${zt.Cascades} ;
    var<private> csmLevel:i32 = -1;
    fn directShadowMaping(shadowBias: f32)  {

        let enableCSM:bool = globalUniform.enableCSM > 0.5;
        for (var i: i32 = 0; i < dirCount ; i = i + 1) {
          if( i >= globalUniform.nDirShadowStart && i < globalUniform.nDirShadowEnd ){
            let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
            let light = lightBuffer[u32(ldx)] ;
            var shadowIndex = i32(light.castShadow);
            var visibility = 1.0;
            var shadowMatrix:mat4x4<f32>;
            #if USE_CSM
              if(enableCSM && shadowIndex == 0){
                var totalWeight = 0.0;
                visibility = 0.0;
                var validCount = 0;
                for(var csm:i32 = 0; csm < csmCount; csm ++){
                  var csmShadowBias = globalUniform.csmShadowBias[csm] * shadowBias;
                  shadowMatrix = globalUniform.csmMatrix[csm];
                  let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, csm, csmShadowBias);
                  if(csmShadowResult.y < 0.5){
                    validCount ++;

                    var uv = 2.0 * csmShadowResult.zw - vec2<f32>(1.0);
                    uv = saturate(vec2<f32>(1.0) - abs(uv));
                    uv /= clamp(globalUniform.csmMargin, 0.01, 0.5);
                    var weight:f32 = min(uv.x, 1.0);
                    weight = min(weight, uv.y);

                    if(validCount == 1 && csm == csmCount - 1){
                      visibility = 1.0 - weight + csmShadowResult.x * weight;
                      totalWeight = 1.0;
                    }else{
                      weight *= 1.0 - totalWeight;
                      visibility += csmShadowResult.x * weight;
                      totalWeight += weight;
                    }
                    // if(weight < 1.0){
                    //   visibility += 0.1;
                    // }
                    if(validCount >= 2 || totalWeight >= 0.99){
                      csmLevel = csm;
                      break;
                    }
                  }
                }
                totalWeight += 0.0001;
                if(validCount == 0){
                  visibility = 1.0;
                }else{
                  visibility = visibility / totalWeight ;
                }
              }else{
                shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
                if(enableCSM) {
                  shadowIndex += csmCount - 1;
                }
                visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
              }
            #else
              shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
              visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
            #endif 
            directShadowVisibility[i] = visibility;
          }
        }

    }

    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, depthTexIndex:i32, shadowBias:f32) -> vec4<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var varying_shadowUV:vec2<f32> = vec2<f32>(0.0);
      #if USE_SHADOWMAPING
        var shadowPosTmp = matrix * vec4<f32>(ORI_VertexVarying.vWorldPos.xyz, 1.0);
        var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
        varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
        if (varying_shadowUV.x <= 1.0
          && varying_shadowUV.x >= 0.0
          && varying_shadowUV.y <= 1.0
          && varying_shadowUV.y >= 0.0
          && shadowPosTmp.z <= 1.0
          && shadowPosTmp.z >= 0.0)
        {
          visibility = 0.0;
          isOutSideArea = 0.0;
          var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize) ;
          var totalWeight = 0.0;
          // var NoL = (dot(normalize(ORI_VertexVarying.vWorldNormal), normalize(-light.direction)));
          // let v = max(NoL, 0.0) ;
          // var bias = max(0.05 * (dot(normalize(fragData.N), normalize(-light.direction)) ), -shadowBias); 
          var bias = -0.005 * max(dot(fragData.N, -light.direction) , 0.0 ); 
          bias = clamp(bias, 0, 0.01) + -shadowBias;

          // var bias = shadowBias / v;
          let bound = 1 ;
          for (var y = -bound; y <= bound; y++) {
            for (var x = -bound; x <= bound; x++) {
                var offset = vec2<f32>(f32(x), f32(y)) ;
                var offsetUV = offset * uvOnePixel ;
                var weight = min(length(offset),1.0) ;
                var depth = textureSampleLevel(shadowMap, shadowMapSampler, varying_shadowUV + offsetUV , depthTexIndex, 0);
                if ((shadowPos.z - bias ) < depth) {
                  visibility += weight ;
                  totalWeight += weight;
                }else{
                  totalWeight += 1.0;
                }
            }
          }
          visibility /= totalWeight;
      }
      #endif
      return vec4<f32>(visibility, isOutSideArea, varying_shadowUV);
    }

    fn pointShadowMapCompare(shadowBias: f32){
      let worldPos = ORI_VertexVarying.vWorldPos.xyz;
      let offset = 0.1;

      for (var i: i32 = 0; i < pointCount ; i = i + 1) {
        if( i >= globalUniform.nPointShadowStart && i < globalUniform.nPointShadowEnd ){
          let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
          let light = lightBuffer[u32(ldx)] ;

          #if USE_SHADOWMAPING
              let lightPos = light.position.xyz;
              var shadow = 0.0;
              let frgToLight = worldPos - lightPos.xyz;
              var dir: vec3<f32> = normalize(frgToLight);
              var len = length(frgToLight);
              var bias = max(shadowBias * globalUniform.far * (1.0 - dot(ORI_ShadingInput.Normal, dir)), 0.005);
  
          #if USE_PCF_SHADOW
              let samples = 4.0;
              let sampleOffset = offset / (samples * 0.5);
              for (var x: f32 = -offset; x < offset; x += sampleOffset) {
                for (var y: f32 = -offset; y < offset; y += sampleOffset) {
                  for (var z: f32 = -offset; z < offset; z += sampleOffset) {
                    let offsetDir = normalize(dir.xyz + vec3<f32>(x, y, z));
                    var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                    depth *= globalUniform.far;
                    if ((len - bias) > depth) {
                      shadow += 1.0 * dot(offsetDir, dir.xyz);
                    }
                  }
                }
              }
              shadow = min(max(shadow / (samples * samples * samples), 0.0), 1.0);
            #endif
  
          #if USE_SOFT_SHADOW
              let vDis = length(globalUniform.CameraPos.xyz - worldPos.xyz);
              let sampleRadies = globalUniform.shadowSoft;
              let samples = 20;
              for (var j: i32 = 0; j < samples; j += 1) {
                let offsetDir = normalize(dir.xyz + sampleOffsetDir[j] * sampleRadies);
                var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                depth *= globalUniform.far;
                if ((len - bias) > depth) {
                  shadow += 1.0 * dot(offsetDir, dir.xyz);
                }
              }
              shadow = min(max(shadow / f32(samples), 0.0), 1.0);
          #endif
  
          #if USE_HARD_SHADOW
              var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, dir.xyz, light.castShadow, 0);
              depth *= globalUniform.far;
              if ((len - bias) > depth) {
                shadow = 1.0;
              }
          #endif
              for (var j = 0; j < pointCount ; j+=1 ) {
                  if(i32(light.castShadow) == j){
                    pointShadows[j] = 1.0 - shadow ;
                  }
              }
          #endif
        }
        }
    }

    #if USE_SOFT_SHADOW
      var<private>sampleOffsetDir : array<vec3<f32>, 20> = array<vec3<f32>, 20>(
        vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(-1.0, -1.0, 1.0), vec3<f32>(-1.0, 1.0, 1.0),
        vec3<f32>(1.0, 1.0, -1.0), vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(-1.0, -1.0, -1.0), vec3<f32>(-1.0, 1.0, -1.0),
        vec3<f32>(1.0, 1.0, 0.0), vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(-1.0, -1.0, 0.0), vec3<f32>(-1.0, 1.0, 0.0),
        vec3<f32>(1.0, 0.0, 1.0), vec3<f32>(-1.0, 0.0, 1.0), vec3<f32>(1.0, 0.0, -1.0), vec3<f32>(-1.0, 0.0, -1.0),
        vec3<f32>(0.0, 1.0, 1.0), vec3<f32>(0.0, -1.0, 1.0), vec3<f32>(0.0, -1.0, -1.0), vec3<f32>(0.0, 1.0, -1.0),
      );
    #endif
`,Zo=`
#include "IrradianceVolumeData_frag"
    struct IrradianceField {
        probeStartPosition: vec4<f32>,
        probeCounts:vec4<f32>,
        probeStep:f32,
        irradianceTextureWidth:f32,
        irradianceTextureHeight:f32,
        irradianceProbeSideLength:f32,
    };

    @group(1) @binding(auto)
    var irradianceMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var irradianceDepthMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceDepthMap: texture_2d<f32>;
    @group(2) @binding(7)
    var<uniform> irradianceData : IrradianceVolumeData ;

    var<private> irradianceFieldSurface: IrradianceField;
    var<private> energyPreservation: f32 = 0.85;
    var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

    fn getIrradianceFieldSurface() -> IrradianceField{
        let data = irradianceData ;
        irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
        irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
        irradianceFieldSurface.probeStep = data.ProbeSpace;
        irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
        return irradianceFieldSurface;
    }

    fn rotateDir(n:vec3<f32>) -> vec3<f32>{
       return normalize(applyQuaternion(-n, quaternion));
    }

    fn square1f(v:f32) -> f32 {
        return v * v ;
     }

   fn square(v:vec3<f32>) -> vec3<f32>{
      return v*v;
   }

    fn getIrradiance() -> vec4<f32>{
        var irradiance = sampleIrradianceField();
        var outerVolumeFactor:f32 = getOuterVolume(irradianceFieldSurface, ORI_VertexVarying.vWorldPos.xyz);
        irradiance *= outerVolumeFactor;
       return irradiance ;
    }
    
    fn debugProbe(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0);
        return probeIrradiance;
    }
    
    fn debugProbeDepth(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);
        
        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV ,0.0);
        probeIrradiance.x = probeIrradiance.x / irradianceData.maxDistance;
        probeIrradiance.y = 0.0;
        probeIrradiance.z = 0.0;
        probeIrradiance.w = 1.0;
        return probeIrradiance;
    }
    
    fn getOuterVolume(L:IrradianceField, position:vec3<f32>) -> f32{
        let halfWidth:vec3<f32> = 0.5 * (L.probeCounts.xyz - 1.0) * L.probeStep;
        let edgeWidth:vec3<f32> = halfWidth + L.probeStep;
        let centerPosition:vec3<f32> = halfWidth + L.probeStartPosition.xyz;
        let clampPos = min(edgeWidth, abs(position - centerPosition));
        
        let factorX = getOuterAxis(clampPos.x, edgeWidth.x, L.probeStep);
        let factorY = getOuterAxis(clampPos.y, edgeWidth.y, L.probeStep);
        let factorZ = getOuterAxis(clampPos.z, edgeWidth.z, L.probeStep);
        return factorX * factorY * factorZ;
    }
    
    fn getOuterAxis(current:f32, edge:f32, space:f32) -> f32{
        return clamp((edge - current) / space, 0.0, 1.0);
    }

    fn getBaseGridCoord(L:IrradianceField, X:vec3<f32>) -> vec3<i32> {
        var offsetIndex = (X - L.probeStartPosition.xyz) / irradianceFieldSurface.probeStep;
        return clamp(vec3<i32>(offsetIndex.xyz), vec3<i32>(0), vec3<i32>(L.probeCounts.xyz) - 1);
    }

    fn gridCoordToProbeIndex(L:IrradianceField, grid:vec3<i32>) -> i32
    {
        return grid.x + i32(L.probeCounts.x) * grid.z + grid.y * i32(L.probeCounts.z * L.probeCounts.x);
    }

    fn gridCoordToPosition(L:IrradianceField, grid:vec3<i32>) -> vec3<f32>
    {
        var pos:vec3<f32> = vec3<f32>(grid.xyz) * L.probeStep + L.probeStartPosition.xyz;
        return pos;
    }

    fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
    {
        var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
        uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
        uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
        return uv ;
    }

    fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
    {
        var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
        var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetZ = probeID / blockCount ;

        var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

        var blockOffset = vec2<f32>(0.0);
        blockOffset.x = f32(offsetX) * size;
        blockOffset.y = f32(offsetY) * size + f32(offsetZ) * irradianceFieldSurface.probeCounts.z * size;

        let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
        var probeCounts:vec3<f32> = irradianceFieldSurface.probeCounts.xyz;

        var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
        var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

        pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

        return pixelCoord + 1.0 ;
    }

    fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
    {
      var pixelCoord = pixelCoord0;
      let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
      let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
      let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
      let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
      let col:i32 = pixelCoord.y / pixelCountYMax;
      pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
      pixelCoord.y = pixelCoord.y % pixelCountYMax;
      return pixelCoord;
    }

    var<private> wpNormal:vec3<f32> ;
    fn sampleIrradianceField() -> vec4<f32>{
        wpNormal = ORI_ShadingInput.Normal.xyz ;
        var wo:vec3<f32> = ORI_CameraWorldDir ;
        var wsN:vec3<f32> = normalize(wpNormal);
        var direction:vec3<f32> = wpNormal;
        var worldPosition: vec3<f32> = ORI_VertexVarying.vWorldPos.xyz;
   
        getIrradianceFieldSurface();

        let surfaceBias = (wsN + 3.0 * wo) * irradianceData.normalBias ;

        var irradiance = vec3<f32>(0.0, 0.0, 0.0);
        var accumulatedWeights = 0.0;
        var biasedWorldPosition = (worldPosition + surfaceBias);

        var baseProbeCoords: vec3<i32> = getBaseGridCoord(irradianceFieldSurface, worldPosition);
        
        var baseProbeWorldPosition: vec3<f32> = gridCoordToPosition(irradianceFieldSurface, baseProbeCoords) ;
        
        var gridSpaceDistance = (biasedWorldPosition - baseProbeWorldPosition);

        // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
        var alpha: vec3<f32> = clamp(gridSpaceDistance / (irradianceFieldSurface.probeStep), vec3<f32>(0.0), vec3<f32>(1.0));
        // let irradianceDir = rotateDir(wsN.xyz);
        // Iterate over adjacent probe cage
        for (var i:i32 = 0; i < 8; i = i + 1) {
            var adjacentProbeOffset : vec3<i32> = vec3<i32>(i, i32(f32(i) * 0.5), i32(f32(i) * 0.25)) & vec3<i32>(1);
            var adjacentProbeCoords: vec3<i32> = clamp(baseProbeCoords + adjacentProbeOffset, vec3<i32>(0),  vec3<i32>(irradianceFieldSurface.probeCounts.xyz) - 1) ;
            
            var adjacentProbeIndex :i32 = gridCoordToProbeIndex(irradianceFieldSurface, adjacentProbeCoords);
            var adjacentProbeWorldPosition :vec3<f32> = gridCoordToPosition(irradianceFieldSurface, adjacentProbeCoords) ;//+ (wsN + 3.0 * w_o) * globalUniform.normalBias;
         
            var worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
            var biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
            var biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);

            let trilinear = max(vec3<f32>(0.001), mix(1.0 - alpha, alpha, vec3<f32>(adjacentProbeOffset)));
            let trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
            var weight = 1.0;

            var wrapShading = (dot(worldPosToAdjProbe, direction) + 1.0) * 0.5;
            weight *= (wrapShading * wrapShading) + 0.2;

            var depthDir = -biasedPosToAdjProbe;//probe - world
            depthDir = applyQuaternion(depthDir, quaternion);
            var probeTextureUV : vec2<f32> = textureCoordFromDirection(depthDir.xyz,
                adjacentProbeIndex,
                irradianceFieldSurface.irradianceTextureWidth,
                irradianceFieldSurface.irradianceTextureHeight,
                irradianceFieldSurface.irradianceProbeSideLength);

            var filteredDistance : vec2<f32> = 2.0 * textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV,0.0).rg ;
           
            var variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);

            var chebyshevWeight = 1.0;
            if(biasedPosToAdjProbeDist > filteredDistance.x ) // occluded
            {
                var v = biasedPosToAdjProbeDist - filteredDistance.x ;
                chebyshevWeight = variance / (variance + (v * v));
                // Increase the contrast in the weight
                chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.0);
            }

            weight *= max(0.05, chebyshevWeight);
            weight = max(0.000001, weight);

            let crushThreshold = 0.2;
            if (weight < crushThreshold)
            {
                weight *= (weight * weight) * (1.0 / (crushThreshold * crushThreshold));
            }

            weight *= trilinearWeight;
            
            //worldPosToAdjProbe
            let rotateDir = applyQuaternion(-direction, quaternion);
            probeTextureUV = textureCoordFromDirection((rotateDir),
            adjacentProbeIndex,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

            var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0).xyz;

            var exponent =  irradianceData.ddgiGamma * 0.5;
            probeIrradiance = pow(probeIrradiance, vec3<f32>(exponent));
            
            irradiance += (weight * probeIrradiance);
            accumulatedWeights += weight;
        }

        if(accumulatedWeights == 0.0){
            return vec4<f32>(0.0, 0.0, 0.0,1.0);
        }

        irradiance *= (1.0 / accumulatedWeights);   
        irradiance *= irradiance;                   

        irradiance *= 6.2831853071795864;
        irradiance *= irradianceData.indirectIntensity;
        return vec4<f32>(irradiance,1.0) ;
    }

`,Xo=`
#include "Clearcoat_frag"
    #include "EnvMap_frag"
    #include "BrdfLut_frag"
    #include "ColorUtil_frag"
    #include "SHCommon_frag"
    
    struct FragData {
        Ao: f32,
        Metallic: f32,
        Roughness: f32,

        Albedo: vec4<f32>,
        Emissive: vec3<f32>,
        Specular: vec3<f32>,

        N: vec3<f32>,
        V: vec3<f32>,
        R: vec3<f32>,
        T: vec3<f32>,

        F0: vec3<f32>,
        F: vec3<f32>,
        KS: vec3<f32>,
        KD: vec3<f32>,

        Alpha: f32,
        Shadow: f32,
        Indirect: f32,
        Reflectance: f32,

        NoV: f32,
        FaceDirection:f32,

        ClearcoatRoughness:f32,
        ClearcoatFactor:f32,
        ClearcoatIor:f32,
        EnvColor: vec3<f32>,
        Irradiance: vec3<f32>,

        LightChannel: vec3<f32>
    };

    var<private> fragData: FragData;

    struct BxDFContext
    {
        NoV : f32 ,
        NoL : f32 ,
        VoL : f32 ,
        NoH : f32 ,
        HoL : f32 ,
        VoH : f32
    };

    fn getContext( N:vec3<f32>, V:vec3<f32>, H:vec3<f32>, L:vec3<f32> ) -> BxDFContext
    {
        var Context:BxDFContext ;
        Context.NoL = saturate(dot(N, L));
        Context.NoV = saturate(dot(N, V));
        Context.VoL = saturate(dot(V, L));
        Context.NoH = saturate(dot(N, H));
        Context.VoH = saturate(dot(V, H));
        Context.HoL = saturate(dot(H, L));
        return Context ;
    }

    // convert roughness to mipmapLevel
    fn roughnessToMipmapLevel( roughness: f32 , mipmapCount:i32 ) -> f32{
        let level = roughness * (1.7 - 0.7 * roughness );
        return level * f32(mipmapCount);
    }

    fn IORToF0(ior:f32)->f32{
        var dc = ior - 1.0 ;
        dc *= dc ;
        var dt = ior + 1.0 ;
        dt *= dt ;
        return dc / dt ;
    }

    fn Fd90( NoL:f32, roughness:f32) -> f32
    {
        return (2.0 * NoL * roughness) + 0.4;
    }

  

    fn KDisneyTerm( NoL:f32, NoV:f32 , roughness:f32) -> f32
    {
        return (1.0 + Fd90(NoL, roughness) * pow(1.0 - NoL, 5.0)) * (1.0 + Fd90(NoV, roughness) * pow(1.0 - NoV, 5.0));
    }

    fn FresnelSchlick( NoV:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);
    }

    fn FresnelTerm( cosA:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return F0 + (1.0 - F0) * t;
    }

    fn FresnelLerp( cosA:f32, F0:vec3<f32> , F90:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return mix( F0 ,F90,t ) ;
    }

    fn FresnelSchlickRoughness( NoV:f32,  F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(roughness), F0) - F0) * pow(1.0 - NoV, 5.0);
    }

    fn DistributionGGX( NdotH:f32 ,  roughness:f32 ) -> f32
    {
        let alpha = roughness * roughness;
        let alpha2 = roughness * roughness;

        let NdotH2 = NdotH * NdotH;

        let nom   = alpha2;
        var denom = (NdotH2 * (alpha2 - 1.0) + 1.0);
        denom = PI * denom * denom;

        return nom / denom;
    }

    // [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
    fn Vis_SmithJoint( NoV : f32 ,  NoL : f32 ,  a2 : f32) -> f32
    {
        var Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
        var Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
        return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
    }

    fn Vis_SmithJointApprox( NoV : f32 ,  NoL : f32 ,  a2 : f32 ) -> f32
    {
        let a = sqrt(a2);
        let Vis_SmithV = NoL * ( NoV * ( 1.0 - a ) + a );
        let Vis_SmithL = NoV * ( NoL * ( 1.0 - a ) + a );
        return 0.5 * rcp( Vis_SmithV + Vis_SmithL );
    }

    fn GeometrySchlickGGX( NdotV : f32 , roughness : f32 ) -> f32
    {
        //roughness compute ks
        let r = (roughness + 1.0);
        let k = (r*r) / 8.0;

        let nom   = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        
        return nom / denom;
    }
    
    fn GeometrySmith( NdotV:f32 , NdotL:f32 , roughness : f32) -> f32
    {
        // let NdotV = max(dot(N, V), 0.0);
        // let NdotL = max(dot(N, L), 0.0);
        let ggx1 = GeometrySchlickGGX(NdotV, roughness);
        let ggx2 = GeometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
    }

    fn GeometryAttenuationGGXSmith( NdotL:f32,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn colorLinear( colorVector:vec3<f32> ) -> vec3<f32>
    {
        var linearColor = pow(colorVector.rgb, vec3<f32>(2.2));
        return linearColor;
    }

    fn computeFresnelSchlick( NoV:f32 , F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - NoV,0.0,1.0), 5.0);
    }

    fn computeFresnelSchlickRoughness(NoV:f32 , F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - fragData.NoV,0.0,1.0), 5.0);
    }

    fn computeDistributionGGX( N:vec3<f32>,  H:vec3<f32>,  roughness:f32) -> f32
    {
        var alpha = roughness * roughness;
        var alpha2 = alpha * alpha; 

        var NdotH = saturate(dot(N, H));
        var NdotH2 = NdotH * NdotH;

        return (alpha2) / (PI * (NdotH2 * (alpha2 - 1.0) + 1.0) * (NdotH2 * (alpha2 - 1.0) + 1.0));
    }

    fn D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        var d = ( NoH * roughness - NoH ) * NoH + 1.0;	// 2 mad
        return roughness / ( PI*d*d );					// 4 mul, 1 rcp
    }

    fn computeGeometryAttenuationGGXSmith( NdotL:f32 ,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn Vis_Smith(  NoL:f32 ,  NoV:f32,  a2:f32 )-> f32
    {
        var Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
        var Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
        return rcp( Vis_SmithV * Vis_SmithL );
    }

    fn F_Function( HdotL:f32, F0:vec3f ) -> vec3f
  {
      var fresnel = exp2((-5.55473 * HdotL - 6.98316) * HdotL);
      return mix(vec3f(fresnel),vec3f(1.0),F0);
  }

  fn D_Function( NdotH:f32, roughness:f32) ->f32
  {
      var a      = roughness*roughness;
      var a2     = a*a;
      var NdotH2 = NdotH*NdotH;
      var nom   = a2;
      var denom = (NdotH2 * (a2 - 1.0) + 1.0);
      denom = PI * denom * denom;
      return nom / denom;
  }

  //G 
  fn G_SubFunction( NdotW : f32,  K : f32)->f32
  {
      return NdotW / mix(NdotW,1.0,K);
  }

  fn G_Function( NdotL: f32, NdotV: f32, roughness: f32)->f32
  {
      var K = (1.0+roughness) * (1.0+roughness) / 8.0;
      return G_SubFunction(NdotL,K) * G_SubFunction(NdotV,K);
  }
  
  fn DGF_Function( NdotH:f32, NdotL:f32,NdotV:f32, HdotL:f32, roughness:f32, shadow:f32, F0:vec3f , lightColor:vec3f )-> vec3f
  {
      var  D = D_Function(NdotH,roughness);
      var  G = G_Function(NdotL,NdotV,roughness);
      var F = F_Function(HdotL,F0);
      // var light_BRDF = saturate(( D * G * F ) / (4 * NdotL * NdotV + 0.001));
      let light_BRDF = ( D * G * F ) / (4.0 * NdotV * NdotL + 0.001);
      return light_BRDF * lightColor * NdotL * PI * shadow;
  }

  fn LightDiffuse_Function( HdotL:f32, NdotL:f32 ,  baseColor:vec3f,  metallic:f32,  shadow:f32, F0:vec3f, lightColor:vec3f) -> vec3f
  {
      var KS = F_Function(HdotL,F0);
      var KD = (1 - KS) * (1 - metallic);
      return KD * baseColor * lightColor.rgb * NdotL * shadow; 
  }

  fn lightContribution( NdotH:f32, NdotL:f32, NdotV:f32, HdotL:f32, roughness:f32, baseColor:vec3f, metallic:f32, shadow:f32, F0:vec3f, lightColor:vec3f ) ->vec3f
  {
      return LightDiffuse_Function(HdotL,NdotL,baseColor,metallic,shadow,F0,lightColor) + DGF_Function(NdotH,NdotL,NdotV,HdotL,roughness,shadow,F0,lightColor);
  }

    fn simpleBRDF( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,L:vec3<f32>,att:f32,lightColor:vec3<f32>,roughness:f32 ,metallic:f32)-> vec3<f32>{
        let H = normalize(V + L);
        let Context:BxDFContext = getContext(N,V,H,L);
        let alpha = roughness * roughness;
        let a2 = alpha * alpha;
        let F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), albedo.rgb , metallic);
        let D = D_GGX( Context.NoH , a2);
        let G = Vis_SmithJointApprox(Context.NoV,Context.NoL, a2 );
        let F = FresnelSchlick(Context.VoH, vec3<f32>(F0));
        let specular = ( D * G * F ) / (4.0 * Context.NoV * Context.NoL + 0.001);
        
        // let kS = exp2( (-5.55473 * Context.HoL - 6.98316) * Context.HoL );
        let kS = F ;
        var kd = 1.0 - kS ;
        kd *= 1.0 - metallic ;

        #if USE_SRGB_ALBEDO
            var diffuse = kd ;
        #else 
            var diffuse = kd * (albedo.rgb / PI ) ;
        #endif

        let lightAtt = Context.NoL * lightColor * att ; 
        var diffuseColor = diffuse * lightAtt; 
        // diffuseColor = vec3f(0.0) ; 
        var specularColor = specular * lightAtt; 
        var col = (diffuseColor + specularColor ) ;
        return vec3f(col) ;
    }

    fn getSpecularDominantDir (  N : vec3<f32> , R : vec3<f32> , roughness : f32 ) -> vec3<f32>
    {
        var smoothness = saturate (1.0 - roughness );
        var lerpFactor = smoothness * ( sqrt ( smoothness ) + roughness );
        // The result is not normalized as we fetch in a cubemap
        return mix (N, R, lerpFactor );
    }

    fn approximateSpecularIBL( specularColor:vec3<f32> , roughness:f32 , R:vec3<f32> , NoV:f32 ) -> vec3<f32> {
       
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD) * f32(MAX_REFLECTION_LOD);
        fragData.EnvColor = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        fragData.EnvColor = globalUniform.skyExposure * (fragData.EnvColor);
        var envBRDF = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2<f32>(NoV, roughness) , 0.0 ) ;
        return (specularColor.rgb * envBRDF.x + envBRDF.y) ;
    }

    fn fresnel_coat(n:vec3<f32>,v:vec3<f32>,ior:f32) -> f32 {
        var f0 = (1.0-ior)/(1.0+ior);
        f0 = f0 * f0  ;
        let fr = pow((f0 + (1.0 - f0)*(1.0 - abs( max(dot(n,v),0.0) ))) , 5.0 ) ;  
        return fr ;
    }

    fn reflectEnvMap(n:vec3<f32> , v:vec3<f32> , roughness:f32) -> vec3<f32> {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(envMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var prefilteredColor: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(envMap, envMapSampler, R , mip ).rgb);
        prefilteredColor = LinearToGammaSpace(prefilteredColor);
        return prefilteredColor ;
    }

    fn Specular_D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        let a2 = roughness * roughness ;
        let f = (NoH * a2 - NoH) * NoH + 1.0;
        return a2 / (PI * f * f) ;
    }

    fn V_Kelemen( LoH : f32 ) -> f32 {
        return 0.25 / (LoH * LoH);
    }

    fn F_Schlick( f0:vec3<f32> ,  f90 : f32 ,  VoH : f32 ) -> vec3<f32> {
        return f0 + (f90 - f0) * pow(1.0 - VoH,5.0);
    }

    fn F_Schlick2(  SpecularColor:vec3<f32>,  VoH :f32 )-> vec3<f32> {
        var Fc = pow5( 1.0 - VoH );
        let rt = clamp(50.0 * SpecularColor.g,0.0,1.0) ;
        return rt * Fc + (1.0 - Fc) * SpecularColor;
    }

    fn oneMinusReflectivity ( metallic : f32 , F0:f32 ) -> f32 {
        let range = 1.0 - F0;
        return range - metallic * range;
    }

    //https://google.github.io/filament/Filament.html materialsystem/clearcoatmodel/clearcoatparameterization
    fn CoatSpecular_brdf( f:vec3<f32>, s:vec3<f32>, n:vec3<f32> , v:vec3<f32> , l:vec3<f32> , att:f32 , layer :vec3<f32> , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let H = normalize(v + l); 
        let VdotNc = max(dot(v,n),0.0);
        let LdotNc = max(dot(l,n),0.0);
        let NoH = max(dot(n,H),0.0);
        let LoH = saturate(dot(l, H))  ;
        let NoL = max(dot(n,l),0.0);

        let Fd = f ; 
        let Fr = s ; 

        let factor = clamp(clearcoatRoughnessFactor,0.089,1.0);
        let clearCoatRoughness = factor * factor ;

        let Dc = D_GGX( NoH , factor ) ;
        let Vc = V_Kelemen( LoH ) * NoL ;
        let Fc = F_Schlick(vec3<f32>(0.04), 2.0 , LoH); 
        let Frc = (Dc * Vc) * Fc ;
        // return layer * vec3<f32>((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc) * ( 0.5 + NoL * 0.5 ) ;
        return vec3<f32>(Frc) ;
    }

    #if USE_CLEARCOAT
    fn approximate_coating(base:vec3<f32> , clearColor: vec3<f32>, n:vec3<f32> , v:vec3<f32> , light:LightData , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let factor = clamp(clearcoatRoughnessFactor,0.084,1.0);
        var clearcoatAlpha = factor * factor + fragData.ClearcoatRoughness;

        // var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
        var att = light.intensity ;
        let l = light.direction ;
   
        let NdotV = max(dot(n,v),0.0);
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // let mip = roughnessToMipmapLevel(clearcoatAlpha,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var envIBL: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, R , MAX_REFLECTION_LOD * clearcoatRoughnessFactor ).rgb) ;
        // envIBL = LinearToGammaSpace(envIBL);

        let clearCoat = materialUniform.clearcoatFactor ;
        // let f = FresnelSchlickRoughness( max(dot(n,v),0.0) , vec3<f32>(0.0) , clearcoatAlpha ) ;
        let clearcoat_brdf =  CoatSpecular_brdf( vec3<f32>(0.04) , vec3<f32>( 0.04 ) , n , v , -l , att , vec3<f32>( 0.04 ) , factor ) ;

        // return clearcoat_brdf;+ fragData.ClearcoatRoughness 
        return mix(base, clearcoat_brdf,materialUniform.clearcoatWeight ) ;
    }
    #endif
   

    fn EnvBRDF( SpecularColor : vec3f , Roughness : f32 , NoV : f32) -> vec3f
    {
        // brdflutMap, brdflutMapSampler
        var AB = textureSampleLevel( brdflutMap, brdflutMapSampler, vec2f( NoV, Roughness ), 0.0 ).rg;
        var GF = SpecularColor * AB.x + saturate( 50.0 * SpecularColor.g ) * AB.y;
        return GF;
    }

    fn EnvBRDF_FD90( F0: vec3f , F90: vec3f ,  Roughness: f32,  NoV: f32)-> vec3f
    {
        // Importance sampled preintegrated G * F
        var AB = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2f(NoV, Roughness), 0.0).rg;
        var GF = F0 * AB.x + F90 * AB.y;
        return GF;
    }

    fn IBLEnv( V:vec3f , N:vec3f , Roughness : f32) -> vec3f 
    {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap));
        let mip = roughnessToMipmapLevel(Roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( V , N ) * N - V ;
        var envIBL: vec3<f32> = textureSampleLevel(prefilterMap, prefilterMapSampler, R , mip ).rgb ;
        return envIBL;
    }

    fn IBLEnv2( R:vec3f , Roughness : f32) -> vec3f 
    {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(reflectionMap));
        let mip = roughnessToMipmapLevel(Roughness,MAX_REFLECTION_LOD);
        var envIBL: vec3<f32> ;
        // envIBL = textureSampleLevel(envMap, envMapSampler, R , mip * 12.0 ).rgb ;
        envIBL = getReflectionsEnv(R,ORI_VertexVarying.vWorldPos.xyz, mip).rgb ;
        envIBL = gammaToLiner(envIBL);
        return envIBL;
    }


    fn F_indirect_Function( NdotV:f32, roughness:f32, F0:vec3f) -> vec3f
    {
        var fresnel = exp2((-5.55473 * NdotV - 6.98316) * NdotV);
        return F0 + fresnel * saturate(1.0 - roughness - F0);
    }


     fn indirectionDiffuse_Function( NdotV:f32, normalDir:vec3f, metallic:f32, baseColor:vec3f, roughness:f32, occlusion:f32, F0:vec3f)-> vec3f 
     {
        //  var SHColor = SH9(normalDir,globalUniform.SH).rgb * globalUniform.skyExposure ;
         var SHColor = fragData.Irradiance.rgb ;
         
         var KS = F_indirect_Function(NdotV,roughness,F0);
         var KD = (1.0 - KS) * (1.0 - metallic); 
         return SHColor * KD * baseColor * occlusion;
        //  return SHColor ;
     }
 
     fn indirectionSpec_Function( reflectDir:vec3f, roughness:f32, NdotV:f32,occlusion:f32, F0:vec3f )-> vec3f 
     {
         var mipRoughness = roughness * (1.7 - 0.7 * roughness) ;
         var env : vec3f ;
         #if USE_CASTREFLECTION
            env = textureSampleLevel(envMap, envMapSampler, reflectDir , mipRoughness * 12.0 ).rgb ;
         #else
            useSphereReflection();
            env = getReflectionsEnv(reflectDir,ORI_VertexVarying.vWorldPos.xyz, mipRoughness).rgb ;
        #endif

        //  env *= 0.45 ;
         var indirectionCube: vec3<f32> = globalUniform.skyExposure * env ;
         var F_IndirectionLight = F_indirect_Function(NdotV,roughness,F0);

         var AB = LUT_Approx(roughness,NdotV);
        //  var AB = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2f(NdotV, roughness), 0.0).rg;
         var indirectionSpecFactor = indirectionCube.rgb * (F_IndirectionLight * AB.r + AB.g) ;
         return indirectionSpecFactor * occlusion;
     }

     const  c0 = vec4f(-1, -0.0275, -0.572, 0.022 );
     const  c1 = vec4f(1, 0.0425, 1.04, -0.04 );
     fn LUT_Approx( roughness:f32,  NoV:f32 )->vec2f
     {
         // [ Lazarov 2013, "Getting More Physical in Call of Duty: Black Ops II" ]
         // Adaptation to fit our G term.
         var r = roughness * c0 + c1;
         var a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
         var AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;
         return saturate(AB);
     }

`,Yo=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "BitUtil"
  #include "Common_frag"
  #include "GlobalUniform"
  #include "SHCommon_frag"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"
  #include "ReflectionCG"
 
  //ORI_ShadingInput
  fn initFragData() {
      // fragData.Albedo = vec4f(gammaToLiner(ORI_ShadingInput.BaseColor.rgb),ORI_ShadingInput.BaseColor.w) ;
      fragData.Albedo = vec4f((ORI_ShadingInput.BaseColor.rgb),ORI_ShadingInput.BaseColor.w) ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.0001,1.0) * 1.85 ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = gammaToLiner(ORI_ShadingInput.EmissiveColor.rgb) * materialUniform.emissiveIntensity ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;

      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(0.04), fragData.Albedo.rgb , fragData.Metallic);
      // fragData.F0 = gammaToLiner(fragData.F0);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      fragData.ClearcoatIor = materialUniform.clearcoatIor ;
      fragData.ClearcoatFactor = materialUniform.clearcoatFactor;
        
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness *= getClearcoatRoughness() ;
        fragData.ClearcoatFactor *= getClearcoatWeight() ;
      #endif
  }

  fn BxDFShading(){
      initFragData();

      let sunLight = lightBuffer[0] ;

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          #if USE_CASTREFLECTION
              irradiance += globalUniform.hdrExposure * (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
          #else
              useSphereReflection();
              irradiance = getReflectionsEnv(fragData.N,ORI_VertexVarying.vWorldPos.xyz,1.0) ;
          #endif
       #endif
      fragData.Irradiance = irradiance.rgb ;

      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.Albedo.rgb , fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      //***********lighting-PBR part********* 
      
      //***********indirect-specular part********* 
      var surReduction = 1.0/(fragData.Roughness * fragData.Roughness + 1.0);
      var grazingTerm = saturate(1.0 - fragData.Roughness + kD);
      var surfaceReduction = 1.0 / (pow(fragData.Roughness,2.0) + 1.0);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;  
      var iblSpecularResult = fresnelLerp * surReduction ;
      //***********indirect-specular part********* 

      //***********lighting-PBR part********* 
      var diffuseColor = mix(fragData.Albedo.rgb,vec3f(0.04),fragData.Metallic);
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting(ORI_VertexVarying.vWorldPos.xyz, light ,iblSpecularResult) ;
              break;
            }
            case DirectLightType: {
              specColor += directLighting(light,iblSpecularResult);
              // specColor = iblSpecularResult;
              break;
            }
            case SpotLightType: {
              specColor += spotLighting( ORI_VertexVarying.vWorldPos.xyz, light ,iblSpecularResult) ;
              break;
            }
            default: {
              break;
            }
          }
      }

      //***********indirect-ambient part********* 
      // var kdLast = (1.0 - 0.04) * (1.0 - fragData.Metallic);    
      var iblDiffuseResult : vec3f ;

      let MAX_LOD  = i32(textureNumLevels(prefilterMap)) ;
      let mip = roughnessToMipmapLevel(fragData.Roughness,MAX_LOD) * f32(MAX_LOD) * 0.5;
    
      var indirectionDiffuse = indirectionDiffuse_Function(fragData.NoV,fragData.N,fragData.Metallic,fragData.Albedo.rgb,fragData.Roughness,fragData.Ao,fragData.F0);
      iblDiffuseResult += indirectionDiffuse / 3.14;

      var indirectionSpec    = indirectionSpec_Function(fragData.R,fragData.Roughness,fragData.NoV,fragData.Ao,gammaToLiner(fragData.F0));
      #if USE_CASTREFLECTION
        indirectionSpec *= globalUniform.hdrExposure ;
      #endif

      var color = vec3f(iblDiffuseResult + indirectionSpec + specColor)  ;
      // var color = vec3f(indirectionDiffuse )  ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
           
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
            let light = getLight(i32(i));
            switch (light.lightType) {
              case PointLightType: {
                var lightColor = light.lightColor.rgb  ;
                var att = pointAtt(ORI_VertexVarying.vWorldPos.xyz, light);
                clearCoatColor += ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , fragData.ClearcoatIor , clearNormal ,  light.direction , fragData.V , clearcoatRoughness , lightColor,  att );
                break;
              }
              case DirectLightType: {
                var lightColor = getHDRColor( light.lightColor.rgb , light.linear )  ;
                var att = max(0.0,light.intensity);
                clearCoatColor += ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , fragData.ClearcoatIor , clearNormal ,  light.direction , fragData.V , clearcoatRoughness , lightColor,  att );
                break;
              }
              case SpotLightType: {
                // var lightColor = light.lightColor.rgb  ;
                // var att = pointAtt(ORI_VertexVarying.vWorldPos.xyz, light);
                // clearCoatColor += ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , 1.5 , clearNormal ,  light.direction , fragData.V , clearcoatRoughness , lightColor,  att );
                break;
              }
              default: {
                break;
              }
            }
        }
       
        color = clearCoatColor ;
      #endif
      
        var retColor = (LinearToGammaSpace(color.rgb));
        retColor += fragData.Emissive.xyz ;

        var viewColor = vec4<f32>( retColor.rgb * fragData.Albedo.w, fragData.Albedo.a) ;

        let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
        let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
        let ORI_NORMALMATRIX = transpose(inverse( nMat ));

        var vNormal = ORI_VertexVarying.vWorldNormal.rgb ;

        let gBuffer = packNHMDGBuffer(
          ORI_VertexVarying.fragCoord.z,
          fragData.Albedo.rgb,
          viewColor.rgb,
          vec3f(fragData.Roughness,fragData.Metallic,fragData.Ao),
          vNormal,
          fragData.Albedo.a
        ) ;

        #if USE_CASTREFLECTION
          ORI_FragmentOutput.gBuffer = gBuffer ;
        #else
          ORI_FragmentOutput.gBuffer = gBuffer ;
          ORI_FragmentOutput.color = viewColor ;
        #endif
  }

  `,Ho=`
    #if USE_CLEARCOAT_ROUGHNESS
    @group(1) @binding(auto)
    var clearCoatRoughnessMapSampler: sampler;
    @group(1) @binding(auto)
    var clearCoatRoughnessMap: texture_2d<f32>;

    fn getClearcoatRoughness() -> f32{
        let clearcoatRoughness = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).g;
        return clearcoatRoughness;
    }

    fn getClearcoatWeight() -> f32{
        let clearcoatWeight = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).r;
        return clearcoatWeight;
    }
    #else
    fn getClearcoatRoughness() -> f32{
        return 1.0;
    }
    fn getClearcoatWeight() -> f32{
        return 1.0;
    }
    #endif

    #if USE_CLEARCOAT
    fn ClearCoat_BRDF( baseColor:vec3<f32>, clearCoatColor:vec3<f32> , clearCoatIor:f32 ,N:vec3<f32>, L:vec3<f32> ,  V:vec3<f32> , clearCoatPerceptualRoughness:f32 ,lightColor:vec3f, att:f32) -> vec3<f32> {
        var factor = clamp(clearCoatPerceptualRoughness, 0.0001, 1.0);
        var clearCoatRoughness = factor ;
        let lightDir = -L ;
        let H = normalize( V + lightDir);
        // let LoH = dot(lightDir,H);
        let NoV = max(dot(N,V),0.00001);
        // let NoL = max(dot(N,lightDir),0.00001);
        // let NoH = max(dot(N,H),0.00001);

        // let clearSpeclur = IBLEnv2(fragData.R,clearCoatRoughness);
        // let F0 = IORToF0(clearCoatIor);
        // let Fr = FresnelSchlickRoughness( NoV , vec3<f32>(clearCoatColor) , clearCoatRoughness ) ;
        // var Fd = clearCoatColor ;
        // clear coat BRDF
        // var Dc = D_GGX(NoH,clearCoatRoughness);
        // var Vc = V_Kelemen(LoH) * NoL;
        // var Fc = F_Schlick2( vec3<f32>(F0) , NoV) ;
        // var Frc = (Dc * Vc) * Fc;
        // base layer attenuation for energy compensation
        // let oneMinusFc  = 1.0 - Fc;

        // let brdfSpecular = clearSpeclur * ((Fd + Fr * oneMinusFc) * oneMinusFc + Frc)  * att * lightColor; 
        var iblSpecular = vec3<f32>(0.0);
        // return brdfSpecular ;

        iblSpecular = indirectionSpec_Function(fragData.R,clearCoatRoughness,NoV,1.0,(clearCoatColor * att * vec3f(IORToF0(clearCoatIor))));
        // iblSpecular = IBLEnv2(fragData.R,clearCoatRoughness);
        // return mix(baseColor , brdfSpecular + iblSpecular ,fragData.ClearcoatFactor) ;
        // return vec3f(baseColor + (clearCoatColor * iblSpecular) * fragData.ClearcoatFactor) ;
        return mix(baseColor , (clearCoatColor * iblSpecular) , fragData.ClearcoatFactor) ;
        // return iblSpecular ;
    }
    #endif
`,Ko=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = materialUniform.roughness  ;
        ORI_ShadingInput.Metallic = materialUniform.metallic ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

        BxDFShading();
    }
`,jo=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
   
        let baseMapOffsetSize = materialUniform.baseMapOffsetSize;
        var uv = transformUV(ORI_VertexVarying.fragUV0,baseMapOffsetSize) ; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            // ORI_ShadingInput.BaseColor = sRGBToLinear(ORI_ShadingInput.BaseColor.rgb)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>( ORI_ShadingInput.BaseColor * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(gammaToLiner(ORI_ShadingInput.BaseColor.rgb),ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor *= vec4f(materialUniform.baseColor.rgba)  ;
        #endif

        let roughnessMapOffsetSize = materialUniform.roughnessMapOffsetSize;
        var uv4 = transformUV(ORI_VertexVarying.fragUV0,roughnessMapOffsetSize); 
        var maskTex = textureSample(maskMap, maskMapSampler, uv4 );
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif

                discard;
            }
        #endif

        useShadow();

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    

        ORI_ShadingInput.Metallic = metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            let aoMapOffsetSize = materialUniform.aoMapOffsetSize;
            var aoMapOffsetSizeUV = transformUV(ORI_VertexVarying.fragUV0,aoMapOffsetSize); 
            var aoMap = textureSample(aoMap, aoMapSampler, ORI_VertexVarying.fragUV0 );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;
        ORI_ShadingInput.Specular = 1.0 ;

        let emissiveMapOffsetSize = materialUniform.emissiveMapOffsetSize;
        var emissiveUV = transformUV(ORI_VertexVarying.fragUV0,emissiveMapOffsetSize) ;
        #if USE_EMISSIVEMAP
            var emissiveMapColor = textureSample(emissiveMap, emissiveMapSampler , emissiveUV ) ;
            let emissiveColor = materialUniform.emissiveColor.rgb * emissiveMapColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor.rgb,1.0);
        #else
            let emissiveColor = materialUniform.emissiveColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor,1.0);
        #endif

        let normalMapOffsetSize = materialUniform.normalMapOffsetSize;
        var nomralUV = transformUV(ORI_VertexVarying.fragUV0,normalMapOffsetSize) ;
        var Normal = textureSample(normalMap,normalMapSampler,nomralUV).rgb ;
        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        ORI_ShadingInput.Normal = normal ;
     
        BxDFShading();

        // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(normal.rgb),1.0) ;
    }
`,qo=`
#include "ClusterDebug_frag" 

        fn debugPosition(){
            //ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,1.0);
        }

        fn debugMeshID(){
            let meshIDColor = u32(round(ORI_VertexVarying.vWorldPos.w) ) ;
            let color = colorSet[ meshIDColor % 9u] ;
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(color.rgb),1.0);
        }

        fn debugNormal(){
            // ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.Normal.xyz,1.0);
        }

        fn debugUV(){
            // ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.fragUV0.xy,0.0,1.0);
        }

        fn debugColor(){
            // ORI_FragmentOutput.color = vec4<f32>(fragData.Albedo.rgb,1.0);
        }

        fn debugDiffuse(){
            // ORI_FragmentOutput.color = vec4<f32>( fragData.LightChannel.rgb,1.0);
        }

        fn debugAmbient(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3f(fragData.Alpha) ,1.0);
        }
        
        fn debugEmissive(){
            // ORI_FragmentOutput.color = vec4<f32>(fragData.Emissive.rgb,1.0);
        }

        fn debugEnvment(){
            // ORI_FragmentOutput.color = vec4<f32>(fragData.EnvColor.rgb,1.0);
        }

        fn debugAo(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Ao),1.0);
        }

        fn debugRoughness(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Roughness),1.0);
        }

        fn debugMetallic(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Metallic),1.0);
        }

        fn debugIrradiance(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Irradiance),1.0);
        }

        fn debugTangent(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.T),1.0);
        }

        fn debugFragmentOut(){
            if(ORI_VertexVarying.fragCoord.x > globalUniform.renderState_split) {
                switch (globalUniform.renderState_right)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              } else {
                switch (globalUniform.renderState_left)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              }
        }
`,$o=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct MaterialUniform {
    x:f32,
    y:f32,
    width:f32,
    height:f32,
    };

    struct VertexOutput {
        @location(auto) fragUV: vec2<f32>,
        @builtin(position) position: vec4<f32>
    };

    @vertex
    fn main(@builtin(vertex_index) vertexIndex : u32, @builtin(instance_index) index : u32 ) -> VertexOutput {
        const pos = array(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
        vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0),
        );
        const uv = array(
        vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), 
        vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(0.0, 0.0),
        );
        let id = u32(index) ;
        var output : VertexOutput;
        output.fragUV = uv[vertexIndex] ;
        output.position = vec4<f32>(pos[vertexIndex] , 0.0, 1.0) ;
        return output ;
    }
`,el=`
#include "WorldMatrixUniform"
      #include "GlobalUniform"
   
      struct MaterialUniform {
        x:f32,
        y:f32,
        width:f32,
        height:f32,
      };

      struct VertexOutput {
          @location(auto) fragUV: vec2<f32>,
          @builtin(position) member: vec4<f32>
      };

      @vertex
      fn main(@builtin(instance_index) index : u32,@location(auto) position: vec3<f32>, @location(auto) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        //   let id = u32(index) ;
        //   let worldMatrix = models.matrix[id];
        //   let windowSize = vec2<f32>(globalUniform.windowWidth,globalUniform.windowHeight) ;
        //   let pos = worldMatrix[3].xy ;
        //   let size = vec2<f32>(worldMatrix[0].x,worldMatrix[1].y) / windowSize ;
          let uv = vec2(((TEXCOORD_1.xy * 2.0) - vec2<f32>(1.0))) ;// / windowSize * size - offset ;
          return VertexOutput(TEXCOORD_1, vec4<f32>(uv, 0.0, 1.0));
      }
`,tl=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv );

        return FragmentOutput(color);
    }
`,rl=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    }; 

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_2d ;

    fn Linear01Depth(  z : f32 ) -> f32
    {
        return 1.0 / (1.0 * z + 5000.0);
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var depth = textureSample(baseMap, baseMapSampler, uv , vec2<i32>(0) ) ;
        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,al=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_cube ;

    fn uvToXYZ( face : i32 ,  uv : vec2<f32> ) -> vec3<f32>
    {
        var out : vec3<f32> ;
        if(face == 0){
            out = vec3<f32>( 1.0, uv.y, -uv.x);
        }else if(face == 1){
            out = vec3<f32>( -1.0, uv.y, uv.x);
        }else if(face == 2){
            out = vec3<f32>( uv.x, -1.0, uv.y);
        }else if(face == 3){
            out = vec3<f32>( uv.x,  1.0, -uv.y);
        }else if(face == 4){
            out = vec3<f32>( uv.x, uv.y, 1.0);
        }else{	
            out = vec3<f32>( -uv.x, uv.y, -1.0);
        }
        return out ;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var ii = 0.16 ;
        var ouv = vec3<f32>(0.0);
        if(uv.x < ii * 6.0){
            ouv = uvToXYZ(5,uv/ii);
        }
        if(uv.x < ii * 5.0){
            ouv = uvToXYZ(4,uv/ii);
        }
        if(uv.x < ii * 4.0){
            ouv = uvToXYZ(3,uv/ii);
        } 
        if(uv.x < ii * 3.0){
            ouv = uvToXYZ(2,uv/ii);
        }
        if(uv.x < ii * 2.0){
            ouv = uvToXYZ(1,uv/ii);
        }
        if(uv.x < ii * 1.0){
            ouv = uvToXYZ(0,uv/ii);
        }
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,il=`
    fn getHDRColor(color: vec3<f32>, exposure: f32) -> vec3 < f32 > {
        return color * pow(2.4, exposure) ;
    }

    // RGBM encode/decode
    const kRGBMRange = 8.0;

    fn EncodeRGBM( icolor : vec3f ) ->vec4f
    {
        var color = icolor ;
        color *= 1.0 / kRGBMRange;
        var m = max(max(color.x, color.y), max(color.z, 1e-5));
        m = ceil(m * 255) / 255;
        return vec4f(color / m, m);
    }

    fn DecodeRGBM( rgbm : vec4f ) -> vec3f
    {
        return rgbm.xyz * rgbm.w * kRGBMRange;
    }

    fn Luminance(  LinearColor : vec3f, LuminanceFactors: vec3f ) -> f32
    {
        return dot( LinearColor, LuminanceFactors );
    }

    fn lambda2rgb(lambda : f32) -> vec3 < f32 > {
        let ultraviolet = 400.0;
        let infrared = 700.0;

        var a = (lambda - ultraviolet) / (infrared - ultraviolet);
        let c = 10.0;
        var b = vec3<f32>(a) - vec3<f32>(0.75, 0.5, 0.25);
        return max((1.0 - c * b * b), vec3<f32>(0.0));
    }

    fn CEToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        return 1.0 - exp(-adapted_lum * color);
    }


    fn acesFilm( x:vec3f) -> vec3f {
        return clamp((x*(2.51*x+vec3f(0.03)))/(x*(2.43*x+vec3f(0.59))+vec3f(0.14)),vec3f(0.0),vec3f(1.0));
    }

    fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        let A = 2.51;
        let B = 0.03;
        let C = 2.43;
        let D = 0.59;
        let E = 0.14;

        var color2 = color * adapted_lum;
        color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
        return color2;
    }

    fn gammaToLiner(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 2.4;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma4(color: vec4<f32>) -> vec4 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec4<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma3(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    // fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3 < f32 > {
    //     var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
    //     linRGB.r = pow(linRGB.r, 0.416666667);
    //     linRGB.g = pow(linRGB.g, 0.416666667);
    //     linRGB.b = pow(linRGB.b, 0.416666667);
    //     return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    // }

    fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
        var linRGB1 = max(linRGB, vec3<f32>(0.0));
        linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
        return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
    }

    var<private>sRGB_2_LMS_MAT: mat3x3<f32> = mat3x3<f32>(
        17.8824, 43.5161, 4.1193,
        3.4557, 27.1554, 3.8671,
        0.02996, 0.18431, 1.4670,
    );

    var<private>LMS_2_sRGB_MAT: mat3x3<f32> = mat3x3<f32>(
        0.0809, -0.1305, 0.1167,
        -0.0102, 0.0540, -0.1136,
        -0.0003, -0.0041, 0.6935,
    );

    fn sRGB_2_LMS(RGB: vec3<f32>) -> vec3<f32>
    {
        return sRGB_2_LMS_MAT * RGB;
    }

    fn LMS_2_sRGB(LMS: vec3<f32>) -> vec3<f32>
    {
        return LMS_2_sRGB_MAT * LMS;
    }

    fn LinearToSrgbBranchless(lin: vec3<f32>) -> vec3<f32>
    {
        var lin2 = max(vec3<f32>(6.10352e-5), lin);
        return min(lin2 * 12.92, pow(max(lin2, vec3<f32>(0.00313067)), vec3<f32>(0.416666667)) * vec3<f32>(1.055) - vec3<f32>(0.055));
    }

    fn sRGBToLinear(color : vec3<f32>) -> vec3<f32>
    {
        let color2 = max(vec3<f32>(6.10352e-5), color);
        let c = 0.04045;
        if (color2.r > c && color2.g > c && color2.b > c) {
            return pow(color2 * (1.0 / 1.055) + 0.0521327, vec3<f32>(2.4));
        } else {
            return color2 * (1.0 / 12.92);
        }
    }

    fn BlendNormalRNM( n1:vec3f,  n2:vec3f) -> vec3f
	{
		let t = n1.xyz + vec3f(0.0, 0.0, 1.0);
		let u = n2.xyz * vec3f(-1.0, -1.0, 1.0);
		let r = (t / t.z) * dot(t, u) - u;
		return r;
	}

//     fn ReorientedBlendNormal(){
//         vec3 t = texture(baseMap,   uv).xyz * vec3( 2.0,  2.0, 2.0) + vec3(-1.0, -1.0,  0.0);
// vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,  1.0, -1.0);
// vec3 r = normalize(t * dot(t, u) - u * t.z);
// return r;
//     }

//     fn UDNBlendNormal(){
    // vec3 t = texture(baseMap,   uv).xyz * 2.0 - 1.0;
    // vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
    // vec3 r = normalize(t.xy + u.xy, t.z);
    // return r;
//     }


fn packRGBA8( In : vec4f ) ->u32
{
	let r = (u32(saturate(In.r) * 255.0) << 0u);
	let g = (u32(saturate(In.g) * 255.0) << 8u);
	let b = (u32(saturate(In.b) * 255.0) << 16u);
	let a = (u32(saturate(In.a) * 255.0) << 24u);
	return r | g | b | a;
}

const i256:f32 = 1.0 / 255.0 ;
fn unpackRGBA8( In : u32 ) -> vec4f 
{
	var Out:vec4f ;
	Out.r = f32((In >> 0u) & 0xFF) * i256;
	Out.g = f32((In >> 8u) & 0xFF) * i256;
	Out.b = f32((In >> 16u) & 0xFF) * i256;
	Out.a = f32((In >> 24u) & 0xFF) * i256;
	return Out;
}
`,sl=`
    fn madfrac(A:f32, B:f32)-> f32 {
        return A*B-floor(A*B) ;
    }

    fn sampleRandomDir(count:u32,SAMPLE_COUNT:u32) -> vec3<f32>{
    var ray_dir = sphericalFibonacci(f32((count)), f32(SAMPLE_COUNT) );
    return normalize(ray_dir) ;
    }

    fn sphericalFibonacci( i : f32 ,  n : f32 ) -> vec3<f32>{
        const PHI = sqrt(5.0) * 0.5 + 0.5;
        let phi = 2.0 * PI * madfrac(i, PHI - 1);
        let cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
        let sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

        return vec3<f32>(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta);

    }
`,nl=`
    #include "MathShader"

    fn buildMatrix3x3() -> mat3x3<f32>{
        var mat3 = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,1.0,0.0,
            0.0,0.0,1.0,
        );
        return mat3 ;
    }

    fn buildMatrix4x4() -> mat4x4<f32>{
        var mat4 = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        return mat4 ;
    }

    fn buildRotateXMat3(rad:f32) -> mat3x3<f32>{
        var xrot = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),
            0.0,sin(rad),cos(rad)
        );
        return xrot;
    }

    fn buildRotateXMat4(rad:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xrot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),0.0,
            0.0,sin(rad),cos(rad),0.0,
            x,y,z,1.0,
        );
        return xrot;
    }

    fn buildYRotateXMat4(radY:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            x,y,z,1.0,
        );
        return yRot;
    }

    fn buildRotateXYZMat4(radX:f32,radY:f32,radZ:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xRot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(radX),-sin(radX),0.0,
            0.0,sin(radX),cos(radX),0.0,
            0.0,0.0,0.0,1.0,
        );
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            0.0,0.0,0.0,1.0,
        );
        var zRot = mat4x4<f32>(
            cos(radZ),-sin(radZ),0.0,0.0,
            sin(radZ), cos(radZ),0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        var fMat = xRot * yRot * zRot ;
        fMat[3].x = x;
        fMat[3].y = y;
        fMat[3].z = z;
        return fMat;
    }

    fn buildRotateYMat3(rad:f32) -> mat3x3<f32>{
        var yrot = mat3x3<f32>(
            cos(rad),0.0,sin(rad),
            0.0,1.0,0.0,
            -sin(rad),0.0,cos(rad)
        );
        return yrot ;
    }

    fn buildRotateZ(rad:f32) -> mat3x3<f32>{
        var zrot = mat3x3<f32>(
            cos(rad),-sin(rad),0.0,
            sin(rad), cos(rad),0.0,
            0.0,0.0,1.0
        );
        return zrot;
    }

    // fn buildRotateXMat4(rad:f32) -> mat4x4<f32>{
    //     var xrot = mat4x4<f32>(
    //         1.0,0.0,0.0,0.0,
    //         0.0,cos(rad),-sin(rad),0.0,
    //         0.0,sin(rad),cos(rad),0.0,
    //         0.0,0.0,0.0,1.0);
    //     return xrot;
    // }

    fn bulidTranslateMat4(x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var trans = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            x,y,z,1.0);
        return trans;
    }

`,ol=`
    struct LightData {
        index:f32,
        lightType:i32,
        radius:f32,
        linear:f32,
        
        position:vec3<f32>,
        lightMatrixIndex:f32,

        direction:vec3<f32>,
        quadratic:f32,

        lightColor:vec3<f32>,
        intensity:f32,

        innerCutOff :f32,
        outerCutOff:f32,
        range :f32,
        castShadow:i32,

        lightTangent:vec3<f32>,
        ies:f32,
    };

    const PointLightType = 1;
    const DirectLightType = 2;
    const SpotLightType = 3;

    struct ClusterBox {
        minPoint:vec4<f32>,
        maxPoint:vec4<f32>
    };

    struct LightIndex {
            count:f32,
            start:f32,
            empty0:f32,
            empty1:f32,
    };

    struct ClustersUniform {
        clusterTileX:f32,
        clusterTileY:f32,
        clusterTileZ:f32,
        numLights:f32,
        maxNumLightsPerCluster:f32,
        near:f32,
        far:f32,
        screenWidth:f32,
        screenHeight:f32,
        clusterPix:f32, 
    };

    @group(2) @binding(1)
    var<storage,read> lightBuffer: array<LightData>;
    @group(2) @binding(2)
    var<uniform> clustersUniform : ClustersUniform;
    @group(2) @binding(3)
    var<storage,read> lightAssignBuffer : array<f32>;
    @group(2) @binding(4)
    var<storage,read> assignTable : array<LightIndex>;
    #if DEBUG_CLUSTER
        @group(2) @binding(5)
        var<storage,read> clusterBuffer : array<ClusterBox>;
    #endif

    fn getLight( index:i32 ) -> LightData {
        let lightId = i32(lightAssignBuffer[index]);
        var lightData = lightBuffer[lightId];
        return lightData ;
    }

    fn linearTo01Depth(depth : f32) -> f32 {
        return (globalUniform.far ) * globalUniform.near / fma(depth, globalUniform.near-globalUniform.far, globalUniform.far);
    }

    fn getClusterId3() -> vec3<u32> {
        let z = linearTo01Depth(ORI_VertexVarying.fragCoord.z) ; 

        let sliceScale = f32(clustersUniform.clusterTileZ) / log2(globalUniform.far / globalUniform.near);
        let sliceBias = -(f32(clustersUniform.clusterTileZ) * log2(globalUniform.near) / log2(globalUniform.far / globalUniform.near));
        let zTile = u32(max(log2(z) * sliceScale + sliceBias, 0.0));

        var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
        let i = u32(floor(screenUV.x * clustersUniform.clusterTileX)) ;
        let j = u32(floor(screenUV.y * clustersUniform.clusterTileY) );

        return vec3<u32>(i,j,zTile);
    }

    fn getCluster() -> LightIndex {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return assignTable[id];
    }

    fn getClusterIndex() -> u32 {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return id;
    }
`,ll=`
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"

  struct FHairTransmittanceData{
    bUseBacklit:bool,
    bUseSeparableR:bool,
    bUseLegacyAbsorption:bool
  };
 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = ORI_ShadingInput.Roughness ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.Specular = vec3f(materialUniform.specularColor.rgb) ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz ) ;
      fragData.V = viewDir ;
      fragData.Ao = materialUniform.ao ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;
  }

  

  fn transformHairNormal(normal : vec3<f32>) -> vec3<f32>{
      var face = 1.0 ;
      if(ORI_VertexVarying.face){
          face = 1.0 ;
      }else{
          face = -1.0 ;
      }
      #if USE_TANGENT
        let T = ORI_VertexVarying.TANGENT.xyz;
        let N = ORI_VertexVarying.vWorldNormal ;
        let B = cross(T,N) * ORI_VertexVarying.TANGENT.w * face;
        let mat3 = mat3x3<f32>(T,B,N);
        let n = mat3 * normal;
        return n ;
      #else
        return normal ;
      #endif
  }


  fn Hair_g( B:f32 ,  Theta:f32 ) -> f32
  {
      return exp(-0.5 * pow2(Theta) / (B * B)) / (sqrt(2 * PI) * B);
  }

  fn Hair_F( CosTheta:f32 )-> f32
  {
      let n = 1.55;
      let F0 = pow2((1.0 - n) / (1.0 + n));
      return F0 + (1.0 - F0) * pow5(1.0 - CosTheta);
  }

  fn HairColorToAbsorption( C:vec3f ,  B:f32 ) -> vec3f
  {
      let b2 = B * B;
      let b3 = B * b2;
      let b4 = b2 * b2;
      let b5 = B * b4;
      let D = (5.969 - 0.215 * B + 2.532 * b2 - 10.73 * b3 + 5.574 * b4 + 0.245 * b5);
      return pow2v3(log(C) / D);
  }

  fn Luminance(  LinearColor : vec3f ) -> f32
  {
    return dot( LinearColor, vec3f( 0.3, 0.59, 0.11 ) );
  }

  fn KajiyaKayDiffuseAttenuation( L:vec3f,  V:vec3f,  N:vec3f,  Shadow:f32 ) -> vec3f
  {
    // Use soft Kajiya Kay diffuse attenuation
    var KajiyaDiffuse = 1.0 - abs(dot(N, L));

    var FakeNormal = normalize(V - N * dot(V, N));
    //N = normalize( DiffuseN + FakeNormal * 2 );
    let nN = FakeNormal;

    let BaseColor = fragData.Albedo.rgb / PI ;
    // Hack approximation for multiple scattering.
    var Wrap = 1.0;
    var NoL = saturate((dot(nN, L) + Wrap) / squareF(1.0 + Wrap));
    var DiffuseScatter = (1.0 / PI) * mix(NoL, KajiyaDiffuse, 0.33) * fragData.Metallic;
    var Luma = Luminance(BaseColor);
    var ScatterTint = pow(BaseColor / Luma, vec3f(1.0 - Shadow));
    return sqrt(BaseColor) * DiffuseScatter * ScatterTint;
  }

  fn HairNormal( ID : f32 ) -> vec4f {
      let tangentA = vec4f(0.0,0.0,0.3,1.0);
      let tangentB = vec4f(0.0,0.0,-0.3,1.0);

      let iTangent = mix(tangentA,tangentB,vec4f(ID));
      var tangent = vec4f(0.0);
      #if USE_FLOWER

      #else 
        let tt = vec4f(0.0,-1.0,0.0,1.0);
        tangent = tt + iTangent;
      #endif

      return normalize(tangent) ;
  }

  fn hairShading( light:LightData , sV:vec3f, N:vec3f, Shadow:f32 , HairTransmittance : FHairTransmittanceData ,  InBacklit:f32 ,  Area:f32 ,  Random:vec2f ) -> vec3f{
      var ClampedRoughness = clamp(fragData.Roughness, 1/255.0, 1.0);
      let Backlit	= min(InBacklit, materialUniform.backlit);
      let HairColor = fragData.Albedo.rgb ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var lightAtt = light.intensity  ;

      let V = normalize(sV) ;
      let L = normalize(-light.direction) ;
      let H = normalize(N+L) ;
      var S : vec3f= vec3f(0.0) ;

      var KajiyaKayDiffuseFactor = 1.0;

      let VoL       = dot(V,L);                                                      
      let SinThetaL = clamp(dot(N,L), -1.0, 1.0);
      let SinThetaV = clamp(dot(N,V), -1.0, 1.0);

      var CosThetaD = cos( 0.5 * abs( asinFast( SinThetaV ) - asinFast( SinThetaL ) ) );
      // var CosThetaD = cos( 0.5 * abs( asin( SinThetaV ) - asin( SinThetaL ) ) );
      
      var Lp = L - SinThetaL * N;
      var Vp = V - SinThetaV * N;
      var CosPhi = dot(Lp,Vp) * rsqrt( dot(Lp,Lp) * dot(Vp,Vp) + 1e-4 );
      var CosHalfPhi = sqrt( saturate( 0.5 + 0.5 * CosPhi ) );

      let n = 1.55;
      let n_prime = 1.19 / CosThetaD + 0.36 * CosThetaD;

      let Shift = 0.035;
      var Alpha:array<f32,3> = array<f32,3>(
        -Shift * 2.0,
        Shift,
        Shift * 4.0,
      );

      var B:array<f32,3> =array<f32,3>(
        Area + pow2(ClampedRoughness),
        (Area + pow2(ClampedRoughness) / 2.0),
        Area + pow2(ClampedRoughness) * 2.0,
      );
     
      //S SR
      let sa = sin(Alpha[0]);
      let ca = cos(Alpha[0]);
      var ShiftA = 2.0 * sa * (ca * CosHalfPhi * sqrt(1.0 - SinThetaV * SinThetaV) + sa * SinThetaV);
      var BScale = 1.0;
      if(HairTransmittance.bUseSeparableR){
          BScale = sqrt(2.0) * CosHalfPhi ;
      }
      var Mp_R = Hair_g(B[0] * BScale, SinThetaL + SinThetaV - ShiftA);
      var Np_R = 0.25 * CosHalfPhi;
      var Fp_R = Hair_F(sqrt(saturate(0.5 + 0.5 * (VoL))));
      S += vec3f(Mp_R* Np_R * Fp_R * (fragData.F0 * 2.0)) * mix(1.0, 0.0, saturate(-VoL));
      KajiyaKayDiffuseFactor -= Fp_R;

      //S ST
      var Mp_ST = Hair_g( B[1], SinThetaL + SinThetaV - Alpha[1] );
      var a_ST = 1.0 / n_prime;
      var h_ST = CosHalfPhi * ( 1.0 + a_ST * ( 0.6 - 0.8 * CosPhi ) );
      var f_ST = Hair_F( CosThetaD * sqrt( saturate( 1.0 - h_ST * h_ST ) ) );
      var Fp_ST = pow2(1.0 - f_ST);
      var Tp_ST : vec3f = vec3f( 0.0 );
      if (HairTransmittance.bUseLegacyAbsorption)
      {
        Tp_ST = pow(HairColor.rgb, vec3f(0.5 * sqrt(1.0 - pow2(h_ST * a_ST)) / CosThetaD));
      }
      else
      {
        let AbsorptionColor = HairColorToAbsorption(HairColor.rgb,0.3);
        Tp_ST = exp(-AbsorptionColor * 2.0 * abs(1.0 - pow2(h_ST * a_ST) / CosThetaD));
      }
     
      var Np_ST = exp( -3.65 * CosPhi - 3.98 );
      
      S += Mp_ST * Np_ST * Fp_ST * Tp_ST * Backlit;
      KajiyaKayDiffuseFactor -= Fp_ST;

      //S TRT
      var Mp_TRT = Hair_g( B[2], SinThetaL + SinThetaV - Alpha[2] );
      
      //float h = 0.75;
      var f_TRT = Hair_F( CosThetaD * 0.5 );
      var Fp_TRT = pow2(1.0 - f_TRT) * f_TRT;
      var Tp_TRT = pow( HairColor.rgb , vec3f(0.8 / CosThetaD) );
      var Np_TRT = exp( 17.0 * CosPhi - 16.78 );
      
      S += Mp_TRT * Np_TRT * Fp_TRT * Tp_TRT;
      KajiyaKayDiffuseFactor -= Fp_TRT;
      // S = vec3f((KajiyaKayDiffuseFactor));
     
      S += KajiyaKayDiffuseAttenuation(L,V,N,Shadow) ;//* saturate(KajiyaKayDiffuseFactor);
      // S = vec3f((KajiyaKayDiffuseFactor));
      S = -min(-S, vec3f(0.0));
      return 2.0 * PI *vec3f(S) * (lightAtt ) ;
  }

  fn BSSSRDFShading(){
    initFragData();

    var irradiance = vec3<f32>(0.0) ;
    #if USEGI
        irradiance += getIrradiance().rgb ;
    #else
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
    #endif
    irradiance = ORI_ShadingInput.SSS + (irradiance.rgb);
    fragData.Irradiance = irradiance.rgb ;

    //***********lighting-PBR part********* 
    var specColor = vec3<f32>(0.0) ;
    let lightIndex = getCluster();
    let start = max(lightIndex.start, 0.0);
    let count = max(lightIndex.count, 0.0);
    let end = max(start + count , 0.0);
    for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
    {
        let light = getLight(i32(i));
        switch (light.lightType) {
          case PointLightType: {
            // specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
          }
          case DirectLightType: {
              // specColor += directHairLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
              var fHairTransmittanceData : FHairTransmittanceData ;
              fHairTransmittanceData.bUseBacklit = true ;
              fHairTransmittanceData.bUseSeparableR = true ;
              fHairTransmittanceData.bUseLegacyAbsorption = false ;

              //use shadow visible backlit
              specColor = hairShading(light,fragData.V, ORI_ShadingInput.HairNormal , 1.0 ,fHairTransmittanceData,1.0,materialUniform.area,vec2f(0.0));
          }
          case SpotLightType: {
            // specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
          }
          default: {
          }
        }
    }


    let sunLight = lightBuffer[0] ;
    //***********lighting-PBR part********* 
    var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0.rgb , fragData.Roughness);
    var kS = F;
    // var kD = vec3(1.0) - kS;
    // kD = kD * (1.0 - fragData.Metallic);
    let envIBL =  materialUniform.envIntensity * IBLEnv(fragData.V ,fragData.N ,fragData.Roughness ) ;
    fragData.EnvColor = envIBL ;
    // fragData.Specular = envIBL ;
    //***********indirect-specular part********* 
    
    var iblSpecularResult = fragData.Metallic * fragData.EnvColor * materialUniform.specularColor.rgb ;
    //***********indirect-specular part********* 
    
    //***********indirect-ambient part********* 
    var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
    var iblDiffuseResult = irradiance * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
    //irradiance
    //***********indirect-ambient part********* 
    var indirectResult = (iblSpecularResult + iblDiffuseResult * max(sunLight.quadratic,0.05) ) * fragData.Ao ;
    fragData.LightChannel = specColor ;

    // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
    #if USEGBUFFER
        var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
        ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
        ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
    #endif
    
    #if USE_WORLDPOS
        ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
    #endif
  
    let finalColor =  LinearToGammaSpace(vec3f(specColor + indirectResult) ) ;
    ORI_FragmentOutput.color = vec4<f32>( finalColor ,fragData.Albedo.a) ;
    // ORI_FragmentOutput.color = vec4<f32>( vec3f(specColor) ,fragData.Albedo.a) ;
}

  `,hl=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BsDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = ORI_ShadingInput.SSS + LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;

   

      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
            }
            case DirectLightType: {
              specColor += directDulLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
            }
            case SpotLightType: {
              specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
            }
            default: {
            }
          }
      }


      fragData.LightChannel = specColor ;

      let sunLight = lightBuffer[0] ;
      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let envIBL =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = envIBL ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   
      var iblSpecularResult = surfaceReduction * fragData.EnvColor * fresnelLerp + envIBL;
      iblSpecularResult *= max(sunLight.quadratic,0.05) ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
      //  Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * 2.0 * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
      //irradiance
      //***********indirect-ambient part********* 
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05);
      // debugOut = vec4f(iblDiffuseResult,1.0);

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
      #endif
      
      var color = specColor + indirectResult ;
      color += fragData.Emissive.xyz ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      let retColor = (LinearToGammaSpace(color.rgb));
      ORI_FragmentOutput.color = vec4<f32>( retColor ,fragData.Albedo.a) ;
  }

  `,cl=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let color = textureSample(baseMap,baseMapSampler,uv) ;
        if(color.w < materialUniform.alphaCutoff){
            discard ;
        }
        
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        UnLit();
    }
`,ul=`
    #include "Common_vert"
    #include "Common_frag"
    #include "ClusterLight"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let baseColor = textureSample(baseMap,baseMapSampler,uv) ;
        if(baseColor.w < materialUniform.alphaCutoff){
            discard ;
        }

        var lightColor = vec4<f32>(0.0);
        let lightIndex = getCluster();
        let start = max(lightIndex.start, 0.0);
        let count = max(lightIndex.count, 0.0);
        let end = max(start + count , 0.0);
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
          let light = getLight(i32(i));
  
          switch (light.lightType) {
            case PointLightType: {
            }
            case DirectLightType: {
                var normal = ORI_VertexVarying.vWorldNormal ;
                let intensity = (light.intensity/10.0);
                let att = max(dot(normal,-light.direction),0.0) * intensity ;
                lightColor += baseColor * att * 0.5 + baseColor * 0.5 ; 
                // lightColor = baseColor * 0.5; 
            }
            case SpotLightType: {
            }
            default: {
            }
          }
        }
        
        ORI_ShadingInput.BaseColor = lightColor * materialUniform.baseColor;
        if(ORI_ShadingInput.BaseColor.w > 1.0){
            ORI_ShadingInput.BaseColor.w = 1.0;
        }
        UnLit();

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // ORI_FragmentOutput.out_depth = z * (n/(f-n)) ;
    }
`,dl=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
        @location(auto) fragUV: vec2<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main(@builtin(instance_index) index : u32, @location(auto) position: vec3<f32>, @location(auto) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        let id = u32(index);
        let worldMatrix = models.matrix[id];

        let screenPos = vec2(((TEXCOORD_1 * 2.0) - vec2<f32>(1.0))) * 0.5 ; 
        return VertexOutput(TEXCOORD_1, vec4<f32>(screenPos, 0.0, 1.0));
    }
`,fl=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix;
    mat4 pvMatrixInv;
    float frame;
    float time;
    float delta;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;

};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;
layout(set = 3, binding = 0) uniform MaterialDataUniform {
    vec4 color;
};

void main() {
        vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
        vec4 colorTexture = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale) * color;
    o_Target = vec4(colorTexture.rgb, colorTexture.a);

    if (o_Target.r <= 0.5 && o_Target.g <= 0.5 && o_Target.b <= 0.5) {
        discard;
    }
    // float gamma     = 2.2;
    // float exposure  = 1.0;
    // float pureWhite = 1.0;

    // float luminance = dot(colorTexture.rgb, vec3(0.2126, 0.7152, 0.0722));
    // float mappedLuminance = (luminance * (1.0 + luminance/(pureWhite*pureWhite))) / (1.0 + luminance);

    // // Scale color by ratio of average luminances.
    // vec3 mappedColor = (mappedLuminance / luminance) * colorTexture.rgb;

    // // Gamma correction.
    // o_Target = vec4(pow(o_Target.rgb, vec3(1.0/gamma)), 1.0);
};
`,Al=`
#include "GlobalUniform"
#include "ColorUtil_frag"

struct uniformData {
    eyesPos: vec3<f32>,
    exposure: f32,
    roughness: f32,
};

struct FragmentOutput {
    @location(auto) o_Position: vec4<f32>,
    @location(auto) o_Normal: vec4<f32>,
    @location(auto) o_Color: vec4<f32>
};

@group(1) @binding(4)
var baseMapSampler: sampler;
@group(1) @binding(5)
var baseMap: texture_cube<f32>;

@group(2) @binding(0)
var<uniform> global: uniformData;

@fragment
fn main(@location(auto) fragUV: vec2<f32>,@location(auto) vClipPos: vec4<f32>, @location(auto) vWorldPos: vec4<f32>, @location(auto) vWorldNormal: vec3<f32> , @builtin(position) fragCoord : vec4<f32> ) -> FragmentOutput {
    let maxLevel: u32 = textureNumLevels(baseMap);
    let textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
    let o_Color = 0.618 * vec4<f32>(LinearToGammaSpace(textureColor) * globalUniform.skyExposure , 1.0);
    let o_Normal = vec4(vWorldNormal,1.0) ;
    let o_Position = vec4<f32>(vWorldPos.xyz,100000.0) ;
    return FragmentOutput(o_Position,o_Normal,o_Color);
}
`,Us=`
#include "Common_vert"
#include "FragmentVarying"
#include "GlobalUniform"

struct FragmentOutput {
    @location(auto) o_Position: vec4<f32>,
    @location(auto) o_Normal: vec4<f32>,
    @location(auto) o_Color: vec4<f32>
};

struct MaterialUniform {
    baseColor: vec4<f32>,
    emissiveColor: vec4<f32>,
    emissiveIntensity: f32,
    normalScale: f32,
    alphaCutoff: f32
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var normalMapSampler: sampler;
@group(1) @binding(auto)
var normalMap: texture_2d<f32>;

@group(1) @binding(auto)
var emissiveMapSampler: sampler;
@group(1) @binding(auto)
var emissiveMap: texture_2d<f32>;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

var<private> ORI_FragmentOutput: FragmentOutput;
var<private> ORI_VertexVarying: FragmentVarying;

@fragment
fn FragMain(vertex_varying:FragmentVarying) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    var texColor = textureSample(baseMap, baseMapSampler, ORI_VertexVarying.fragUV0.xy );

    var emissive = textureSample(emissiveMap, emissiveMapSampler, ORI_VertexVarying.fragUV0.xy ).rgb ;
    let intensity = materialUniform.emissiveIntensity * materialUniform.emissiveColor.a ;
    emissive = emissive.rgb * materialUniform.emissiveColor.rgb ;
    emissive = convertToHDRRGB(emissive,intensity);

    if (materialUniform.alphaCutoff-texColor.w > 0.0) {
        discard ;
    }

    var o_Position = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,emissive.r) ;
    var o_Normal = vec4<f32>((ORI_VertexVarying.vWorldNormal.xyz * 0.5 + 0.5 ),emissive.g) ;
    var o_Color = vec4<f32>((texColor * materialUniform.baseColor).rgb , emissive.b )  ;
    return FragmentOutput(o_Position,o_Normal,vec4<f32>(o_Color));
}

fn convertToHDRRGB( color : vec3<f32> , ins:f32 ) -> vec3<f32> {
    var hdrColor = vec3<f32>(0.0,0.0,0.0);
    hdrColor.r = color.r * pow(2.4, ins);
    hdrColor.g = color.g * pow(2.4, ins);
    hdrColor.b = color.b * pow(2.4, ins);
    return hdrColor;
}
`,gl=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(auto) fragUV: vec2<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${ct.getMorphTargetShaderBinding(2,1)}
#endif

#if USE_SKELETON
    ${pa.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
    @builtin(instance_index) index : u32,
    @location(auto) position: vec3<f32>,
    @location(auto) normal: vec3<f32>,
    @location(auto) uv: vec2<f32>,
    @location(auto) TEXCOORD_1: vec2<f32>,

    #if USE_METAHUMAN
        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #else
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #endif
    #else
        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
        #endif

        #if USE_SKELETON
            #if USE_TANGENT
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                #endif
            #else
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                #endif
            #endif
        #endif

        #if USE_MORPHTARGETS
            #if USE_TANGENT
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;
    var vertexNormal = vertex.normal.xyz;

    #if USE_MORPHTARGETS
     ${ct.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;

    return VertexOutput(vertex.uv, vPos );  
}
`,pl=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(auto) fragUV: vec2<f32>,
    @location(auto) worldPos: vec3<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${ct.getMorphTargetShaderBinding(2,1)}
##endif
 
#if USE_SKELETON
    ${pa.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(auto) position: vec3<f32>,
  @location(auto) normal: vec3<f32>,
  @location(auto) uv: vec2<f32>,
  @location(auto) TEXCOORD_1: vec2<f32>,

  
  #if USE_METAHUMAN
    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        @location(auto) joints1: vec4<f32>,
        @location(auto) weights1: vec4<f32>,
        @location(auto) vIndex: f32,
    #else
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        @location(auto) joints1: vec4<f32>,
        @location(auto) weights1: vec4<f32>,
        @location(auto) vIndex: f32,
    #endif
    #else
    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
    #endif

    #if USE_SKELETON
        #if USE_TANGENT
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #else
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #endif
    #endif

    #if USE_MORPHTARGETS
        #if USE_TANGENT
            @location(auto) vIndex: f32,
        #else
            @location(auto) vIndex: f32,
        #endif
    #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;

    #if USE_METAHUMAN
        ${ct.getMorphTargetCalcVertex()}
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    #if USE_MORPHTARGETS
        ${ct.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;
    return VertexOutput(vertex.uv, worldPos.xyz , vPos ); 
}
`,ml=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(auto) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32> , @location(auto) worldPos:vec3<f32> ) -> FragmentOutput {
        var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      #if USE_ALPHACUT
        let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
        if(Albedo.w > 0.5){
          fragOut = FragmentOutput(vec4<f32>(0.0),distance);
        }
      #else
        fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      #endif
      
        return fragOut ;
    }
`,Ul=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(auto) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32> , @location(auto) clipPos:vec3<f32> ) -> FragmentOutput {
        // var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        // distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      // #if USE_ALPHACUT
      //   let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
      //   if(Albedo.w > 0.5){
      //     fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      //   }
      // #else
      //   fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      // #endif
      
        return fragOut ;
    }
`,Bl=`
    #include "GlobalUniform"
    #include "MathShader"
    struct VertexOutput {
        @location(auto) vID: f32 ,
        @location(auto) vPos: vec3<f32> ,
        @location(auto) vClipPos: vec4<f32> ,
        @builtin(position) member: vec4<f32>
    };

    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;

    var<private> worldMatrix: mat4x4<f32>;

    #if USE_MORPHTARGETS
        ${ct.getMorphTargetShaderBinding(1,0)}
    #endif

    #if USE_SKELETON
        ${pa.groupBindingAndFunctions(1,0)}
    #endif

    @vertex
    fn main(
        @builtin(instance_index) index : u32,
        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #elseif USE_MORPHTARGETS
            @location(auto) vIndex: f32,
        #endif
    #elseif USE_SKELETON
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
            @location(auto) joints1: vec4<f32>,
            @location(auto) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        @location(auto) vIndex: f32,
    #endif
    ) -> VertexOutput {
    worldMatrix = models.matrix[index];

    var vertexPosition = position;
    var vertexNormal = normal;
    #if USE_MORPHTARGETS
        ${ct.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(joints0, weights0, joints1, weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(joints0, weights0);
        #endif
    #endif

        
        let wPos = worldMatrix * vec4<f32>(vertexPosition.xyz, 1.0);
        var fixProjMat = globalUniform.projMat ;
        var rzMatrix : mat4x4<f32> ;
        rzMatrix[0] = vec4<f32>(1.0,0.0,0.0,0.0) ; 
        rzMatrix[1] = vec4<f32>(0.0,1.0,0.0,0.0) ; 
        rzMatrix[2] = vec4<f32>(0.0,0.0,1.0,0.0) ; 
        rzMatrix[3] = vec4<f32>(0.0,0.0,0.0,1.0) ; 
        var clipPos:vec4<f32> = fixProjMat * globalUniform.viewMat * (wPos) ;

        // let d = log2Depth(clipPos.z * (globalUniform.far - globalUniform.near),globalUniform.near,globalUniform.far) ;
        return VertexOutput(f32(index) , wPos.xyz,clipPos, clipPos);
    }

    fn depthToLinear01(depth:f32) -> f32 {
        let a = 1.0 / (globalUniform.near - globalUniform.far);
        return (globalUniform.near*globalUniform.far*a) / (depth + globalUniform.far * a) ;
    }
`,Fl=`
    #include "GlobalUniform"
    #include "MathShader"
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>,
        @builtin(frag_depth) out_depth: f32
    };
   

    @fragment
    fn main(@location(auto) vID: f32, @location(auto) vPos:vec3<f32> ,  @location(auto) vClipPos: vec4<f32> ,  @builtin(position) fragCoord : vec4<f32>) -> FragmentOutput {
        var op = vec4<f32>( vPos, vID);
        let d = log2Depth(fragCoord.z+0.00001,globalUniform.near,globalUniform.far);
        return FragmentOutput(op,d);
    }
`,Cl=`

    const inv256:f32 = 1.0/256.0;
    const inv1024:f32 = 1.0/1024.0;

    const bit7_inv128:f32 = 1.0 / 128.0;
    const bit7_128:f32 = 128.0;
    
    const r10g10b10 = vec2i(0x3FFFFF,0xFF);
    fn floatToVec3f( v:f32 ) -> vec3f {
        var VPInt:i32 = bitcast<i32>(v);
        var VPInt1024:i32 = VPInt%1024;
        var VPInt10241024:i32 = ((VPInt-VPInt1024)/1024)%1024;
        return vec3f(f32(VPInt1024),f32(VPInt10241024),f32(((VPInt-VPInt1024-VPInt10241024)/1048576)))*vec3f(inv1024);
    }

    fn vec3fToFloat( v:vec3f) -> f32{
        let intv = min(vec3<i32>(floor(v*1024.)),vec3<i32>(1023));
        return bitcast<f32>(i32(intv.x+intv.y*1024+intv.z*1048576));
    }

    fn vec4fToFloat_7bits( v:vec4f) -> f32{
        //0~256
        let intv = min(vec4<i32>(floor(v*bit7_128)),vec4<i32>(127));
        return bitcast<f32>(i32(intv.x+intv.y*128+intv.z*16384+intv.w*2097152));
    }

    fn floatToVec4f_7bits( v:f32 ) -> vec4f {
        var VPInt:i32 = bitcast<i32>(v);
        var VPInt128:i32 = VPInt%128;
        var VPInt128128:i32 = ((VPInt-VPInt128)/128)%128;
        var VPInt128128128:i32 = ((VPInt-VPInt128-VPInt128128)/16384)%128;
        var VPInt128128128128:i32 = ((VPInt-VPInt128-VPInt128128-VPInt128128128)/2097152)%128;
        return vec4f(f32(VPInt128),f32(VPInt128128),f32(VPInt128128128),f32(VPInt128128128128))*vec4f(bit7_inv128);
    }






    const i_r11g11b11 = vec3i(0x7FF,0x7FF,0x7FF);
    const f_r11g11b11 = vec3f(f32(0x7FF),f32(0x7FF),f32(0x7FF));
    fn r11g11b11_to_float( v:vec3f) -> f32{
        let iR: i32 = i32(v.r * f_r11g11b11.r);
        let iG: i32 = i32(v.g * f_r11g11b11.g);
        let iB: i32 = i32(v.b * f_r11g11b11.b);
        return bitcast<f32>((iR << 22u) | (iG << 11u) | iB );
    }

    fn float_to_r11g11b11( v:f32 ) -> vec3f {
        let iV: i32 = bitcast<i32>(v);
        var r: f32 = f32((iV >> 22u) & i_r11g11b11.r) / f_r11g11b11.r;
        var g: f32 = f32((iV >> 11u) & i_r11g11b11.g) / f_r11g11b11.g;
        var b: f32 = f32(iV & i_r11g11b11.b) / f_r11g11b11.b ;
        return vec3f(r,g,b);
    }

    const i_r22g8 = vec2i(0x3FFFFF,0xFF);
    const f_r22g8 = vec2f(f32(0x3FFFFF),f32(0xFF));
    fn r22g8_to_float( v:vec2f) -> f32{
        let iR: i32 = i32(v.r * f_r22g8.r);
        let iG: i32 = i32(v.g * f_r22g8.g);
        return bitcast<f32>((iR << 8u) | iG);
    }

    fn float_to_r22g8( v:f32 ) -> vec2f {
        let iV: i32 = bitcast<i32>(v);
        var r: f32 = f32((iV >> 8u) & i_r22g8.r) / f_r22g8.r;
        var g: f32 = f32(iV & i_r22g8.g) / f_r22g8.g ;
        return vec2f(r,g);
    }

    const r11g11b9 = vec3i(0x7FF,0x7FF,0x1FF);
    fn r11g11b9_to_float( v:vec3f) -> f32{
        let iR: i32 = i32(v.r * f32(r11g11b9.r));
        let iG: i32 = i32(v.g * f32(r11g11b9.g));
        let iB: i32 = i32(v.b * f32(r11g11b9.b));
        return bitcast<f32>((iR << 20u) | (iG << 9u) | iB );
    }

    fn float_to_r11g11b9( v:f32 ) -> vec3f {
        let iV: i32 = bitcast<i32>(v);
        var r: f32 = f32((iV >> 20u) & r11g11b9.r) / f32(r11g11b9.r);
        var g: f32 = f32((iV >> 9u) & r11g11b9.g) / f32(r11g11b9.g);
        var b: f32 = f32(iV & r11g11b9.b) / f32(r11g11b9.b) ;
        return vec3f(r,g,b);
    }




    fn floatToRGBA(v:f32) -> vec4f{
        var iv = bitcast<u32>(v);
        var color = vec4f(0.0);
        color.x = f32((iv&0x00FF0000u)>>16u)/255.0;
        color.y = f32((iv&0x000FF00u)>>8u)/255.0;
        color.z = f32(iv&0x000000FFu)/255.0;
        return color;
    }

    const bitShift:vec4f = vec4f(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));
    fn RGBAToFloat(v:vec4f) -> f32 {
        var f = dot(v, bitShift);
        return f;
    }

`,Ql=`
    #include "MathShader"
    #include "FastMathShader"
    #include "BitUtil"
    #include "ColorUtil_frag"

    @group(0) @binding(1) var gBufferTexture : texture_2d<f32>;

    struct GBuffer{
        x : f32 ,
        y : f32 ,
        z : f32 ,
        w : f32 ,
    }

    struct ViewSpaceGBuffer{
        depth:f32,
        color:vec3f ,
        abldeoColor:vec3f ,
        viewPosition:vec3f,
        viewNormal:vec3f,
        roughness:f32,
        metallic:f32,
    }

    struct WorldSpaceGBuffer{
        depth:f32,
        color:vec3f ,
        abldeoColor:vec3f ,
        worldPosition:vec3f,
        worldNormal:vec3f,
        roughness:f32,
        metallic:f32,
    }

    fn getViewSpaceGBuffer(fragCoord:vec2i , uv:vec2f ) -> ViewSpaceGBuffer {
        var sampleUV = uv ;
        sampleUV.y = 1.0 - sampleUV.y ;
        let gBufferTexture = textureLoad(gBufferTexture, fragCoord , 0) ;

        var gBuffer : ViewSpaceGBuffer ;
        //x channel view space depth 
        gBuffer.depth = gBufferTexture.x ;
        let viewPos = getViewPosition(gBufferTexture.x,sampleUV);
        gBuffer.viewPosition = viewPos;
        
        //y channel last final color texture
        gBuffer.color = floatToVec3f(gBufferTexture.y) ;

        //z channel view space normal 
        let zChannel = floatToVec3f(gBufferTexture.z) ;
        let octUV = zChannel.xy * 2.0 - 1.0  ;
        gBuffer.viewNormal = octDecode(octUV.xy) ;

        //w channel view space normal 
        let wChannel = floatToVec3f(gBufferTexture.w) ;
        gBuffer.abldeoColor = wChannel.xyz ;

        gBuffer.roughness = zChannel.z ;
        gBuffer.metallic = 0.0 ;//wChannel.w ;

        return gBuffer ;
    }

    fn getWorldSpaceGBuffer(fragCoord:vec2i , uv:vec2f ) -> WorldSpaceGBuffer {
        var sampleUV = uv ;
        sampleUV.y = 1.0 - sampleUV.y ;
        let gBufferTexture = textureLoad(gBufferTexture, fragCoord , 0) ;

        var gBuffer : WorldSpaceGBuffer ;
        //x channel view space depth 
        gBuffer.depth = gBufferTexture.x ;
        let worldPos = getWorldPosition(gBufferTexture.x,sampleUV);
        gBuffer.worldPosition = worldPos;

        //y channel last final color texture
        gBuffer.color = floatToVec3f(gBufferTexture.y) ;

        //z channel world space normal and roughness 
        let zChannel = floatToVec3f(gBufferTexture.z) ;
        let octUV = zChannel.xy * 2.0 - 1.0  ;
        gBuffer.worldNormal = getWorldNormal(octDecode(octUV.xy)) ;

        //w channel abldeoColor and metallic
        let wChannel = floatToVec3f(gBufferTexture.w) ;
        gBuffer.abldeoColor = wChannel.xyz ;

        gBuffer.roughness = zChannel.z ;
        gBuffer.metallic = 0.0 ;//wChannel.w ;

        return gBuffer ;
    }

    fn getGBuffer(fragCoord:vec2i) -> GBuffer {
        let gBufferTexture = textureLoad(gBufferTexture, fragCoord , 0) ;
        var gBuffer:GBuffer ;
        gBuffer.x = gBufferTexture.x ;
        gBuffer.y = gBufferTexture.y ;
        gBuffer.z = gBufferTexture.z ;
        gBuffer.w = gBufferTexture.w ;
        return gBuffer ;
    }

    fn getDepthFromGBuffer(gBuffer:GBuffer) -> f32 {
        return gBuffer.x ;
    }

    fn getViewPositionFromGBuffer(gBuffer:GBuffer,screenUV:vec2f) -> vec3f {
        var sampleUV = screenUV ;
        sampleUV.x = 1.0 - sampleUV.x ;
        sampleUV.y = 1.0 - sampleUV.y ;
        let viewPos = getViewPosition(gBuffer.x,sampleUV);
        return viewPos;
    }

    fn getViewNormalFromGBuffer(gBuffer:GBuffer) -> vec3f {
        let worldNormal = getWorldNormalFromGBuffer(gBuffer) ;
        return getViewNormal(worldNormal);
    }

    fn getWorldPositionFromGBuffer(gBuffer:GBuffer,uv:vec2f) -> vec3f {
        var sampleUV = uv ;
        sampleUV.y = 1.0 - sampleUV.y ;
        let worldPos = getWorldPosition(gBuffer.x,sampleUV);
        return worldPos;
    }

    fn getSkyPositionFromGBuffer(uv:vec2f) -> vec3f {
        var sampleUV = uv ;
        sampleUV.y = 1.0 - sampleUV.y ;
        let worldPos = getWorldPosition(0.9999999, sampleUV);
        return worldPos;
    }

    fn getRGBMColorFromGBuffer(gBuffer:GBuffer) -> vec3f {
        let rgb = unpack4x8unorm(u32(gBuffer.z)).rgb ;
        let m = unpack4x8unorm(u32(gBuffer.w)).z ;
        return DecodeRGBM(vec4f(rgb,m)) ;
    }

   
    fn getWorldNormalFromGBuffer(gBuffer:GBuffer) -> vec3f {
        // let viewNormal = getViewNormalFromGBuffer(gBuffer) ; 
        // let worldNormal = getWorldNormal(viewNormal) ;
        // return worldNormal;
        let zChannel = float_to_r11g11b9(gBuffer.y) ;
        let octUV = zChannel.xy * 2.0 - 1.0  ;
        let viewNormal = octDecode(octUV.xy);
        return viewNormal;
    }



    fn getAbldeoFromGBuffer(gBuffer:GBuffer) -> vec4f {
        let rgba = floatToVec4f_7bits(gBuffer.z).rgba ;
        return rgba ;
    }

    fn getAlphaFromGBuffer(gBuffer:GBuffer) -> f32 {
        let rgba = floatToVec4f_7bits(gBuffer.z).rgba ;
        return rgba.a;
    }

    fn getMetaillicFromGBuffer(gBuffer:GBuffer) -> f32 {
        let channel = float_to_r22g8(gBuffer.w) ;
        return channel.y;
    }

    fn getRoughnessFromGBuffer(gBuffer:GBuffer) -> f32 {
        let channel = float_to_r11g11b9(gBuffer.y) ;
        return channel.z;
    }

    fn getIDFromGBuffer_f32_01(gBuffer:GBuffer) -> f32 {
        let channel = float_to_r22g8(gBuffer.w) ;
        return channel.x;
    }

    fn getIDFromGBuffer_i32(gBuffer:GBuffer) -> i32 {
        let id_f32_01 = getIDFromGBuffer_f32_01(gBuffer) ;
        let id = i32(round(id_f32_01 * f_r22g8.r));
        return id;
    }

    
`,vl=`
    #include "Common_vert"
    #include "Common_frag"
    #include "GlobalUniform"
    #include "BitUtil"
    #include "MathShader"
    #include "ReflectionCG"
    #include "ColorUtil_frag"
    
    struct MaterialUniform {
        transformUV1:vec4<f32>,
        transformUV2:vec4<f32>,
        baseColor: vec4<f32>,
        alphaCutoff: f32,
        reflectionIndex : f32,
    };

    // @group(1) @binding(0)
    // var baseMapSampler: sampler;
    // @group(1) @binding(1)
    // var baseMap: texture_2d<f32>;
    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        useSphereReflection();
        var finalColor : vec3f ;
        let scale = vec2f(1.0/8.0,1.0/globalUniform.reflectionProbeMaxCount) ;
        var uv = (octEncode(-ORI_VertexVarying.vWorldNormal) + 1.0) * 0.5 ;
        var uv1 = uv * scale + vec2f(0.0,(materialUniform.reflectionIndex * scale.y )) ;
        let gBuffer = textureSampleLevel(reflectionMap,reflectionMapSampler,uv1,0.0);
        ORI_ShadingInput.BaseColor = vec4f(gBuffer.rgb,1.0) ;
        UnLit();
    }

    fn UnLit(){
        var viewColor = ORI_ShadingInput.BaseColor ;
            let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
            let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
            let ORI_NORMALMATRIX = transpose(inverse( nMat ));

            var vNormal = normalize(ORI_NORMALMATRIX * (ORI_VertexVarying.vWorldNormal ));
            var worldNormal = vec3<f32>( (vNormal.xyz + 1.0) * 0.5);

            let gBuffer = packNHMDGBuffer(
                ORI_VertexVarying.fragCoord.z,
                vec3f(0.0),
                viewColor.rgb,
                vec3f(0.0),
                vNormal,
                viewColor.a
            );

            #if USE_CASTREFLECTION
                ORI_FragmentOutput.gBuffer = gBuffer ;
            #else
                ORI_FragmentOutput.color = viewColor ;
                ORI_FragmentOutput.gBuffer = gBuffer ;
            #endif
    }
`,Sl=`
    #include 'MathShader'
    #include 'BitUtil'
    #include 'GlobalUniform'

    struct ReflectionInfo{
        gid:f32,
        worldPosition:vec3f,
        radius:f32,
        worldPosition2:vec3f,
    }

    @group(1) @binding(auto)
    var reflectionMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var reflectionMapSampler: sampler;

    @group(2) @binding(8) 
    var<storage,read> reflectionBuffer : array<ReflectionInfo>;

    var<private> reflectionSize : vec2f ; 
    var<private> PROBE_SOURCESIZE : vec2f ; 
    var<private> PROBEMAP_SOURCESIZE : vec2f ; 
    var<private> aspect : vec2f ; 
    var<private> spaceV : f32 ; 

    fn useSphereReflection(){
        reflectionSize = vec2f(textureDimensions(reflectionMap).xy);
        PROBE_SOURCESIZE = vec2f(globalUniform.reflectionProbeSize);
        PROBEMAP_SOURCESIZE = vec2f(globalUniform.reflectionMapWidth,globalUniform.reflectionMapHeight) ;
        aspect = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
        spaceV = 1.0 / globalUniform.reflectionProbeMaxCount;
    }

    fn getSampleProbeUV(dir:vec3<f32>,gid:f32) -> vec2<f32> {
        let faceId = dir_to_faceId(dir);
        var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
        targetUV.x = 1.0 - targetUV.x;
        // targetUV.y = 1.0 - targetUV.y;
        let threshould = 0.5 / PROBE_SOURCESIZE;
        targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));
     
        targetUV.x = f32(faceId) + targetUV.x;
        targetUV = targetUV * aspect ;
        targetUV.y = targetUV.y + (spaceV*gid);
        return targetUV ;
     }

    //  fn getReflectionsMap(n:vec3<f32>,gid:f32) -> vec3f {
    //     var uv = getSampleProbeUV(-n,gid);
    //     let color = textureSample(reflectionMap,reflectionMapSampler,uv) ;
    //     return floatToVec3f(color.y) ;
    //  }

    const magic = vec4f(0.9852,0.99214,0.00754,0.0);
     fn getReflectionsBuffer(n:vec3<f32>,gid:f32,mip:f32) -> vec4f {
        let scaleA = vec2f(1.0/8.0,1.0/globalUniform.reflectionProbeMaxCount) ;
        let mipSource = clamp((mip * 8.0),0.0,8.0) ;
        let mip1 = floor(mipSource) ;
        let mip2 = mip1 + 1.0 ;
        let mipPect = mipSource - mip1 ;
        var uv = (octEncode(-n) + 1.0) * 0.5 * magic.xy + magic.zw ;
        var uv1 = (uv * scaleA + vec2f((mip1 * (scaleA.x)) ,0.0 ));
        var uv2 = (uv * scaleA + vec2f((mip2 * (scaleA.x)) ,0.0 ));
        let b1 = textureSampleLevel(reflectionMap,reflectionMapSampler,uv1,0.0);
        let b2 = textureSampleLevel(reflectionMap,reflectionMapSampler,uv2,0.0);
        let b1Color = b1.rgb ;
        let b2Color = b2.rgb ;

        // let rgb1 = unpack4x8unorm(u32(b1.z)).rgb ;
        // let rgb2 = unpack4x8unorm(u32(b2.z)).rgb ;

        // let m1 = unpack4x8unorm(u32(b1.w)).z ;
        // let m2 = unpack4x8unorm(u32(b2.w)).z ;

        // let b1Color = DecodeRGBM(vec4f(rgb1,m1));
        // let b2Color = DecodeRGBM(vec4f(rgb2,m2));

        // let b1D = b1.x; 
        // let b2D = b2.x; 

        let color = mix(b1Color,b2Color,vec3f(mipPect));  ;
        // let depth = mix(b1D,b2D,(mipPect)); 
        // return vec4f(color,depth) ;
        return vec4f(color,0.0) ;
     }

     fn getReflectionsEnv(reflectDir:vec3<f32>,worldPos:vec3f,mip:f32) -> vec3f{
        let maxCount = u32(globalUniform.reflectionProbeMaxCount) ;
        var nearColor = vec3f(0.0);
        if(globalUniform.reflectionCount > 0.0){
            var nearDistance = 99999.0 ;
            var nearReflectionIndex = 0u ;
            for(var i = 0u ; i < maxCount; i+=1u){
                var reflectionInfo = reflectionBuffer[i];
                let dis = length(reflectionInfo.worldPosition - worldPos) ;
                if(dis < nearDistance){
                    nearDistance = dis;
                    nearReflectionIndex = i;
                }
            }
            nearColor = getReflectionsBuffer(reflectDir,f32(nearReflectionIndex),mip).xyz;
        }else{
            nearColor = textureSampleLevel(envMap, envMapSampler, reflectDir , mip * 12.0 ).rgb ;
        }
        return nearColor ;
     }

    //  fn getReflectionsEnv(n:vec3<f32>,worldPos:vec3f,mip:f32) -> vec3f{
    //     let count = 1.0 ;//globalUniform.reflectionProbeMaxCount ;
    //     var nearColor = vec3f(0.0);
    //     var nearDistance = 99999.0 ;
    //     for(var i = 0.0 ; i < count; i+=1.0){
    //         var reflectionInfo = reflectionBuffer[i32(i)];
    //         let dis = length(reflectionInfo.worldPosition - worldPos) ;
    //         if(dis > reflectionInfo.radius){
    //             var buffer = getReflectionsBuffer(n,i,mip);
    //             var d = buffer.w;
    //             if(d <= -globalUniform.far){
    //                 d = 99999.0 - 1.0 ;
    //             }
    //             if(nearDistance > d){
    //                 nearColor = buffer.xyz;
    //                 nearDistance = d;
    //             }
    //         }else{
    //             nearColor = vec3f(1.0,0.0,0.0);
    //         }
    //     }
    //     return nearColor ;
    //  }


`,Rl=`

fn Y0(v : vec3f ) -> f32 {
     return ((1.0 / 2.0) * sqrt(1.0 / PI)); 
}

fn Y1(v: vec3f ) -> f32 {
    return ( sqrt(3.0 / (4.0 * PI)) * v.z ) ;
}

fn Y2(v: vec3f ) -> f32 { 
    return (sqrt(3.0 / (4.0 * PI)) * v.y) ;
}

fn Y3(v: vec3f ) -> f32 {  
    return (sqrt(3.0 / (4.0 * PI)) * v.x) ;
}

fn Y4(v: vec3f ) -> f32 { 
    return (1.0 / 2.0 * sqrt(15.0 / PI) * v.x * v.z) ;
}

fn Y5(v: vec3f ) -> f32 { 
    return (1.0 / 2.0 * sqrt(15.0 / PI) * v.z * v.y) ;
}

fn Y6(v: vec3f ) -> f32 { 
    return (1.0 / 4.0 * sqrt(5.0 / PI) * (-v.x * v.x - v.z * v.z + 2.0 * v.y * v.y)) ;
}

fn Y7(v: vec3f ) -> f32 { 
    return (1.0 / 2.0 * -sqrt(15.0 / PI) * v.y * v.x) ;
}

fn Y8(v: vec3f ) -> f32 { 
    return (1.0 / 4.0 * sqrt(15.0 / PI) * (v.x * v.x - v.z * v.z)) ;
}

fn Y9(v: vec3f ) -> f32 { 
    return (1.0 / 4.0 * sqrt(35.0 / (2.0 * PI)) * (3.0 * v.x * v.x - v.z * v.z) * v.z) ;
}

fn Y10(v: vec3f ) -> f32 { 
    return ( 1.0 / 2.0 * sqrt(105.0 / PI) * v.x * v.z * v.y );
}

fn Y11(v: vec3f ) -> f32 { 
    return ( 1.0 / 4.0 * sqrt(21.0 / (2.0 * PI)) * v.z * (4.0 * v.y * v.y - v.x * v.x - v.z * v.z) );
}

fn Y12(v: vec3f ) -> f32 { 
    return ( 1.0 / 4.0 * sqrt(7.0 / PI) * v.y * (2 * v.y * v.y - 3.0 * v.x * v.x - 3.0 * v.z * v.z) );
}

fn Y13(v: vec3f ) -> f32 { 
    return ( 1.0 / 4.0 * sqrt(21.0 / (2.0 * PI)) * v.x * (4.0 * v.y * v.y - v.x * v.x - v.z * v.z) );
}

fn Y14(v: vec3f ) -> f32 { 
    return ( 1.0 / 4.0 * sqrt(105.0 / PI) * (v.x * v.x - v.z * v.z) * v.y );
}

fn Y15(v: vec3f ) -> f32 { 
    return ( 1.0 / 4.0 * sqrt(35.0 / (2.0 * PI)) * (v.x * v.x - 3.0 * v.z * v.z) * v.x );
}

fn SH9(dir: vec3<f32>, coefficients: array<vec4f, 9>) -> vec4<f32> {
    let N: vec3<f32> = vec3<f32>(dir.z, dir.y, dir.x);
    let v: vec3<f32> = normalize(N);

    let color = coefficients[0] * Y0(v)  
        + coefficients[1] * Y1(v) 
        + coefficients[2] * Y2(v) 
        + coefficients[3] * Y3(v) 
        + coefficients[4] * Y4(v) 
        + coefficients[5] * Y5(v) 
        + coefficients[6] * Y6(v) 
        + coefficients[7] * Y7(v)  
        + coefficients[8] * Y8(v) 
    ;
    
    return vec4(color.rgb,1.0) ;
}
`;class N{static init(){N.register("MathShader",yo),N.register("FastMathShader",Lo),N.register("BitUtil",Cl),N.register("GBufferStand",Ql),N.register("SHCommon_frag",Rl),N.register("MatrixShader",nl),N.register("GlobalUniform",tn),N.register("WorldMatrixUniform",rn),N.register("NormalMap_frag",Oo),N.register("LightingFunction_frag",Eo),N.register("PhysicMaterialUniform_frag",Io),N.register("UnLitMaterialUniform_frag",xo),N.register("VideoUniform_frag",To),N.register("InstanceUniform",Po),N.register("Inline_vert",Do),N.register("VertexAttributes_vert",_o),N.register("Common_vert",No),N.register("Common_frag",Vo),N.register("FragmentVarying",Go),N.register("FragmentOutput",an),N.register("ClusterLight",ol),N.register("ShadingInput",Wo),N.register("IESProfiles_frag",Jo),N.register("ShadowMapping_frag",zo),N.register("Irradiance_frag",Zo),N.register("IrradianceVolumeData_frag",wo),N.register("BrdfLut_frag",Mo),N.register("EnvMap_frag",ko),N.register("ColorUtil_frag",il),N.register("BRDF_frag",Xo),N.register("Hair_frag",ll),N.register("BxDF_frag",Yo),N.register("BsDF_frag",hl),N.register("UnLit_frag",bo),N.register("UnLit",cl),N.register("ReflectionCG",Sl),N.register("ReflectionShader_shader",vl),N.register("Clearcoat_frag",Ho),N.register("LitShader",Ko),N.register("PBRLItShader",jo),N.register("ClusterDebug_frag",Ro),N.register("BxdfDebug_frag",qo),N.register("GenerayRandomDir",sl),N.register("Quad_vert_wgsl",el),N.register("Quad_frag_wgsl",tl),N.register("Quad_depth2d_frag_wgsl",rl),N.register("Quad_depthCube_frag_wgsl",al),N.register("sky_vs_frag_wgsl",ka.sky_vs_frag_wgsl),N.register("sky_fs_frag_wgsl",ka.sky_fs_frag_wgsl),N.register("LambertShader",ul),N.register("QuadGlsl_vs",dl),N.register("QuadGlsl_fs",fl),N.register("SkyGBuffer_fs",Al),N.register("gbuffer_vs",Us),N.register("gbuffer_fs",Us),N.register("castPointShadowMap_vert",pl),N.register("shadowCastMap_frag",ml),N.register("shadowCastMap_vert",gl),N.register("directionShadowCastMap_frag",Ul),N.register("ZPass_shader_vs",Bl),N.register("ZPass_shader_fs",Fl)}static register(t,e){N[t.toLowerCase()]||(N[t.toLowerCase()]=e)}static getShader(t){return N[t.toLowerCase()],N[t.toLowerCase()]}}class Rr{static parse(t,e){return t=this.filterComment(t),t=this.parsePreprocess(new Bs,t,e),t=this.parseAutoBindingForAllGroup(t),t=this.parseAutoLocationBlock(t),t}static parseComputeShader(t,e){return t=this.filterComment(t),t=this.parsePreprocess(new Bs,t,e),t=this.parseAutoBindingForAllGroup(t),t}static parsePreprocess(t,e,r){let a=e.indexOf("#");if(a==-1)return e;let i=e.substring(0,a),o=e.indexOf(`
`,e.lastIndexOf("#")),l=e.substring(a,o),h=e.substring(o);return i+this.parsePreprocessCommand(t,l,r)+h}static parseAutoBindingForAllGroup(t){let e=0,r="",a=new Map;for(;e<t.length;){let i=t.indexOf("@group(",e);if(i==-1){r+=t.substring(e);break}let o=t.indexOf(")",i),l=Number.parseInt(t.substring(i+7,o));i=t.indexOf("@binding(",o),o=t.indexOf(")",i);let h=t.substring(i+9,o);if(r+=t.substring(e,i),h.includes("auto"))if(a.has(l)){let c=a.get(l)+1;r+=`@binding(${c})`,a.set(l,c)}else r+="@binding(0)",a.set(l,0);else{let c=Number.parseInt(h);(!a.has(l)||a.get(l)<c)&&a.set(l,c),r+=`@binding(${h})`}e=o+1}return r}static parseAutoBindingForGroupX(t,e){let r=0,a="",i=new Map;for(;r<t.length;){let o=t.indexOf("@group(",r);if(o==-1){a+=t.substring(r);break}let l=t.indexOf(")",o),h=Number.parseInt(t.substring(o+7,l));if(o=t.indexOf("@binding(",l),l=t.indexOf(")",o),a+=t.substring(r,o),h==e)if(i.has(h)){let c=i.get(h)+1;a+=`@binding(${c})`,i.set(h,c)}else a+="@binding(0)",i.set(h,0);else a+=t.substring(o,l+1);r=l+1}return a}static parseAutoLocation(t){let e=0,r="",a=0;for(;e<t.length;){let i=t.indexOf("@location(",e);if(i==-1){r+=t.substring(e);break}let o=t.indexOf(")",i),l=t.substring(i+10,o);r+=t.substring(e,i),l==="auto"?(r+=`@location(${a})`,a++):r+=t.substring(i,o+1),e=o+1}return r}static parseAutoLocationBlock(t){let e=0,r="";for(;e<t.length;){let a=t.indexOf("@location(",e);if(a==-1){r+=t.substring(e);break}let i=t.indexOf("}",a),o=t.indexOf("->",a);o!=-1&&o<i&&(i=o);let l=t.substring(a,i+1);l=this.parseAutoLocation(l),r+=t.substring(e,a),r+=l,e=i+1}return r}static parsePreprocessCommand(t,e,r){let a="",i=e.split(`
`),o=[!1],l=[!1];for(let h=0;h<i.length;h++){let c=i[h],u=o[o.length-1];if(c.trim().indexOf("#")!=0){u||(a+=c+`
`);continue}let d=c.trim();if(d.indexOf("#if")!=-1){if(u&&o.length>1){o.push(u);continue}let f=d.substring(3).trim();u=!this.parseCondition(f,r),o.push(u),l.push(!u);continue}else if(d.indexOf("#elseif")!=-1||d.indexOf("#else")!=-1&&d.indexOf(" if")!=-1){if(l[l.length-1]){o.pop(),u=!0,o.push(u);continue}if(o.pop(),u=o[o.length-1],u&&o.length>1){o.push(u);continue}let f=d.substring(d.indexOf("if")+2).trim();f==""&&console.error(`preprocess command error, conditions missing: ${d}`),u=!this.parseCondition(f,r),o.push(u),l.push(!u);continue}else if(d.indexOf("#else")!=-1){o.pop(),u&&o.length>1&&o[o.length-1]?o.push(u):o.push(!u);continue}else if(d.indexOf("#endif")!=-1){o.pop(),l.pop();continue}else if(d.indexOf("#include")!=-1){let f="",A=d.charAt(d.length-1);if(A==">"?f=this.extract(d,"<",">"):f=this.extract(d,A,A),!t.includeMap.has(f)){t.includeMap.set(f,!0);let p=N.getShader(f);if(!p)throw`${d} error: '${f}' not found`;p=this.filterComment(p),p=this.parsePreprocess(t,p,r),a+=p+`\r
`}continue}else if(d.indexOf("#define ")!=-1){let f=d.substring(d.indexOf("#define ")+8).trim(),A=f.indexOf(" "),p=f,B="";A!=-1&&(p=f.substring(0,A).trim(),B=f.substring(A+1).trim()),r[p]=B;continue}else throw"nonsupport: "+d}return a}static parseCondition(t,e){let r=e[t];return r==null?!1:r==!0||r!=0}static filterComment(t){let e="",r=!0,a=!0;for(let i=0;i<t.length;){let o=r?t.indexOf("//",i):-1,l=a?t.indexOf("/*",i):-1;if(o==-1&&l==-1){e+=t.substring(i);break}r=o!=-1,a=l!=-1,o!=-1&&l!=-1&&(o<l?l=-1:o=-1),o!=-1?(l=t.indexOf(`
`,o),e+=t.substring(i,o),i=l!=-1?l:t.length):l!=-1&&(o=t.indexOf("*/",l),e+=t.substring(i,l),i=o+2)}return e}static extract(t,e,r){let a=t.indexOf(e)+e.length,i=t.indexOf(r,a);return t.substring(a,i).trim()}}class Bs{constructor(){s(this,"includeMap",new Map)}}const Gr=class Gr{constructor(){s(this,"attributes",[]);s(this,"vs_variables",[]);s(this,"fs_variables",[]);s(this,"cs_variables",[]);s(this,"groups",[]);s(this,"variables",{});s(this,"useSplit",!1)}static parser(t,e){e.shaderReflection||(e.shaderReflection=new Gr),t.indexOf("@vertex")!=-1?(e.shaderReflection.attributes=this.parserVertexOld(t),e.shaderReflection.vs_variables=this.parserVariables(t)):t.indexOf("@fragment")!=-1?e.shaderReflection.fs_variables=this.parserVariables(t):t.indexOf("@compute")!=-1&&(e.shaderReflection.cs_variables=this.parserVariables(t))}static parser2(t,e){e.shaderReflection||(e.shaderReflection=new Gr);let r=e.shaderReflection;t.indexOf("@vertex")!=-1?(r.attributes=this.parserVertex(e.vsEntryPoint,t),r.vs_variables=this.parserVariables(t)):t.indexOf("@fragment")!=-1?r.fs_variables=this.parserVariables(t):t.indexOf("@compute")!=-1&&(r.cs_variables=this.parserVariables(t)),t.indexOf("splitTexture")!=-1&&(r.useSplit=!0)}static combineShaderReflectionVarInfo(t,e){for(const r of e){t.groups[r.group]||(t.groups[r.group]=[]);let a=r;if(t.groups[r.group][r.binding]){let i=t.groups[r.group][r.binding],o=r;if(i.dataFields)for(let l=0;l<i.dataFields.length;l++)i.dataFields[l];if(o.dataFields)for(let l=0;l<o.dataFields.length;l++)o.dataFields[l]}t.groups[r.group][r.binding]=a,t.variables[r.varName]=a}}static final(t){let e=t.shaderReflection;this._shaderReflectionMap.set(t.shaderVariant,e),this.combineShaderReflectionVarInfo(e,e.vs_variables),this.combineShaderReflectionVarInfo(e,e.fs_variables)}static getShaderReflection2(t,e){let r=Rr.parse(t,e.defineValue);Gr.parser2(r,e)}static poolGetReflection(t){return this._shaderReflectionMap.get(t)}static genShaderVar(t){let e=`${t.vs}${t.fs}${t.compute}`;e+="|";for(const r in t.uniforms)e+=r+":";e+="|";for(const r in t.constValues)e+=r+":",e+=t.constValues[r];e+="|";for(const r in t.defines)e+=r+":",e+=t.defines[r];e+="|";for(const r in t.shaderState)e+=r+":",e+=t.shaderState[r]+";";return e}static genShaderVariant(t){let e="";for(const r in t.uniforms)e+=r+":";e+="|";for(const r in t.constValues)e+=r+":",e+=t.constValues[r];e+="|";for(const r in t.defineValue)e+=r+":",e+=t.defineValue[r];return e}static genRenderShaderVariant(t){let e=`RenderShader(${t.vsName},${t.fsName})`;e+="|",e+=this.genShaderVariant(t),e+="|";for(const r in t.shaderState)e+=r+":",e+=t.shaderState[r]+";";return e}static genComputeShaderVariant(t){let e=`ComputeShader(${t.instanceID})`;return e+="|",e+=this.genShaderVariant(t),e}combine(t){let e=t.shaderReflection,r=t.defines,a={};for(let o=0;o<this.attributes.length;o++){let l=this.attributes[o];r[l.name]&&(a[l.name]=l)}let i=e.attributes.length;for(let o=0;o<i;o++){const l=e.attributes[o];if(!a[l.name])this.attributes.push(l);else{let h=a[l.name];h.location==l.location&&h.name!=l.name&&console.log("location must same!")}}}static parserVariables(t){let e=0,r=[];for(;e<t.length;){let a=t.indexOf("@group(",e);if(a<0)break;let i=t.indexOf(";",a);e=i;let o=t.substring(a,i),l=this.extract(o,"@group(",")"),h=this.extract(o,"@binding(",")"),c="",u="var";o.indexOf("var<")!=-1?(c=this.extract(o,">",":"),u=this.extract(o,"var<",">").replace(",","-").replaceAll(" ","")):c=this.extract(o,"var",":");let d=o.substring(o.lastIndexOf(":")+1).trim(),f={group:0,binding:0,varType:"",varName:"",dataType:"",dataIsBuiltinType:!0,dataFields:null};f.group=Number.parseInt(l),f.binding=Number.parseInt(h),f.varType=u,f.varName=c,f.dataType=d,f.dataIsBuiltinType=this.isBuiltinTypes(f.dataType),f.dataIsBuiltinType||(f.dataFields=this.parserStructFields(t,f.dataType)),r.push(f)}return r}static extract(t,e,r){let a=t.indexOf(e)+e.length,i=t.indexOf(r,a);return t.substring(a,i).trim()}static isBuiltinTypes(t){switch(t){case"i32":return!0;case"u32":return!0;case"f32":return!0;default:let e=t.indexOf("<");if(e!=-1)switch(t.substring(0,e)){case"vec2":return!0;case"vec3":return!0;case"vec4":return!0;case"mat3":return!0;case"mat4":return!0;case"array":return this.isBuiltinTypes(t.substring(e+1,t.lastIndexOf(">")))}break}return!1}static parserStructFields(t,e){let r=[],a=0;for(;a<t.length;){let i=t.indexOf("struct ",a);if(i<0)break;let o=t.indexOf("{",i);if(a=o,t.substring(i+6,o).trim()===e){i=t.indexOf("{",i),o=t.indexOf("}",i);let l=t.substring(i+1,o).split(",");for(let h of l){let c=h.indexOf(":");if(c!=-1){let u={name:h.substring(0,c).trim(),type:h.substring(c+1).trim()};r.push(u)}}break}}return r}static parserVertexOld(t){let e=[],r=t.split("fn main(")[1].split("->")[0],a=r.split("@");if(a&&a.length>1)for(let o=1;o<a.length;o++){let l=a[o].replace(/\s*$/g,"");l=l.replaceAll(",",""),l=l.replaceAll(`
`,""),l=l.replaceAll("  "," "),this.parserAttribute(l,e)}else{var i=r.split(":")[1];i=i.replaceAll("  ",""),i=i.replaceAll(" ",""),i=i.replaceAll(")",""),i=t.split(`struct ${i}`)[1];let o=i.indexOf("{"),l=i.indexOf("}");i=i.slice(o,l),a=i.split("@");for(let h=1;h<a.length;h++){let c=a[h].replace(/\s*$/g,"");c=c.replaceAll(`
`,""),c=c.split(",")[0],c=c.replaceAll("  "," "),this.parserAttribute(c,e)}}return e}static parserVertex(t,e){let r=[],a=e.split(`fn ${t}(`)[1].split("->")[0],i=a.split("@");if(i&&i.length>1)for(let l=1;l<i.length;l++){let h=i[l].replace(/\s*$/g,"");h=h.replaceAll(",",""),h=h.replaceAll(`
`,""),h=h.replaceAll("  "," "),this.parserAttribute(h,r)}else{var o=a.split(":")[1];o=o.replaceAll("  ",""),o=o.replaceAll(" ",""),o=o.replaceAll(")",""),o=e.split(`struct ${o}`)[1];let l=o.indexOf("{"),h=o.indexOf("}");o=o.slice(l,h),i=o.split("@");for(let c=1;c<i.length;c++){let u=i[c].replace(/\s*$/g,"");u=u.replaceAll(`
`,""),u=u.split(",")[0],u=u.replaceAll("  "," "),this.parserAttribute(u,r)}}return r}static parserAttribute(t,e){let r={name:"",group:0,location:0,type:"",valueType:"",value:0,size:0,format:"float32"};if(t.indexOf("builtin")!=-1){r.type="builtin";var a=t.match(/\((.+?)\)/g)[0];a=t.match(/\((.+?)\)/g)[0],a=a.replace("(",""),a=a.replaceAll(")",""),r.location=parseInt(a);let i=t.split(":");r.name=i[0].split(" ")[1],r.name=r.name.replaceAll("  "," "),r.name=r.name.replaceAll(" ",""),r.valueType=i[1],r.valueType=r.valueType.replaceAll("  "," "),r.valueType=r.valueType.replaceAll(" ",""),r.valueType=r.valueType.replaceAll("\r",""),r.valueType=r.valueType.replaceAll(")",""),r.valueType=r.valueType.replaceAll(")",""),r.size=_r[r.valueType],e.push(r)}else if(t.indexOf("location")!=-1){r.type="location";var a=t.match(/\((.+?)\)/g)[0];a=t.match(/\((.+?)\)/g)[0],a=a.replace("(",""),a=a.replaceAll(")",""),r.location=parseInt(a);let o=t.split(":");r.name=o[0].split(" ")[1],r.name=r.name.replaceAll("  "," "),r.name=r.name.replaceAll(" ",""),r.valueType=o[1],r.valueType=r.valueType.replaceAll("  "," "),r.valueType=r.valueType.replaceAll(" ",""),r.valueType=r.valueType.replaceAll("\r",""),r.valueType=r.valueType.replaceAll(")",""),r.valueType=r.valueType.replaceAll(")",""),r.size=_r[r.valueType],e.push(r)}r.format=So[_r[r.valueType]]}};s(Gr,"_shaderReflectionMap",new Map);let ht=Gr;class bt extends en{constructor(e){super();s(this,"entryPoint","CsMain");s(this,"workerSizeX",1);s(this,"workerSizeY",0);s(this,"workerSizeZ",0);s(this,"_computePipeline");s(this,"_csShaderModule");s(this,"_destCS");s(this,"_sourceCS");s(this,"_storageTextureDic");s(this,"_sampleTextureDic");s(this,"_groupsShaderReflectionVarInfos");s(this,"_groupCache",{});this._sourceCS=e,ht.getShaderReflection2(e,this),this._storageTextureDic=new Map,this._sampleTextureDic=new Map}setStorageTexture(e,r){this._storageTextureDic.has(e)||this._storageTextureDic.set(e,r)}setSamplerTexture(e,r){this._sampleTextureDic.set(e,r)}compute(e){this._computePipeline||this.genComputePipeline(),e.setPipeline(this._computePipeline);for(let r=0;r<this.bindGroups.length;++r)e.setBindGroup(r,this.bindGroups[r]);this.workerSizeX&&this.workerSizeY&&this.workerSizeZ?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY,this.workerSizeZ):this.workerSizeX&&this.workerSizeY?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY):e.dispatchWorkgroups(this.workerSizeX)}createBufferBindGroup(e,r,a,i){let o=this._bufferDic.get(r);if(o){let l={binding:a,resource:{buffer:o.buffer,offset:0,size:o.memory.shareDataBuffer.byteLength}};i.push(l)}else console.error(`ComputeShader(${this.instanceID})`,`buffer ${r} is missing!`)}noticeBufferChange(e){let r=this._groupCache[e];r&&this.genGroups(r.groupIndex,r.infos,!0)}genGroups(e,r,a=!1){if(!this.bindGroups[e]||a){const i=r[e];let o=[];for(let h=0;h<i.length;++h){const c=i[h];if(c)switch(c.varType){case"uniform":case"storage-read":case"storage-read_write":this.createBufferBindGroup(e,c.varName,c.binding,o),this._groupCache[c.varName]={groupIndex:e,infos:r};break;case"var":if(c.dataType=="sampler"){let u=c.varName.replace("Sampler",""),d=this._sampleTextureDic.get(u);if(d){let f={binding:c.binding,resource:d.gpuSampler};o.push(f)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${c.varName} is missing! `)}else if(c.dataType=="sampler_comparison"){let u=c.varName.replace("Sampler",""),d=this._sampleTextureDic.get(u);if(d){let f={binding:c.binding,resource:d.gpuSampler_comparison};o.push(f)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${c.varName} is missing! `)}else if(c.dataType.indexOf("texture_storage")!=-1){let u=this._storageTextureDic.get(c.varName);if(u){let d={binding:c.binding,resource:u.getGPUView()};o.push(d),ae.getInstance().attached(u,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${c.varName} is missing! `)}else if(c.dataType.indexOf("texture")!=-1){let u=this._sampleTextureDic.get(c.varName);if(u){let d={binding:c.binding,resource:u.getGPUView()};o.push(d),ae.getInstance().attached(u,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${c.varName} is missing! `)}break;default:console.error("unprocessed type:",c.varType);break}}let l=R.device.createBindGroup({layout:this._computePipeline.getBindGroupLayout(e),entries:o});this.bindGroups[e]=l}}genComputePipeline(){this.preCompileShader(this._sourceCS),this.genReflection(),this._computePipeline=R.device.createComputePipeline({layout:"auto",compute:{module:this.compileShader(),entryPoint:this.entryPoint}}),this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroups=[];for(let r=0;r<e.groups.length;++r){let a=e.groups[r];this._groupsShaderReflectionVarInfos[r]=a,this.genGroups(r,this._groupsShaderReflectionVarInfos)}R.addEventListener(pr.RESIZE,r=>{for(let a=0;a<e.groups.length;++a){let i=e.groups[a];this._groupsShaderReflectionVarInfos[a]=i,this.genGroups(a,this._groupsShaderReflectionVarInfos,!0)}},this)}preCompileShader(e){for(const r in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,r)){const a=this.constValues[r];e=e.replaceAll(`&${r}`,a.toString())}this._destCS=Rr.parseComputeShader(e,this.defineValue)}compileShader(){let e=R.device.createShaderModule({label:`ComputeShader(${this.instanceID})`,code:this._destCS});return e.getCompilationInfo().then(r=>{r.messages.length>0&&console.warn("[shader error]",r,this._destCS)}),this._csShaderModule=e,e}genReflection(){this.shaderVariant+=ht.genComputeShaderVariant(this);let e=ht.poolGetReflection(this.shaderVariant);e?this.shaderReflection=e:(ht.getShaderReflection2(this._destCS,this),ht.combineShaderReflectionVarInfo(this.shaderReflection,this.shaderReflection.cs_variables))}}var W=(n=>(n[n.COLOR=1]="COLOR",n[n.REFLECTION=2]="REFLECTION",n[n.POSITION=4]="POSITION",n[n.GRAPHIC=8]="GRAPHIC",n[n.GI=16]="GI",n[n.Cluster=32]="Cluster",n[n.SHADOW=64]="SHADOW",n[n.POINT_SHADOW=128]="POINT_SHADOW",n[n.POST=256]="POST",n[n.DEPTH=512]="DEPTH",n[n.UI=1024]="UI",n))(W||{});class ve{static startView(t){let e=this.viewMap.get(t);if(!e){e={};for(const r in W)parseInt(r)>=0||(e[r]={vertexCount:0,indicesCount:0,instanceCount:0,triCount:0,drawCount:0,pipelineCount:0});this.viewMap.set(t,e)}for(const r in W)parseInt(r)>=0||(e[r].vertexCount=0,e[r].indicesCount=0,e[r].triCount=0,e[r].instanceCount=0,e[r].drawCount=0,e[r].pipelineCount=0)}static viewCount(t){return this.startView(t),this.viewMap.get(t)}static viewCount_vertex(t,e,r){this.viewMap.get(t)[e].vertexCount+=r}static viewCount_indices(t,e,r){this.viewMap.get(t)[e].indicesCount+=r}static viewCount_tri(t,e,r){this.viewMap.get(t)[e].triCount+=r}static viewCount_instance(t,e,r){this.viewMap.get(t)[e].instanceCount+=r}static viewCount_draw(t,e){this.viewMap.get(t)[e].drawCount++}static viewCount_pipeline(t,e){this.viewMap.get(t)[e].pipelineCount++}static start(t){let e=this.profilerLabelMap.get(t);e||(e={lable:t,start:0,end:0,total:0,count:0,child:new Map},this.profilerLabelMap.set(t,e)),e.start=performance.now(),e.end=performance.now(),e.count=0,e.child.clear()}static end(t){let e=this.profilerLabelMap.get(t);e&&(e.end=performance.now(),e.total=e.end-e.start)}static countStart(t,e=""){let r=this.profilerLabelMap.get(t);if(r&&(r.count++,e!="")){let a=r.child.get(e);a||(a={lable:e,start:0,end:0,total:0,count:0}),a.start=performance.now(),a.end=performance.now(),a.count=0,r.child.set(e,a)}}static countEnd(t,e){let r=this.profilerLabelMap.get(t);if(r&&e!=""){let a=r.child.get(e);a||(a={lable:e,start:0,end:0,total:0,count:0}),a.end=performance.now(),a.total=a.end-a.start,a.count++}}static print(t){let e=this.profilerLabelMap.get(t);e&&console.log("performance",t,e.total+" ms")}}s(ve,"profilerLabelMap",new Map),s(ve,"viewMap",new Map),s(ve,"testObj",{testValue1:0,testValue2:0,testValue3:0,testValue4:0});var El=(()=>{var n=import.meta.url;return async function(t={}){var e=t,r,a;e.ready=new Promise((E,I)=>{r=E,a=I});var i=Object.assign({},e),o=[],l="./this.program",h=(E,I)=>{throw I},c=typeof window=="object",u=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f="";function A(E){return e.locateFile?e.locateFile(E,f):f+E}var p,B;if(d){const{createRequire:E}=await Promise.resolve().then(()=>Od);var F=E(import.meta.url),U=F("fs"),Q=F("path");u?f=Q.dirname(f)+"/":f=F("url").fileURLToPath(new URL("data:text/javascript;base64,CnZhciBNb2R1bGUgPSAoKCkgPT4gewogIHZhciBfc2NyaXB0RGlyID0gaW1wb3J0Lm1ldGEudXJsOwogIAogIHJldHVybiAoCmFzeW5jIGZ1bmN0aW9uKG1vZHVsZUFyZyA9IHt9KSB7Cgp2YXIgTW9kdWxlPW1vZHVsZUFyZzt2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSxyZWFkeVByb21pc2VSZWplY3Q7TW9kdWxlWyJyZWFkeSJdPW5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntyZWFkeVByb21pc2VSZXNvbHZlPXJlc29sdmU7cmVhZHlQcm9taXNlUmVqZWN0PXJlamVjdH0pO3ZhciBtb2R1bGVPdmVycmlkZXM9T2JqZWN0LmFzc2lnbih7fSxNb2R1bGUpO3ZhciBhcmd1bWVudHNfPVtdO3ZhciB0aGlzUHJvZ3JhbT0iLi90aGlzLnByb2dyYW0iO3ZhciBxdWl0Xz0oc3RhdHVzLHRvVGhyb3cpPT57dGhyb3cgdG9UaHJvd307dmFyIEVOVklST05NRU5UX0lTX1dFQj10eXBlb2Ygd2luZG93PT0ib2JqZWN0Ijt2YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT0iZnVuY3Rpb24iO3ZhciBFTlZJUk9OTUVOVF9JU19OT0RFPXR5cGVvZiBwcm9jZXNzPT0ib2JqZWN0IiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PSJvYmplY3QiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT0ic3RyaW5nIjt2YXIgc2NyaXB0RGlyZWN0b3J5PSIiO2Z1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCl7aWYoTW9kdWxlWyJsb2NhdGVGaWxlIl0pe3JldHVybiBNb2R1bGVbImxvY2F0ZUZpbGUiXShwYXRoLHNjcmlwdERpcmVjdG9yeSl9cmV0dXJuIHNjcmlwdERpcmVjdG9yeStwYXRofXZhciByZWFkXyxyZWFkQXN5bmMscmVhZEJpbmFyeTtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXtjb25zdHtjcmVhdGVSZXF1aXJlOmNyZWF0ZVJlcXVpcmV9PWF3YWl0IGltcG9ydCgibW9kdWxlIik7dmFyIHJlcXVpcmU9Y3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO3ZhciBmcz1yZXF1aXJlKCJmcyIpO3ZhciBub2RlUGF0aD1yZXF1aXJlKCJwYXRoIik7aWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtzY3JpcHREaXJlY3Rvcnk9bm9kZVBhdGguZGlybmFtZShzY3JpcHREaXJlY3RvcnkpKyIvIn1lbHNle3NjcmlwdERpcmVjdG9yeT1yZXF1aXJlKCJ1cmwiKS5maWxlVVJMVG9QYXRoKG5ldyBVUkwoIi4vIixpbXBvcnQubWV0YS51cmwpKX1yZWFkXz0oZmlsZW5hbWUsYmluYXJ5KT0+e2ZpbGVuYW1lPWlzRmlsZVVSSShmaWxlbmFtZSk/bmV3IFVSTChmaWxlbmFtZSk6bm9kZVBhdGgubm9ybWFsaXplKGZpbGVuYW1lKTtyZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLGJpbmFyeT91bmRlZmluZWQ6InV0ZjgiKX07cmVhZEJpbmFyeT1maWxlbmFtZT0+e3ZhciByZXQ9cmVhZF8oZmlsZW5hbWUsdHJ1ZSk7aWYoIXJldC5idWZmZXIpe3JldD1uZXcgVWludDhBcnJheShyZXQpfXJldHVybiByZXR9O3JlYWRBc3luYz0oZmlsZW5hbWUsb25sb2FkLG9uZXJyb3IsYmluYXJ5PXRydWUpPT57ZmlsZW5hbWU9aXNGaWxlVVJJKGZpbGVuYW1lKT9uZXcgVVJMKGZpbGVuYW1lKTpub2RlUGF0aC5ub3JtYWxpemUoZmlsZW5hbWUpO2ZzLnJlYWRGaWxlKGZpbGVuYW1lLGJpbmFyeT91bmRlZmluZWQ6InV0ZjgiLChlcnIsZGF0YSk9PntpZihlcnIpb25lcnJvcihlcnIpO2Vsc2Ugb25sb2FkKGJpbmFyeT9kYXRhLmJ1ZmZlcjpkYXRhKX0pfTtpZighTW9kdWxlWyJ0aGlzUHJvZ3JhbSJdJiZwcm9jZXNzLmFyZ3YubGVuZ3RoPjEpe3RoaXNQcm9ncmFtPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXC9nLCIvIil9YXJndW1lbnRzXz1wcm9jZXNzLmFyZ3Yuc2xpY2UoMik7cXVpdF89KHN0YXR1cyx0b1Rocm93KT0+e3Byb2Nlc3MuZXhpdENvZGU9c3RhdHVzO3Rocm93IHRvVGhyb3d9fWVsc2UgaWYoRU5WSVJPTk1FTlRfSVNfV0VCfHxFTlZJUk9OTUVOVF9JU19XT1JLRVIpe2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7c2NyaXB0RGlyZWN0b3J5PXNlbGYubG9jYXRpb24uaHJlZn1lbHNlIGlmKHR5cGVvZiBkb2N1bWVudCE9InVuZGVmaW5lZCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3NjcmlwdERpcmVjdG9yeT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY31pZihfc2NyaXB0RGlyKXtzY3JpcHREaXJlY3Rvcnk9X3NjcmlwdERpcn1pZihzY3JpcHREaXJlY3Rvcnkuc3RhcnRzV2l0aCgiYmxvYjoiKSl7c2NyaXB0RGlyZWN0b3J5PSIifWVsc2V7c2NyaXB0RGlyZWN0b3J5PXNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCxzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLywiIikubGFzdEluZGV4T2YoIi8iKSsxKX17cmVhZF89dXJsPT57dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oIkdFVCIsdXJsLGZhbHNlKTt4aHIuc2VuZChudWxsKTtyZXR1cm4geGhyLnJlc3BvbnNlVGV4dH07aWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtyZWFkQmluYXJ5PXVybD0+e3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKCJHRVQiLHVybCxmYWxzZSk7eGhyLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO3hoci5zZW5kKG51bGwpO3JldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpfX1yZWFkQXN5bmM9KHVybCxvbmxvYWQsb25lcnJvcik9Pnt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbigiR0VUIix1cmwsdHJ1ZSk7eGhyLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO3hoci5vbmxvYWQ9KCk9PntpZih4aHIuc3RhdHVzPT0yMDB8fHhoci5zdGF0dXM9PTAmJnhoci5yZXNwb25zZSl7b25sb2FkKHhoci5yZXNwb25zZSk7cmV0dXJufW9uZXJyb3IoKX07eGhyLm9uZXJyb3I9b25lcnJvcjt4aHIuc2VuZChudWxsKX19fWVsc2V7fXZhciBvdXQ9TW9kdWxlWyJwcmludCJdfHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO3ZhciBlcnI9TW9kdWxlWyJwcmludEVyciJdfHxjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihNb2R1bGUsbW9kdWxlT3ZlcnJpZGVzKTttb2R1bGVPdmVycmlkZXM9bnVsbDtpZihNb2R1bGVbImFyZ3VtZW50cyJdKWFyZ3VtZW50c189TW9kdWxlWyJhcmd1bWVudHMiXTtpZihNb2R1bGVbInRoaXNQcm9ncmFtIl0pdGhpc1Byb2dyYW09TW9kdWxlWyJ0aGlzUHJvZ3JhbSJdO2lmKE1vZHVsZVsicXVpdCJdKXF1aXRfPU1vZHVsZVsicXVpdCJdO3ZhciB3YXNtQmluYXJ5O2lmKE1vZHVsZVsid2FzbUJpbmFyeSJdKXdhc21CaW5hcnk9TW9kdWxlWyJ3YXNtQmluYXJ5Il07ZnVuY3Rpb24gaW50QXJyYXlGcm9tQmFzZTY0KHMpe2lmKHR5cGVvZiBFTlZJUk9OTUVOVF9JU19OT0RFIT0idW5kZWZpbmVkIiYmRU5WSVJPTk1FTlRfSVNfTk9ERSl7dmFyIGJ1Zj1CdWZmZXIuZnJvbShzLCJiYXNlNjQiKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlcixidWYuYnl0ZU9mZnNldCxidWYubGVuZ3RoKX12YXIgZGVjb2RlZD1hdG9iKHMpO3ZhciBieXRlcz1uZXcgVWludDhBcnJheShkZWNvZGVkLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxkZWNvZGVkLmxlbmd0aDsrK2kpe2J5dGVzW2ldPWRlY29kZWQuY2hhckNvZGVBdChpKX1yZXR1cm4gYnl0ZXN9ZnVuY3Rpb24gdHJ5UGFyc2VBc0RhdGFVUkkoZmlsZW5hbWUpe2lmKCFpc0RhdGFVUkkoZmlsZW5hbWUpKXtyZXR1cm59cmV0dXJuIGludEFycmF5RnJvbUJhc2U2NChmaWxlbmFtZS5zbGljZShkYXRhVVJJUHJlZml4Lmxlbmd0aCkpfXZhciB3YXNtTWVtb3J5O3ZhciBBQk9SVD1mYWxzZTt2YXIgRVhJVFNUQVRVUzt2YXIgSEVBUDgsSEVBUFU4LEhFQVAxNixIRUFQVTE2LEhFQVAzMixIRUFQVTMyLEhFQVBGMzIsSEVBUEY2NDtmdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpe3ZhciBiPXdhc21NZW1vcnkuYnVmZmVyO01vZHVsZVsiSEVBUDgiXT1IRUFQOD1uZXcgSW50OEFycmF5KGIpO01vZHVsZVsiSEVBUDE2Il09SEVBUDE2PW5ldyBJbnQxNkFycmF5KGIpO01vZHVsZVsiSEVBUFU4Il09SEVBUFU4PW5ldyBVaW50OEFycmF5KGIpO01vZHVsZVsiSEVBUFUxNiJdPUhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGIpO01vZHVsZVsiSEVBUDMyIl09SEVBUDMyPW5ldyBJbnQzMkFycmF5KGIpO01vZHVsZVsiSEVBUFUzMiJdPUhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KGIpO01vZHVsZVsiSEVBUEYzMiJdPUhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShiKTtNb2R1bGVbIkhFQVBGNjQiXT1IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoYil9dmFyIF9fQVRQUkVSVU5fXz1bXTt2YXIgX19BVElOSVRfXz1bXTt2YXIgX19BVE1BSU5fXz1bXTt2YXIgX19BVFBPU1RSVU5fXz1bXTt2YXIgcnVudGltZUluaXRpYWxpemVkPWZhbHNlO2Z1bmN0aW9uIHByZVJ1bigpe2lmKE1vZHVsZVsicHJlUnVuIl0pe2lmKHR5cGVvZiBNb2R1bGVbInByZVJ1biJdPT0iZnVuY3Rpb24iKU1vZHVsZVsicHJlUnVuIl09W01vZHVsZVsicHJlUnVuIl1dO3doaWxlKE1vZHVsZVsicHJlUnVuIl0ubGVuZ3RoKXthZGRPblByZVJ1bihNb2R1bGVbInByZVJ1biJdLnNoaWZ0KCkpfX1jYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pfWZ1bmN0aW9uIGluaXRSdW50aW1lKCl7cnVudGltZUluaXRpYWxpemVkPXRydWU7Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyl9ZnVuY3Rpb24gcHJlTWFpbigpe2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRNQUlOX18pfWZ1bmN0aW9uIHBvc3RSdW4oKXtpZihNb2R1bGVbInBvc3RSdW4iXSl7aWYodHlwZW9mIE1vZHVsZVsicG9zdFJ1biJdPT0iZnVuY3Rpb24iKU1vZHVsZVsicG9zdFJ1biJdPVtNb2R1bGVbInBvc3RSdW4iXV07d2hpbGUoTW9kdWxlWyJwb3N0UnVuIl0ubGVuZ3RoKXthZGRPblBvc3RSdW4oTW9kdWxlWyJwb3N0UnVuIl0uc2hpZnQoKSl9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pfWZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKXtfX0FUUFJFUlVOX18udW5zaGlmdChjYil9ZnVuY3Rpb24gYWRkT25Jbml0KGNiKXtfX0FUSU5JVF9fLnVuc2hpZnQoY2IpfWZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYil7X19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKX12YXIgcnVuRGVwZW5kZW5jaWVzPTA7dmFyIHJ1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGw7dmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2Z1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcysrO01vZHVsZVsibW9uaXRvclJ1bkRlcGVuZGVuY2llcyJdPy4ocnVuRGVwZW5kZW5jaWVzKX1mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMtLTtNb2R1bGVbIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiXT8uKHJ1bkRlcGVuZGVuY2llcyk7aWYocnVuRGVwZW5kZW5jaWVzPT0wKXtpZihydW5EZXBlbmRlbmN5V2F0Y2hlciE9PW51bGwpe2NsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO3J1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGx9aWYoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKXt2YXIgY2FsbGJhY2s9ZGVwZW5kZW5jaWVzRnVsZmlsbGVkO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2NhbGxiYWNrKCl9fX1mdW5jdGlvbiBhYm9ydCh3aGF0KXtNb2R1bGVbIm9uQWJvcnQiXT8uKHdoYXQpO3doYXQ9IkFib3J0ZWQoIit3aGF0KyIpIjtlcnIod2hhdCk7QUJPUlQ9dHJ1ZTtFWElUU1RBVFVTPTE7d2hhdCs9Ii4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby4iO3ZhciBlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7cmVhZHlQcm9taXNlUmVqZWN0KGUpO3Rocm93IGV9dmFyIGRhdGFVUklQcmVmaXg9ImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwiO3ZhciBpc0RhdGFVUkk9ZmlsZW5hbWU9PmZpbGVuYW1lLnN0YXJ0c1dpdGgoZGF0YVVSSVByZWZpeCk7dmFyIGlzRmlsZVVSST1maWxlbmFtZT0+ZmlsZW5hbWUuc3RhcnRzV2l0aCgiZmlsZTovLyIpO3ZhciB3YXNtQmluYXJ5RmlsZTt3YXNtQmluYXJ5RmlsZT0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LEFHRnpiUUVBQUFBQnBBRWFZQUYvQVg5Z0FuOS9BR0FEZjM5L0FYOWdBMzkvZndCZ0FYOEFZQUFBWUFWL2YzOS9md0JnQkg5L2YzOEFZQUovZndGL1lBWi9mMzkvZjM4QVlBQUJmMkFFZjM5L2ZRQmdCSDkvZjM4QmYyQUJmQUY5WUFKOGZ3RjhZQUY5QVgxZ0FYd0JmR0FDZm44QmYyQURmSHgvQVh4Z0FueDhBWHhnQm45OGYzOS9md0YvWUFKOWZ3Ri9ZQUo4ZndGL1lBVi9mMzkvZndGL1lBTi9mbjhCZm1BRGYzOTlBQUlmQlFGaEFXRUFEQUZoQVdJQUF3RmhBV01BQlFGaEFXUUFBQUZoQVdVQUF3TllWd01HQWcwTkFnQUVBQkVFRWhNRkJRNENCQThRQWdBUEVBVUVBQWNEQ0FBQUFBZ1VBd0FNRGdBRUJCVVdGd0VJQVFnQkFBQUFBQUVCQkFBQUFBQUFDZ0FKQ1FZR0J3Y0tBZ29LR0FBQ0JBc0JBd3NCQXdnWkF3UUZBWEFCTEN3RkJ3RUJnZ0tBZ0FJR0NBRi9BVUh3dUFRTEJ6a09BV1lDQUFGbkFCMEJhQUJiQVdrQVVnRnFBRTRCYXdCTkFXd0FTd0Z0QUVNQmJnQTlBVzhBV2dGd0FGa0JjUUVBQVhJQVBnRnpBRVFKTVFFQVFRRUxLeU1mV0RZNk9UZzNWMVpWTWpvNU9EZFVVMUJSVHljakR5MHRURVZIU2c5R1NFa1BRUTlBRDBJZVB4NEtpdnNCVnhjQUlBQXRBQUJCSUhGRkJFQWdBU0FDSUFBUUdSb0xDMnNCQVg4akFFR0FBbXNpQlNRQUFrQWdBaUFEVEEwQUlBUkJnTUFFY1EwQUlBVWdBU0FDSUFOcklnTkJnQUlnQTBHQUFra2lBUnNRQnhvZ0FVVUVRQU5BSUFBZ0JVR0FBaEFGSUFOQmdBSnJJZ05CL3dGTERRQUxDeUFBSUFVZ0F4QUZDeUFGUVlBQ2FpUUFDL0lDQWdKL0FYNENRQ0FDUlEwQUlBQWdBVG9BQUNBQUlBSnFJZ05CQVdzZ0FUb0FBQ0FDUVFOSkRRQWdBQ0FCT2dBQ0lBQWdBVG9BQVNBRFFRTnJJQUU2QUFBZ0EwRUNheUFCT2dBQUlBSkJCMGtOQUNBQUlBRTZBQU1nQTBFRWF5QUJPZ0FBSUFKQkNVa05BQ0FBUVFBZ0FHdEJBM0VpQkdvaUF5QUJRZjhCY1VHQmdvUUliQ0lCTmdJQUlBTWdBaUFFYTBGOGNTSUVhaUlDUVFScklBRTJBZ0FnQkVFSlNRMEFJQU1nQVRZQ0NDQURJQUUyQWdRZ0FrRUlheUFCTmdJQUlBSkJER3NnQVRZQ0FDQUVRUmxKRFFBZ0F5QUJOZ0lZSUFNZ0FUWUNGQ0FESUFFMkFoQWdBeUFCTmdJTUlBSkJFR3NnQVRZQ0FDQUNRUlJySUFFMkFnQWdBa0VZYXlBQk5nSUFJQUpCSEdzZ0FUWUNBQ0FFSUFOQkJIRkJHSElpQkdzaUFrRWdTUTBBSUFHdFFvR0FnSUFRZmlFRklBTWdCR29oQVFOQUlBRWdCVGNER0NBQklBVTNBeEFnQVNBRk53TUlJQUVnQlRjREFDQUJRU0JxSVFFZ0FrRWdheUlDUVI5TERRQUxDeUFBQzBzQkFud2dBQ0FBb2lJQklBQ2lJZ0lnQVNBQm9xSWdBVVNuUmp1TWg4M0dQcUpFZE9mSzR2a0FLcitnb2lBQ0lBRkVzdnR1aVJBUmdUK2lSSGVzeTFSVlZjVy9vS0lnQUtDZ3RndFBBUUY4SUFBZ0FLSWlBQ0FBSUFDaUlnR2lJQUJFYVZEdTRFS1QrVDZpUkNjZUQraUh3RmEvb0tJZ0FVUkNPZ1hoVTFXbFA2SWdBRVNCWGd6OS8vL2Z2NkpFQUFBQUFBQUE4RCtnb0tDMkMzUUJBWDhnQWtVRVFDQUFLQUlFSUFFb0FnUkdEd3NnQUNBQlJnUkFRUUVQQ3lBQktBSUVJZ0l0QUFBaEFRSkFJQUFvQWdRaUF5MEFBQ0lBUlEwQUlBQWdBVWNOQUFOQUlBSXRBQUVoQVNBRExRQUJJZ0JGRFFFZ0FrRUJhaUVDSUFOQkFXb2hBeUFBSUFGR0RRQUxDeUFBSUFGR0N6VUJBWDlCQVNBQUlBQkJBVTBiSVFBQ1FBTkFJQUFRSlNJQkRRRkI2RGdvQWdBaUFRUkFJQUVSQlFBTUFRc0xFQUlBQ3lBQkM5a0xBUWQvQWtBZ0FFVU5BQ0FBUVFocklnTWdBRUVFYXlnQ0FDSUJRWGh4SWdCcUlRVUNRQ0FCUVFGeERRQWdBVUVDY1VVTkFTQURJQU1vQWdBaUFXc2lBMEdJTlNnQ0FFa05BU0FBSUFGcUlRQUNRQUpBUVl3MUtBSUFJQU5IQkVBZ0F5Z0NEQ0VDSUFGQi93Rk5CRUFnQVVFRGRpRUJJQU1vQWdnaUJDQUNSZ1JBUWZnMFFmZzBLQUlBUVg0Z0FYZHhOZ0lBREFVTElBUWdBallDRENBQ0lBUTJBZ2dNQkFzZ0F5Z0NHQ0VHSUFJZ0EwY0VRQ0FES0FJSUlnRWdBallDRENBQ0lBRTJBZ2dNQXdzZ0F5Z0NGQ0lCQkg4Z0EwRVVhZ1VnQXlnQ0VDSUJSUTBDSUFOQkVHb0xJUVFEUUNBRUlRY2dBU0lDUVJScUlRUWdBaWdDRkNJQkRRQWdBa0VRYWlFRUlBSW9BaEFpQVEwQUN5QUhRUUEyQWdBTUFnc2dCU2dDQkNJQlFRTnhRUU5IRFFKQmdEVWdBRFlDQUNBRklBRkJmbkUyQWdRZ0F5QUFRUUZ5TmdJRUlBVWdBRFlDQUE4TFFRQWhBZ3NnQmtVTkFBSkFJQU1vQWh3aUFVRUNkRUdvTjJvaUJDZ0NBQ0FEUmdSQUlBUWdBallDQUNBQ0RRRkIvRFJCL0RRb0FnQkJmaUFCZDNFMkFnQU1BZ3NnQmtFUVFSUWdCaWdDRUNBRFJodHFJQUkyQWdBZ0FrVU5BUXNnQWlBR05nSVlJQU1vQWhBaUFRUkFJQUlnQVRZQ0VDQUJJQUkyQWhnTElBTW9BaFFpQVVVTkFDQUNJQUUyQWhRZ0FTQUNOZ0lZQ3lBRElBVlBEUUFnQlNnQ0JDSUJRUUZ4UlEwQUFrQUNRQUpBQWtBZ0FVRUNjVVVFUUVHUU5TZ0NBQ0FGUmdSQVFaQTFJQU0yQWdCQmhEVkJoRFVvQWdBZ0FHb2lBRFlDQUNBRElBQkJBWEkyQWdRZ0EwR01OU2dDQUVjTkJrR0FOVUVBTmdJQVFZdzFRUUEyQWdBUEMwR01OU2dDQUNBRlJnUkFRWXcxSUFNMkFnQkJnRFZCZ0RVb0FnQWdBR29pQURZQ0FDQURJQUJCQVhJMkFnUWdBQ0FEYWlBQU5nSUFEd3NnQVVGNGNTQUFhaUVBSUFVb0Fnd2hBaUFCUWY4QlRRUkFJQUZCQTNZaEFTQUZLQUlJSWdRZ0FrWUVRRUg0TkVINE5DZ0NBRUYrSUFGM2NUWUNBQXdGQ3lBRUlBSTJBZ3dnQWlBRU5nSUlEQVFMSUFVb0FoZ2hCaUFDSUFWSEJFQkJpRFVvQWdBYUlBVW9BZ2dpQVNBQ05nSU1JQUlnQVRZQ0NBd0RDeUFGS0FJVUlnRUVmeUFGUVJScUJTQUZLQUlRSWdGRkRRSWdCVUVRYWdzaEJBTkFJQVFoQnlBQklnSkJGR29oQkNBQ0tBSVVJZ0VOQUNBQ1FSQnFJUVFnQWlnQ0VDSUJEUUFMSUFkQkFEWUNBQXdDQ3lBRklBRkJmbkUyQWdRZ0F5QUFRUUZ5TmdJRUlBQWdBMm9nQURZQ0FBd0RDMEVBSVFJTElBWkZEUUFDUUNBRktBSWNJZ0ZCQW5SQnFEZHFJZ1FvQWdBZ0JVWUVRQ0FFSUFJMkFnQWdBZzBCUWZ3MFFmdzBLQUlBUVg0Z0FYZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdCVVliYWlBQ05nSUFJQUpGRFFFTElBSWdCallDR0NBRktBSVFJZ0VFUUNBQ0lBRTJBaEFnQVNBQ05nSVlDeUFGS0FJVUlnRkZEUUFnQWlBQk5nSVVJQUVnQWpZQ0dBc2dBeUFBUVFGeU5nSUVJQUFnQTJvZ0FEWUNBQ0FEUVl3MUtBSUFSdzBBUVlBMUlBQTJBZ0FQQ3lBQVFmOEJUUVJBSUFCQmVIRkJvRFZxSVFFQ2YwSDROQ2dDQUNJRVFRRWdBRUVEZG5RaUFIRkZCRUJCK0RRZ0FDQUVjallDQUNBQkRBRUxJQUVvQWdnTElRQWdBU0FETmdJSUlBQWdBellDRENBRElBRTJBZ3dnQXlBQU5nSUlEd3RCSHlFQ0lBQkIvLy8vQjAwRVFDQUFRU1lnQUVFSWRtY2lBV3QyUVFGeElBRkJBWFJyUVQ1cUlRSUxJQU1nQWpZQ0hDQURRZ0EzQWhBZ0FrRUNkRUdvTjJvaEJ3Si9Ba0FDZjBIOE5DZ0NBQ0lCUVFFZ0FuUWlCSEZGQkVCQi9EUWdBU0FFY2pZQ0FFRVlJUUlnQnlFRVFRZ01BUXNnQUVFWklBSkJBWFpyUVFBZ0FrRWZSeHQwSVFJZ0J5Z0NBQ0VFQTBBZ0JDSUJLQUlFUVhoeElBQkdEUUlnQWtFZGRpRUVJQUpCQVhRaEFpQUJJQVJCQkhGcVFSQnFJZ2NvQWdBaUJBMEFDMEVZSVFJZ0FTRUVRUWdMSVFBZ0F5SUJEQUVMSUFFb0FnZ2lCQ0FETmdJTVFRZ2hBaUFCUVFocUlRZEJHQ0VBUVFBTElRVWdCeUFETmdJQUlBSWdBMm9nQkRZQ0FDQURJQUUyQWd3Z0FDQURhaUFGTmdJQVFaZzFRWmcxS0FJQVFRRnJJZ0JCZnlBQUd6WUNBQXNMVHdFQ2YwR1lLeWdDQUNJQklBQkJCMnBCZUhFaUFtb2hBQUpBSUFKQkFDQUFJQUZORzBVRVFDQUFQd0JCRUhSTkRRRWdBQkFERFFFTFFiZ3pRVEEyQWdCQmZ3OExRWmdySUFBMkFnQWdBUXVEQVFJRmZ3RitBa0FnQUVLQWdJQ0FFRlFFUUNBQUlRY01BUXNEUUNBQlFRRnJJZ0VnQUNBQVFncUFJZ2RDQ241OXAwRXdjam9BQUNBQVF2Ly8vLytmQVZZaEJTQUhJUUFnQlEwQUN3c2dCNmNpQWdSQUEwQWdBVUVCYXlJQklBSWdBa0VLYmlJRFFRcHNhMEV3Y2pvQUFDQUNRUWxMSVFZZ0F5RUNJQVlOQUFzTElBRUxCZ0FnQUJBTUM1a0JBUU44SUFBZ0FLSWlBeUFESUFPaW9pQURSSHpWejFvNjJlVTlva1RybkN1SzV1VmF2cUNpSUFNZ0EwUjkvckZYNHgzSFBxSkUxV0hCR2FBQktyK2dva1NtK0JBUkVSR0JQNkNnSVFVZ0F5QUFvaUVFSUFKRkJFQWdCQ0FESUFXaVJFbFZWVlZWVmNXL29LSWdBS0FQQ3lBQUlBTWdBVVFBQUFBQUFBRGdQNklnQlNBRW9xR2lJQUdoSUFSRVNWVlZWVlZWeFQraW9LRUxrZ0VCQTN4RUFBQUFBQUFBOEQ4Z0FDQUFvaUlDUkFBQUFBQUFBT0Evb2lJRG9TSUVSQUFBQUFBQUFQQS9JQVNoSUFPaElBSWdBaUFDSUFKRWtCWExHYUFCK2o2aVJIZFJ3Ulpzd1ZhL29LSkVURlZWVlZWVnBUK2dvaUFDSUFLaUlnTWdBNklnQWlBQ1JOUTRpTDdwK3FpOW9rVEVzYlM5bnU0aFBxQ2lSSzFTbklCUGZwSytvS0tnb2lBQUlBR2lvYUNnQ3lvQkFYOUJCQkFrSWdCQnBDZzJBZ0FnQUVIOEp6WUNBQ0FBUVpBb05nSUFJQUJCZ0NsQkFSQUJBQXRmQVFOL1FRZ1FKQ0lBUWFRb05nSUFJQUJCbENrMkFnQkJpUWtRTENJQlFRMXFFQXNpQWtFQU5nSUlJQUlnQVRZQ0JDQUNJQUUyQWdBZ0FDQUNRUXhxUVlrSklBRkJBV29RRlRZQ0JDQUFRY1FwTmdJQUlBQkI1Q2xCQWhBQkFBdW9BUUFDUUNBQlFZQUlUZ1JBSUFCRUFBQUFBQUFBNEgraUlRQWdBVUgvRDBrRVFDQUJRZjhIYXlFQkRBSUxJQUJFQUFBQUFBQUE0SCtpSVFCQi9SY2dBU0FCUWYwWFR4dEIvZzlySVFFTUFRc2dBVUdCZUVvTkFDQUFSQUFBQUFBQUFHQURvaUVBSUFGQnVIQkxCRUFnQVVISkIyb2hBUXdCQ3lBQVJBQUFBQUFBQUdBRG9pRUFRZkJvSUFFZ0FVSHdhRTBiUVpJUGFpRUJDeUFBSUFGQi93ZHFyVUkwaHIraUM0QUVBUU4vSUFKQmdBUlBCRUFnQUNBQklBSVFCQ0FBRHdzZ0FDQUNhaUVEQWtBZ0FDQUJjMEVEY1VVRVFBSkFJQUJCQTNGRkJFQWdBQ0VDREFFTElBSkZCRUFnQUNFQ0RBRUxJQUFoQWdOQUlBSWdBUzBBQURvQUFDQUJRUUZxSVFFZ0FrRUJhaUlDUVFOeFJRMEJJQUlnQTBrTkFBc0xBa0FnQTBGOGNTSUVRY0FBU1EwQUlBSWdCRUZBYWlJRlN3MEFBMEFnQWlBQktBSUFOZ0lBSUFJZ0FTZ0NCRFlDQkNBQ0lBRW9BZ2cyQWdnZ0FpQUJLQUlNTmdJTUlBSWdBU2dDRURZQ0VDQUNJQUVvQWhRMkFoUWdBaUFCS0FJWU5nSVlJQUlnQVNnQ0hEWUNIQ0FDSUFFb0FpQTJBaUFnQWlBQktBSWtOZ0lrSUFJZ0FTZ0NLRFlDS0NBQ0lBRW9BaXcyQWl3Z0FpQUJLQUl3TmdJd0lBSWdBU2dDTkRZQ05DQUNJQUVvQWpnMkFqZ2dBaUFCS0FJOE5nSThJQUZCUUdzaEFTQUNRVUJySWdJZ0JVME5BQXNMSUFJZ0JFOE5BUU5BSUFJZ0FTZ0NBRFlDQUNBQlFRUnFJUUVnQWtFRWFpSUNJQVJKRFFBTERBRUxJQU5CQkVrRVFDQUFJUUlNQVFzZ0FDQURRUVJySWdSTEJFQWdBQ0VDREFFTElBQWhBZ05BSUFJZ0FTMEFBRG9BQUNBQ0lBRXRBQUU2QUFFZ0FpQUJMUUFDT2dBQ0lBSWdBUzBBQXpvQUF5QUJRUVJxSVFFZ0FrRUVhaUlDSUFSTkRRQUxDeUFDSUFOSkJFQURRQ0FDSUFFdEFBQTZBQUFnQVVFQmFpRUJJQUpCQVdvaUFpQURSdzBBQ3dzZ0FBc0dBQ0FBRUF3TC9RSUNBWHdEZnlNQVFSQnJJZ1FrQUFKQUlBQzhJZ05CLy8vLy93ZHhJZ0pCMnAraytnTk5CRUFnQWtHQWdJRE1BMGtOQVNBQXV4QUlJUUFNQVFzZ0FrSFJwKzJEQkUwRVFDQUF1eUVCSUFKQjQ1ZmJnQVJOQkVBZ0EwRUFTQVJBSUFGRUdDMUVWUHNoK1QrZ0VBbU1JUUFNQXdzZ0FVUVlMVVJVK3lINXY2QVFDU0VBREFJTFJCZ3RSRlQ3SVFuQVJCZ3RSRlQ3SVFsQUlBTkJBRTRiSUFHZ21oQUlJUUFNQVFzZ0FrSFY0NGlIQkUwRVFDQUNRZC9idjRVRVRRUkFJQUM3SVFFZ0EwRUFTQVJBSUFGRTBpRXpmM3paRWtDZ0VBa2hBQXdEQ3lBQlJOSWhNMzk4MlJMQW9CQUpqQ0VBREFJTFJCZ3RSRlQ3SVJsQVJCZ3RSRlQ3SVJuQUlBTkJBRWdiSUFDN29CQUlJUUFNQVFzZ0FrR0FnSUQ4QjA4RVFDQUFJQUNUSVFBTUFRc2dBQ0FFUVFocUVDOGhBaUFFS3dNSUlRRUNRQUpBQWtBQ1FDQUNRUU54RGdNQUFRSURDeUFCRUFnaEFBd0RDeUFCRUFraEFBd0NDeUFCbWhBSUlRQU1BUXNnQVJBSmpDRUFDeUFFUVJCcUpBQWdBQXZCQVFJQ2Z3RjhJd0JCRUdzaUFTUUFBa0FnQUwxQ0lJaW5RZi8vLy84SGNTSUNRZnZEcFA4RFRRUkFJQUpCZ0lEQThnTkpEUUVnQUVRQUFBQUFBQUFBQUVFQUVCQWhBQXdCQ3lBQ1FZQ0F3UDhIVHdSQUlBQWdBS0VoQUF3QkN5QUFJQUVRTUNFQ0lBRXJBd2doQUNBQkt3TUFJUU1DUUFKQUFrQUNRQ0FDUVFOeERnTUFBUUlEQ3lBRElBQkJBUkFRSVFBTUF3c2dBeUFBRUJFaEFBd0NDeUFESUFCQkFSQVFtaUVBREFFTElBTWdBQkFSbWlFQUN5QUJRUkJxSkFBZ0FBdkNBUUVEZndKQUlBRWdBaWdDRUNJREJIOGdBd1VnQWhBYURRRWdBaWdDRUFzZ0FpZ0NGQ0lFYTBzRVFDQUNJQUFnQVNBQ0tBSWtFUUlBRHdzQ1FBSkFJQUlvQWxCQkFFZ05BQ0FCUlEwQUlBRWhBd05BSUFBZ0Eyb2lCVUVCYXkwQUFFRUtSd1JBSUFOQkFXc2lBdzBCREFJTEN5QUNJQUFnQXlBQ0tBSWtFUUlBSWdRZ0Ewa05BaUFCSUFOcklRRWdBaWdDRkNFRURBRUxJQUFoQlVFQUlRTUxJQVFnQlNBQkVCVWFJQUlnQWlnQ0ZDQUJhallDRkNBQklBTnFJUVFMSUFRTFdRRUJmeUFBSUFBb0FrZ2lBVUVCYXlBQmNqWUNTQ0FBS0FJQUlnRkJDSEVFUUNBQUlBRkJJSEkyQWdCQmZ3OExJQUJDQURjQ0JDQUFJQUFvQWl3aUFUWUNIQ0FBSUFFMkFoUWdBQ0FCSUFBb0FqQnFOZ0lRUVFBTDZRSURBMzhCZkFGOUl3QkJFR3NpQXlRQUFuMGdBTHdpQWtILy8vLy9CM0VpQVVIYW42VDZBMDBFUUVNQUFJQS9JQUZCZ0lDQXpBTkpEUUVhSUFDN0VBa01BUXNnQVVIUnArMkRCRTBFUUNBQlFlU1gyNEFFVHdSQVJCZ3RSRlQ3SVFsQVJCZ3RSRlQ3SVFuQUlBSkJBRWdiSUFDN29CQUpqQXdDQ3lBQXV5RUVJQUpCQUVnRVFDQUVSQmd0UkZUN0lmay9vQkFJREFJTFJCZ3RSRlQ3SWZrL0lBU2hFQWdNQVFzZ0FVSFY0NGlIQkUwRVFDQUJRZURidjRVRVR3UkFSQmd0UkZUN0lSbEFSQmd0UkZUN0lSbkFJQUpCQUVnYklBQzdvQkFKREFJTElBSkJBRWdFUUVUU0lUTi9mTmtTd0NBQXU2RVFDQXdDQ3lBQXUwVFNJVE4vZk5rU3dLQVFDQXdCQ3lBQUlBQ1RJQUZCZ0lDQS9BZFBEUUFhSUFBZ0EwRUlhaEF2SVFFZ0F5c0RDQ0VFQWtBQ1FBSkFBa0FnQVVFRGNRNERBQUVDQXdzZ0JCQUpEQU1MSUFTYUVBZ01BZ3NnQkJBSmpBd0JDeUFFRUFnTElRVWdBMEVRYWlRQUlBVUx2UUVDQW53Q2Z5TUFRUkJySWdNa0FBSjhJQUM5UWlDSXAwSC8vLy8vQjNFaUJFSDd3NlQvQTAwRVFFUUFBQUFBQUFEd1B5QUVRWjdCbXZJRFNRMEJHaUFBUkFBQUFBQUFBQUFBRUJFTUFRc2dBQ0FBb1NBRVFZQ0F3UDhIVHcwQUdpQUFJQU1RTUNFRUlBTXJBd2doQUNBREt3TUFJUUVDUUFKQUFrQUNRQ0FFUVFOeERnTUFBUUlEQ3lBQklBQVFFUXdEQ3lBQklBQkJBUkFRbWd3Q0N5QUJJQUFRRVpvTUFRc2dBU0FBUVFFUUVBc2hBaUFEUVJCcUpBQWdBZ3NUQUVIVU5FSGNNellDQUVHTU5FRXFOZ0lBQ3dzQUlBQVFIeG9nQUJBTUN6RUJBbjhnQUVHVUtUWUNBQ0FBS0FJRVFReHJJZ0VnQVNnQ0NFRUJheUlDTmdJSUlBSkJBRWdFUUNBQkVCWUxJQUFMbWdFQUlBQkJBVG9BTlFKQUlBQW9BZ1FnQWtjTkFDQUFRUUU2QURRQ1FDQUFLQUlRSWdKRkJFQWdBRUVCTmdJa0lBQWdBellDR0NBQUlBRTJBaEFnQTBFQlJ3MENJQUFvQWpCQkFVWU5BUXdDQ3lBQklBSkdCRUFnQUNnQ0dDSUNRUUpHQkVBZ0FDQUROZ0lZSUFNaEFnc2dBQ2dDTUVFQlJ3MENJQUpCQVVZTkFRd0NDeUFBSUFBb0FpUkJBV28yQWlRTElBQkJBVG9BTmdzTFhRRUJmeUFBS0FJUUlnTkZCRUFnQUVFQk5nSWtJQUFnQWpZQ0dDQUFJQUUyQWhBUEN3SkFJQUVnQTBZRVFDQUFLQUlZUVFKSERRRWdBQ0FDTmdJWUR3c2dBRUVCT2dBMklBQkJBallDR0NBQUlBQW9BaVJCQVdvMkFpUUxDNEFEQVFSL0l3QkI4QUJySWdJa0FDQUFLQUlBSWdOQkJHc29BZ0FoQkNBRFFRaHJLQUlBSVFVZ0FrSUFOd0pRSUFKQ0FEY0NXQ0FDUWdBM0FtQWdBa0lBTndCbklBSkNBRGNDU0NBQ1FRQTJBa1FnQWtIVUpUWUNRQ0FDSUFBMkFqd2dBaUFCTmdJNElBQWdCV29oQXdKQUlBUWdBVUVBRUFvRVFFRUFJQU1nQlJzaEFBd0JDeUFBSUFOT0JFQWdBa0lBTndBdklBSkNBRGNDR0NBQ1FnQTNBaUFnQWtJQU53SW9JQUpDQURjQ0VDQUNRUUEyQWd3Z0FpQUJOZ0lJSUFJZ0FEWUNCQ0FDSUFRMkFnQWdBa0VCTmdJd0lBUWdBaUFESUFOQkFVRUFJQVFvQWdBb0FoUVJDUUFnQWlnQ0dBMEJDMEVBSVFBZ0JDQUNRVGhxSUFOQkFVRUFJQVFvQWdBb0FoZ1JCZ0FDUUFKQUlBSW9BbHdPQWdBQkFnc2dBaWdDVEVFQUlBSW9BbGhCQVVZYlFRQWdBaWdDVkVFQlJodEJBQ0FDS0FKZ1FRRkdHeUVBREFFTElBSW9BbEJCQVVjRVFDQUNLQUpnRFFFZ0FpZ0NWRUVCUncwQklBSW9BbGhCQVVjTkFRc2dBaWdDU0NFQUN5QUNRZkFBYWlRQUlBQUxCQUFnQUFzT0FDQUFRZEFBYWhBbFFkQUFhZ3ZnSndFTWZ5TUFRUkJySWdva0FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCOUFGTkJFQkIrRFFvQWdBaUJFRVFJQUJCQzJwQitBTnhJQUJCQzBrYklnWkJBM1lpQUhZaUFVRURjUVJBQWtBZ0FVRi9jMEVCY1NBQWFpSUNRUU4wSWdGQm9EVnFJZ0FnQVVHb05Xb29BZ0FpQVNnQ0NDSUZSZ1JBUWZnMElBUkJmaUFDZDNFMkFnQU1BUXNnQlNBQU5nSU1JQUFnQlRZQ0NBc2dBVUVJYWlFQUlBRWdBa0VEZENJQ1FRTnlOZ0lFSUFFZ0Ftb2lBU0FCS0FJRVFRRnlOZ0lFREFzTElBWkJnRFVvQWdBaUNFME5BU0FCQkVBQ1FFRUNJQUIwSWdKQkFDQUNhM0lnQVNBQWRIRm9JZ0ZCQTNRaUFFR2dOV29pQWlBQVFhZzFhaWdDQUNJQUtBSUlJZ1ZHQkVCQitEUWdCRUYrSUFGM2NTSUVOZ0lBREFFTElBVWdBallDRENBQ0lBVTJBZ2dMSUFBZ0JrRURjallDQkNBQUlBWnFJZ2NnQVVFRGRDSUJJQVpySWdWQkFYSTJBZ1FnQUNBQmFpQUZOZ0lBSUFnRVFDQUlRWGh4UWFBMWFpRUJRWXcxS0FJQUlRSUNmeUFFUVFFZ0NFRURkblFpQTNGRkJFQkIrRFFnQXlBRWNqWUNBQ0FCREFFTElBRW9BZ2dMSVFNZ0FTQUNOZ0lJSUFNZ0FqWUNEQ0FDSUFFMkFnd2dBaUFETmdJSUN5QUFRUWhxSVFCQmpEVWdCellDQUVHQU5TQUZOZ0lBREFzTFFmdzBLQUlBSWd0RkRRRWdDMmhCQW5SQnFEZHFLQUlBSWdJb0FnUkJlSEVnQm1zaEF5QUNJUUVEUUFKQUlBRW9BaEFpQUVVRVFDQUJLQUlVSWdCRkRRRUxJQUFvQWdSQmVIRWdCbXNpQVNBRElBRWdBMGtpQVJzaEF5QUFJQUlnQVJzaEFpQUFJUUVNQVFzTElBSW9BaGdoQ1NBQ0lBSW9BZ3dpQUVjRVFFR0lOU2dDQUJvZ0FpZ0NDQ0lCSUFBMkFnd2dBQ0FCTmdJSURBb0xJQUlvQWhRaUFRUi9JQUpCRkdvRklBSW9BaEFpQVVVTkF5QUNRUkJxQ3lFRkEwQWdCU0VISUFFaUFFRVVhaUVGSUFBb0FoUWlBUTBBSUFCQkVHb2hCU0FBS0FJUUlnRU5BQXNnQjBFQU5nSUFEQWtMUVg4aEJpQUFRYjkvU3cwQUlBQkJDMm9pQUVGNGNTRUdRZncwS0FJQUlnZEZEUUJCQUNBR2F5RURBa0FDUUFKQUFuOUJBQ0FHUVlBQ1NRMEFHa0VmSUFaQi8vLy9CMHNOQUJvZ0JrRW1JQUJCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWdzaUNFRUNkRUdvTjJvb0FnQWlBVVVFUUVFQUlRQU1BUXRCQUNFQUlBWkJHU0FJUVFGMmEwRUFJQWhCSDBjYmRDRUNBMEFDUUNBQktBSUVRWGh4SUFacklnUWdBMDhOQUNBQklRVWdCQ0lERFFCQkFDRURJQUVoQUF3REN5QUFJQUVvQWhRaUJDQUVJQUVnQWtFZGRrRUVjV29vQWhBaUFVWWJJQUFnQkJzaEFDQUNRUUYwSVFJZ0FRMEFDd3NnQUNBRmNrVUVRRUVBSVFWQkFpQUlkQ0lBUVFBZ0FHdHlJQWR4SWdCRkRRTWdBR2hCQW5SQnFEZHFLQUlBSVFBTElBQkZEUUVMQTBBZ0FDZ0NCRUY0Y1NBR2F5SUNJQU5KSVFFZ0FpQURJQUViSVFNZ0FDQUZJQUViSVFVZ0FDZ0NFQ0lCQkg4Z0FRVWdBQ2dDRkFzaUFBMEFDd3NnQlVVTkFDQURRWUExS0FJQUlBWnJUdzBBSUFVb0FoZ2hDQ0FGSUFVb0Fnd2lBRWNFUUVHSU5TZ0NBQm9nQlNnQ0NDSUJJQUEyQWd3Z0FDQUJOZ0lJREFnTElBVW9BaFFpQVFSL0lBVkJGR29GSUFVb0FoQWlBVVVOQXlBRlFSQnFDeUVDQTBBZ0FpRUVJQUVpQUVFVWFpRUNJQUFvQWhRaUFRMEFJQUJCRUdvaEFpQUFLQUlRSWdFTkFBc2dCRUVBTmdJQURBY0xJQVpCZ0RVb0FnQWlCVTBFUUVHTU5TZ0NBQ0VBQWtBZ0JTQUdheUlCUVJCUEJFQWdBQ0FHYWlJQ0lBRkJBWEkyQWdRZ0FDQUZhaUFCTmdJQUlBQWdCa0VEY2pZQ0JBd0JDeUFBSUFWQkEzSTJBZ1FnQUNBRmFpSUJJQUVvQWdSQkFYSTJBZ1JCQUNFQ1FRQWhBUXRCZ0RVZ0FUWUNBRUdNTlNBQ05nSUFJQUJCQ0dvaEFBd0pDeUFHUVlRMUtBSUFJZ0pKQkVCQmhEVWdBaUFHYXlJQk5nSUFRWkExUVpBMUtBSUFJZ0FnQm1vaUFqWUNBQ0FDSUFGQkFYSTJBZ1FnQUNBR1FRTnlOZ0lFSUFCQkNHb2hBQXdKQzBFQUlRQWdCa0V2YWlJREFuOUIwRGdvQWdBRVFFSFlPQ2dDQUF3QkMwSGNPRUovTndJQVFkUTRRb0NnZ0lDQWdBUTNBZ0JCMERnZ0NrRU1ha0Z3Y1VIWXF0V3FCWE0yQWdCQjVEaEJBRFlDQUVHME9FRUFOZ0lBUVlBZ0N5SUJhaUlFUVFBZ0FXc2lCM0VpQVNBR1RRMElRYkE0S0FJQUlnVUVRRUdvT0NnQ0FDSUlJQUZxSWdrZ0NFME5DU0FGSUFsSkRRa0xBa0JCdERndEFBQkJCSEZGQkVBQ1FBSkFBa0FDUUVHUU5TZ0NBQ0lGQkVCQnVEZ2hBQU5BSUFVZ0FDZ0NBQ0lJVHdSQUlBZ2dBQ2dDQkdvZ0JVc05Bd3NnQUNnQ0NDSUFEUUFMQzBFQUVBMGlBa0YvUmcwRElBRWhCRUhVT0NnQ0FDSUFRUUZySWdVZ0FuRUVRQ0FCSUFKcklBSWdCV3BCQUNBQWEzRnFJUVFMSUFRZ0JrME5BMEd3T0NnQ0FDSUFCRUJCcURnb0FnQWlCU0FFYWlJSElBVk5EUVFnQUNBSFNRMEVDeUFFRUEwaUFDQUNSdzBCREFVTElBUWdBbXNnQjNFaUJCQU5JZ0lnQUNnQ0FDQUFLQUlFYWtZTkFTQUNJUUFMSUFCQmYwWU5BU0FHUVRCcUlBUk5CRUFnQUNFQ0RBUUxRZGc0S0FJQUlnSWdBeUFFYTJwQkFDQUNhM0VpQWhBTlFYOUdEUUVnQWlBRWFpRUVJQUFoQWd3REN5QUNRWDlIRFFJTFFiUTRRYlE0S0FJQVFRUnlOZ0lBQ3lBQkVBMGhBa0VBRUEwaEFDQUNRWDlHRFFVZ0FFRi9SZzBGSUFBZ0FrME5CU0FBSUFKcklnUWdCa0VvYWswTkJRdEJxRGhCcURnb0FnQWdCR29pQURZQ0FFR3NPQ2dDQUNBQVNRUkFRYXc0SUFBMkFnQUxBa0JCa0RVb0FnQWlBd1JBUWJnNElRQURRQ0FDSUFBb0FnQWlBU0FBS0FJRUlnVnFSZzBDSUFBb0FnZ2lBQTBBQ3d3RUMwR0lOU2dDQUNJQVFRQWdBQ0FDVFJ0RkJFQkJpRFVnQWpZQ0FBdEJBQ0VBUWJ3NElBUTJBZ0JCdURnZ0FqWUNBRUdZTlVGL05nSUFRWncxUWRBNEtBSUFOZ0lBUWNRNFFRQTJBZ0FEUUNBQVFRTjBJZ0ZCcURWcUlBRkJvRFZxSWdVMkFnQWdBVUdzTldvZ0JUWUNBQ0FBUVFGcUlnQkJJRWNOQUF0QmhEVWdCRUVvYXlJQVFYZ2dBbXRCQjNFaUFXc2lCVFlDQUVHUU5TQUJJQUpxSWdFMkFnQWdBU0FGUVFGeU5nSUVJQUFnQW1wQktEWUNCRUdVTlVIZ09DZ0NBRFlDQUF3RUN5QUNJQU5ORFFJZ0FTQURTdzBDSUFBb0FneEJDSEVOQWlBQUlBUWdCV28yQWdSQmtEVWdBMEY0SUFOclFRZHhJZ0JxSWdFMkFnQkJoRFZCaERVb0FnQWdCR29pQWlBQWF5SUFOZ0lBSUFFZ0FFRUJjallDQkNBQ0lBTnFRU2cyQWdSQmxEVkI0RGdvQWdBMkFnQU1Bd3RCQUNFQURBWUxRUUFoQUF3RUMwR0lOU2dDQUNBQ1N3UkFRWWcxSUFJMkFnQUxJQUlnQkdvaEFVRzRPQ0VBQWtBRFFDQUJJQUFvQWdCSEJFQWdBQ2dDQ0NJQURRRU1BZ3NMSUFBdEFBeEJDSEZGRFFNTFFiZzRJUUFEUUFKQUlBTWdBQ2dDQUNJQlR3UkFJQUVnQUNnQ0JHb2lCU0FEU3cwQkN5QUFLQUlJSVFBTUFRc0xRWVExSUFSQktHc2lBRUY0SUFKclFRZHhJZ0ZySWdjMkFnQkJrRFVnQVNBQ2FpSUJOZ0lBSUFFZ0IwRUJjallDQkNBQUlBSnFRU2cyQWdSQmxEVkI0RGdvQWdBMkFnQWdBeUFGUVNjZ0JXdEJCM0ZxUVM5cklnQWdBQ0FEUVJCcVNSc2lBVUViTmdJRUlBRkJ3RGdwQWdBM0FoQWdBVUc0T0NrQ0FEY0NDRUhBT0NBQlFRaHFOZ0lBUWJ3NElBUTJBZ0JCdURnZ0FqWUNBRUhFT0VFQU5nSUFJQUZCR0dvaEFBTkFJQUJCQnpZQ0JDQUFRUWhxSVF3Z0FFRUVhaUVBSUF3Z0JVa05BQXNnQVNBRFJnMEFJQUVnQVNnQ0JFRitjVFlDQkNBRElBRWdBMnNpQWtFQmNqWUNCQ0FCSUFJMkFnQUNmeUFDUWY4QlRRUkFJQUpCZUhGQm9EVnFJUUFDZjBINE5DZ0NBQ0lCUVFFZ0FrRURkblFpQW5GRkJFQkIrRFFnQVNBQ2NqWUNBQ0FBREFFTElBQW9BZ2dMSVFFZ0FDQUROZ0lJSUFFZ0F6WUNERUVNSVFKQkNBd0JDMEVmSVFBZ0FrSC8vLzhIVFFSQUlBSkJKaUFDUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vaEFBc2dBeUFBTmdJY0lBTkNBRGNDRUNBQVFRSjBRYWczYWlFQkFrQUNRRUg4TkNnQ0FDSUZRUUVnQUhRaUJIRkZCRUJCL0RRZ0JDQUZjallDQUNBQklBTTJBZ0FNQVFzZ0FrRVpJQUJCQVhaclFRQWdBRUVmUnh0MElRQWdBU2dDQUNFRkEwQWdCU0lCS0FJRVFYaHhJQUpHRFFJZ0FFRWRkaUVGSUFCQkFYUWhBQ0FCSUFWQkJIRnFJZ1FvQWhBaUJRMEFDeUFFSUFNMkFoQUxJQU1nQVRZQ0dFRUlJUUlnQXlJQklRQkJEQXdCQ3lBQktBSUlJZ0FnQXpZQ0RDQUJJQU0yQWdnZ0F5QUFOZ0lJUVFBaEFFRVlJUUpCREFzZ0Eyb2dBVFlDQUNBQ0lBTnFJQUEyQWdBTFFZUTFLQUlBSWdBZ0JrME5BRUdFTlNBQUlBWnJJZ0UyQWdCQmtEVkJrRFVvQWdBaUFDQUdhaUlDTmdJQUlBSWdBVUVCY2pZQ0JDQUFJQVpCQTNJMkFnUWdBRUVJYWlFQURBUUxRYmd6UVRBMkFnQkJBQ0VBREFNTElBQWdBallDQUNBQUlBQW9BZ1FnQkdvMkFnUWdBa0Y0SUFKclFRZHhhaUlJSUFaQkEzSTJBZ1FnQVVGNElBRnJRUWR4YWlJRUlBWWdDR29pQTJzaEJ3SkFRWkExS0FJQUlBUkdCRUJCa0RVZ0F6WUNBRUdFTlVHRU5TZ0NBQ0FIYWlJQU5nSUFJQU1nQUVFQmNqWUNCQXdCQzBHTU5TZ0NBQ0FFUmdSQVFZdzFJQU0yQWdCQmdEVkJnRFVvQWdBZ0Iyb2lBRFlDQUNBRElBQkJBWEkyQWdRZ0FDQURhaUFBTmdJQURBRUxJQVFvQWdRaUFFRURjVUVCUmdSQUlBQkJlSEVoQ1NBRUtBSU1JUUlDUUNBQVFmOEJUUVJBSUFRb0FnZ2lBU0FDUmdSQVFmZzBRZmcwS0FJQVFYNGdBRUVEZG5keE5nSUFEQUlMSUFFZ0FqWUNEQ0FDSUFFMkFnZ01BUXNnQkNnQ0dDRUdBa0FnQWlBRVJ3UkFRWWcxS0FJQUdpQUVLQUlJSWdBZ0FqWUNEQ0FDSUFBMkFnZ01BUXNDUUNBRUtBSVVJZ0FFZnlBRVFSUnFCU0FFS0FJUUlnQkZEUUVnQkVFUWFnc2hBUU5BSUFFaEJTQUFJZ0pCRkdvaEFTQUFLQUlVSWdBTkFDQUNRUkJxSVFFZ0FpZ0NFQ0lBRFFBTElBVkJBRFlDQUF3QkMwRUFJUUlMSUFaRkRRQUNRQ0FFS0FJY0lnQkJBblJCcURkcUlnRW9BZ0FnQkVZRVFDQUJJQUkyQWdBZ0FnMEJRZncwUWZ3MEtBSUFRWDRnQUhkeE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0JFWWJhaUFDTmdJQUlBSkZEUUVMSUFJZ0JqWUNHQ0FFS0FJUUlnQUVRQ0FDSUFBMkFoQWdBQ0FDTmdJWUN5QUVLQUlVSWdCRkRRQWdBaUFBTmdJVUlBQWdBallDR0FzZ0J5QUphaUVISUFRZ0NXb2lCQ2dDQkNFQUN5QUVJQUJCZm5FMkFnUWdBeUFIUVFGeU5nSUVJQU1nQjJvZ0J6WUNBQ0FIUWY4QlRRUkFJQWRCZUhGQm9EVnFJUUFDZjBINE5DZ0NBQ0lCUVFFZ0IwRURkblFpQW5GRkJFQkIrRFFnQVNBQ2NqWUNBQ0FBREFFTElBQW9BZ2dMSVFFZ0FDQUROZ0lJSUFFZ0F6WUNEQ0FESUFBMkFnd2dBeUFCTmdJSURBRUxRUjhoQWlBSFFmLy8vd2ROQkVBZ0IwRW1JQWRCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWlFQ0N5QURJQUkyQWh3Z0EwSUFOd0lRSUFKQkFuUkJxRGRxSVFBQ1FBSkFRZncwS0FJQUlnRkJBU0FDZENJRmNVVUVRRUg4TkNBQklBVnlOZ0lBSUFBZ0F6WUNBQXdCQ3lBSFFSa2dBa0VCZG10QkFDQUNRUjlIRzNRaEFpQUFLQUlBSVFFRFFDQUJJZ0FvQWdSQmVIRWdCMFlOQWlBQ1FSMTJJUUVnQWtFQmRDRUNJQUFnQVVFRWNXb2lCU2dDRUNJQkRRQUxJQVVnQXpZQ0VBc2dBeUFBTmdJWUlBTWdBellDRENBRElBTTJBZ2dNQVFzZ0FDZ0NDQ0lCSUFNMkFnd2dBQ0FETmdJSUlBTkJBRFlDR0NBRElBQTJBZ3dnQXlBQk5nSUlDeUFJUVFocUlRQU1BZ3NDUUNBSVJRMEFBa0FnQlNnQ0hDSUJRUUowUWFnM2FpSUNLQUlBSUFWR0JFQWdBaUFBTmdJQUlBQU5BVUg4TkNBSFFYNGdBWGR4SWdjMkFnQU1BZ3NnQ0VFUVFSUWdDQ2dDRUNBRlJodHFJQUEyQWdBZ0FFVU5BUXNnQUNBSU5nSVlJQVVvQWhBaUFRUkFJQUFnQVRZQ0VDQUJJQUEyQWhnTElBVW9BaFFpQVVVTkFDQUFJQUUyQWhRZ0FTQUFOZ0lZQ3dKQUlBTkJEMDBFUUNBRklBTWdCbW9pQUVFRGNqWUNCQ0FBSUFWcUlnQWdBQ2dDQkVFQmNqWUNCQXdCQ3lBRklBWkJBM0kyQWdRZ0JTQUdhaUlFSUFOQkFYSTJBZ1FnQXlBRWFpQUROZ0lBSUFOQi93Rk5CRUFnQTBGNGNVR2dOV29oQUFKL1FmZzBLQUlBSWdGQkFTQURRUU4yZENJQ2NVVUVRRUg0TkNBQklBSnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaEFTQUFJQVEyQWdnZ0FTQUVOZ0lNSUFRZ0FEWUNEQ0FFSUFFMkFnZ01BUXRCSHlFQUlBTkIvLy8vQjAwRVFDQURRU1lnQTBFSWRtY2lBR3QyUVFGeElBQkJBWFJyUVQ1cUlRQUxJQVFnQURZQ0hDQUVRZ0EzQWhBZ0FFRUNkRUdvTjJvaEFRSkFBa0FnQjBFQklBQjBJZ0p4UlFSQVFmdzBJQUlnQjNJMkFnQWdBU0FFTmdJQUlBUWdBVFlDR0F3QkN5QURRUmtnQUVFQmRtdEJBQ0FBUVI5SEczUWhBQ0FCS0FJQUlRRURRQ0FCSWdJb0FnUkJlSEVnQTBZTkFpQUFRUjEySVFFZ0FFRUJkQ0VBSUFJZ0FVRUVjV29pQnlnQ0VDSUJEUUFMSUFjZ0JEWUNFQ0FFSUFJMkFoZ0xJQVFnQkRZQ0RDQUVJQVEyQWdnTUFRc2dBaWdDQ0NJQUlBUTJBZ3dnQWlBRU5nSUlJQVJCQURZQ0dDQUVJQUkyQWd3Z0JDQUFOZ0lJQ3lBRlFRaHFJUUFNQVFzQ1FDQUpSUTBBQWtBZ0FpZ0NIQ0lCUVFKMFFhZzNhaUlGS0FJQUlBSkdCRUFnQlNBQU5nSUFJQUFOQVVIOE5DQUxRWDRnQVhkeE5nSUFEQUlMSUFsQkVFRVVJQWtvQWhBZ0FrWWJhaUFBTmdJQUlBQkZEUUVMSUFBZ0NUWUNHQ0FDS0FJUUlnRUVRQ0FBSUFFMkFoQWdBU0FBTmdJWUN5QUNLQUlVSWdGRkRRQWdBQ0FCTmdJVUlBRWdBRFlDR0FzQ1FDQURRUTlOQkVBZ0FpQURJQVpxSWdCQkEzSTJBZ1FnQUNBQ2FpSUFJQUFvQWdSQkFYSTJBZ1FNQVFzZ0FpQUdRUU55TmdJRUlBSWdCbW9pQlNBRFFRRnlOZ0lFSUFNZ0JXb2dBellDQUNBSUJFQWdDRUY0Y1VHZ05Xb2hBRUdNTlNnQ0FDRUJBbjlCQVNBSVFRTjJkQ0lISUFSeFJRUkFRZmcwSUFRZ0IzSTJBZ0FnQUF3QkN5QUFLQUlJQ3lFRUlBQWdBVFlDQ0NBRUlBRTJBZ3dnQVNBQU5nSU1JQUVnQkRZQ0NBdEJqRFVnQlRZQ0FFR0FOU0FETmdJQUN5QUNRUWhxSVFBTElBcEJFR29rQUNBQUM1Y0NBQ0FBUlFSQVFRQVBDd0ovQWtBZ0FBUi9JQUZCL3dCTkRRRUNRRUhVTkNnQ0FDZ0NBRVVFUUNBQlFZQi9jVUdBdndOR0RRTU1BUXNnQVVIL0QwMEVRQ0FBSUFGQlAzRkJnQUZ5T2dBQklBQWdBVUVHZGtIQUFYSTZBQUJCQWd3RUN5QUJRWUJBY1VHQXdBTkhJQUZCZ0xBRFQzRkZCRUFnQUNBQlFUOXhRWUFCY2pvQUFpQUFJQUZCREhaQjRBRnlPZ0FBSUFBZ0FVRUdka0UvY1VHQUFYSTZBQUZCQXd3RUN5QUJRWUNBQkd0Qi8vOC9UUVJBSUFBZ0FVRS9jVUdBQVhJNkFBTWdBQ0FCUVJKMlFmQUJjam9BQUNBQUlBRkJCblpCUDNGQmdBRnlPZ0FDSUFBZ0FVRU1ka0UvY1VHQUFYSTZBQUZCQkF3RUN3dEJ1RE5CR1RZQ0FFRi9CVUVCQ3d3QkN5QUFJQUU2QUFCQkFRc0xvUmdERTM4QmZBSitJd0JCc0FScklnd2tBQ0FNUVFBMkFpd0NRQ0FCdlNJYVFnQlRCRUJCQVNFUFFmWUlJUk1nQVpvaUFiMGhHZ3dCQ3lBRVFZQVFjUVJBUVFFaEQwSDVDQ0VUREFFTFFmd0lRZmNJSUFSQkFYRWlEeHNoRXlBUFJTRVZDd0pBSUJwQ2dJQ0FnSUNBZ1BqL0FJTkNnSUNBZ0lDQWdQai9BRkVFUUNBQVFTQWdBaUFQUVFOcUlnTWdCRUgvLzN0eEVBWWdBQ0FUSUE4UUJTQUFRWjhKUWR3SklBVkJJSEVpQlJ0QnVBbEI0QWtnQlJzZ0FTQUJZaHRCQXhBRklBQkJJQ0FDSUFNZ0JFR0F3QUJ6RUFZZ0F5QUNJQUlnQTBnYklRa01BUXNnREVFUWFpRVNBa0FDZndKQUlBRWdERUVzYWhBcklnRWdBYUFpQVVRQUFBQUFBQUFBQUdJRVFDQU1JQXdvQWl3aUJrRUJhellDTENBRlFTQnlJZzVCNFFCSERRRU1Bd3NnQlVFZ2NpSU9RZUVBUmcwQ0lBd29BaXdoQ2tFR0lBTWdBMEVBU0JzTUFRc2dEQ0FHUVIxcklnbzJBaXdnQVVRQUFBQUFBQUN3UWFJaEFVRUdJQU1nQTBFQVNCc0xJUXNnREVFd2FrR2dBa0VBSUFwQkFFNGJhaUlOSVFjRFFDQUhBbjhnQVVRQUFBQUFBQUR3UVdNZ0FVUUFBQUFBQUFBQUFHWnhCRUFnQWFzTUFRdEJBQXNpQXpZQ0FDQUhRUVJxSVFjZ0FTQUR1S0ZFQUFBQUFHWE56VUdpSWdGRUFBQUFBQUFBQUFCaURRQUxBa0FnQ2tFQVRBUkFJQW9oQXlBSElRWWdEU0VJREFFTElBMGhDQ0FLSVFNRFFFRWRJQU1nQTBFZFR4c2hBd0pBSUFkQkJHc2lCaUFJU1EwQUlBT3RJUnRDQUNFYUEwQWdCaUFhUXYvLy8vOFBneUFHTlFJQUlCdUdmQ0lhSUJwQ2dKVHIzQU9BSWhwQ2dKVHIzQU4rZlQ0Q0FDQUdRUVJySWdZZ0NFOE5BQXNnR3FjaUJrVU5BQ0FJUVFScklnZ2dCallDQUFzRFFDQUlJQWNpQmtrRVFDQUdRUVJySWdjb0FnQkZEUUVMQ3lBTUlBd29BaXdnQTJzaUF6WUNMQ0FHSVFjZ0EwRUFTZzBBQ3dzZ0EwRUFTQVJBSUF0QkdXcEJDVzVCQVdvaEVDQU9RZVlBUmlFUkEwQkJDVUVBSUFOcklnTWdBMEVKVHhzaENRSkFJQVlnQ0UwRVFDQUlLQUlBUlVFQ2RDRUhEQUVMUVlDVTY5d0RJQWwySVJSQmZ5QUpkRUYvY3lFV1FRQWhBeUFJSVFjRFFDQUhJQU1nQnlnQ0FDSVhJQWwyYWpZQ0FDQVdJQmR4SUJSc0lRTWdCMEVFYWlJSElBWkpEUUFMSUFnb0FnQkZRUUowSVFjZ0EwVU5BQ0FHSUFNMkFnQWdCa0VFYWlFR0N5QU1JQXdvQWl3Z0NXb2lBellDTENBTklBY2dDR29pQ0NBUkd5SUhJQkJCQW5ScUlBWWdCaUFIYTBFQ2RTQVFTaHNoQmlBRFFRQklEUUFMQzBFQUlRTUNRQ0FHSUFoTkRRQWdEU0FJYTBFQ2RVRUpiQ0VEUVFvaEJ5QUlLQUlBSWdsQkNra05BQU5BSUFOQkFXb2hBeUFKSUFkQkNtd2lCMDhOQUFzTElBc2dBMEVBSUE1QjVnQkhHMnNnRGtIbkFFWWdDMEVBUjNGcklnY2dCaUFOYTBFQ2RVRUpiRUVKYTBnRVFDQU1RVEJxUVFSQnBBSWdDa0VBU0J0cUlBZEJnTWdBYWlJSlFRbHRJaEZCQW5ScUloQkJnQ0JySVFwQkNpRUhJQWtnRVVFSmJHc2lDVUVIVEFSQUEwQWdCMEVLYkNFSElBbEJBV29pQ1VFSVJ3MEFDd3NDUUNBS0tBSUFJaEVnRVNBSGJpSVVJQWRzYXlJSlJTQVFRZndmYXlJV0lBWkdjUTBBQWtBZ0ZFRUJjVVVFUUVRQUFBQUFBQUJBUXlFQklBZEJnSlRyM0FOSERRRWdDQ0FLVHcwQklCQkJoQ0JyTFFBQVFRRnhSUTBCQzBRQkFBQUFBQUJBUXlFQkMwUUFBQUFBQUFEZ1AwUUFBQUFBQUFEd1AwUUFBQUFBQUFENFB5QUdJQlpHRzBRQUFBQUFBQUQ0UHlBSklBZEJBWFlpRkVZYklBa2dGRWtiSVJrQ1FDQVZEUUFnRXkwQUFFRXRSdzBBSUJtYUlSa2dBWm9oQVFzZ0NpQVJJQWxySWdrMkFnQWdBU0Fab0NBQllRMEFJQW9nQnlBSmFpSUROZ0lBSUFOQmdKVHIzQU5QQkVBRFFDQUtRUUEyQWdBZ0NDQUtRUVJySWdwTEJFQWdDRUVFYXlJSVFRQTJBZ0FMSUFvZ0NpZ0NBRUVCYWlJRE5nSUFJQU5CLzVQcjNBTkxEUUFMQ3lBTklBaHJRUUoxUVFsc0lRTkJDaUVISUFnb0FnQWlDVUVLU1EwQUEwQWdBMEVCYWlFRElBa2dCMEVLYkNJSFR3MEFDd3NnQ2tFRWFpSUhJQVlnQmlBSFN4c2hCZ3NEUUNBR0lnY2dDRTBpQ1VVRVFDQUdRUVJySWdZb0FnQkZEUUVMQ3dKQUlBNUI1d0JIQkVBZ0JFRUljU0VLREFFTElBTkJmM05CZnlBTFFRRWdDeHNpQmlBRFNpQURRWHRLY1NJS0d5QUdhaUVMUVg5QmZpQUtHeUFGYWlFRklBUkJDSEVpQ2cwQVFYY2hCZ0pBSUFrTkFDQUhRUVJyS0FJQUlnNUZEUUJCQ2lFSlFRQWhCaUFPUVFwd0RRQURRQ0FHSWdwQkFXb2hCaUFPSUFsQkNtd2lDWEJGRFFBTElBcEJmM01oQmdzZ0J5QU5hMEVDZFVFSmJDRUpJQVZCWDNGQnhnQkdCRUJCQUNFS0lBc2dCaUFKYWtFSmF5SUdRUUFnQmtFQVNoc2lCaUFHSUF0S0d5RUxEQUVMUVFBaENpQUxJQU1nQ1dvZ0JtcEJDV3NpQmtFQUlBWkJBRW9iSWdZZ0JpQUxTaHNoQ3d0QmZ5RUpJQXRCL2YvLy93ZEIvdi8vL3djZ0NpQUxjaUlSRzBvTkFTQUxJQkZCQUVkcVFRRnFJUTRDUUNBRlFWOXhJaFZCeGdCR0JFQWdBeUFPUWYvLy8vOEhjMG9OQXlBRFFRQWdBMEVBU2hzaEJnd0JDeUFTSUFNZ0EwRWZkU0lHY3lBR2E2MGdFaEFPSWdaclFRRk1CRUFEUUNBR1FRRnJJZ1pCTURvQUFDQVNJQVpyUVFKSURRQUxDeUFHUVFKckloQWdCVG9BQUNBR1FRRnJRUzFCS3lBRFFRQklHem9BQUNBU0lCQnJJZ1lnRGtILy8vLy9CM05LRFFJTElBWWdEbW9pQXlBUFFmLy8vLzhIYzBvTkFTQUFRU0FnQWlBRElBOXFJZ1VnQkJBR0lBQWdFeUFQRUFVZ0FFRXdJQUlnQlNBRVFZQ0FCSE1RQmdKQUFrQUNRQ0FWUWNZQVJnUkFJQXhCRUdvaUJrRUljaUVESUFaQkNYSWhDaUFOSUFnZ0NDQU5TeHNpQ1NFSUEwQWdDRFVDQUNBS0VBNGhCZ0pBSUFnZ0NVY0VRQ0FHSUF4QkVHcE5EUUVEUUNBR1FRRnJJZ1pCTURvQUFDQUdJQXhCRUdwTERRQUxEQUVMSUFZZ0NrY05BQ0FNUVRBNkFCZ2dBeUVHQ3lBQUlBWWdDaUFHYXhBRklBaEJCR29pQ0NBTlRRMEFDeUFSQkVBZ0FFSGtDVUVCRUFVTElBY2dDRTBOQVNBTFFRQk1EUUVEUUNBSU5RSUFJQW9RRGlJR0lBeEJFR3BMQkVBRFFDQUdRUUZySWdaQk1Eb0FBQ0FHSUF4QkVHcExEUUFMQ3lBQUlBWkJDU0FMSUF0QkNVNGJFQVVnQzBFSmF5RUdJQWhCQkdvaUNDQUhUdzBESUF0QkNVb2hHQ0FHSVFzZ0dBMEFDd3dDQ3dKQUlBdEJBRWdOQUNBSElBaEJCR29nQnlBSVN4c2hDU0FNUVJCcUlnWkJDSEloQXlBR1FRbHlJUTBnQ0NFSEEwQWdEU0FITlFJQUlBMFFEaUlHUmdSQUlBeEJNRG9BR0NBRElRWUxBa0FnQnlBSVJ3UkFJQVlnREVFUWFrME5BUU5BSUFaQkFXc2lCa0V3T2dBQUlBWWdERUVRYWtzTkFBc01BUXNnQUNBR1FRRVFCU0FHUVFGcUlRWWdDaUFMY2tVTkFDQUFRZVFKUVFFUUJRc2dBQ0FHSUEwZ0Jtc2lCaUFMSUFZZ0MwZ2JFQVVnQ3lBR2F5RUxJQWRCQkdvaUJ5QUpUdzBCSUF0QkFFNE5BQXNMSUFCQk1DQUxRUkpxUVJKQkFCQUdJQUFnRUNBU0lCQnJFQVVNQWdzZ0N5RUdDeUFBUVRBZ0JrRUpha0VKUVFBUUJnc2dBRUVnSUFJZ0JTQUVRWURBQUhNUUJpQUZJQUlnQWlBRlNCc2hDUXdCQ3lBVElBVkJHblJCSDNWQkNYRnFJUWdDUUNBRFFRdExEUUJCRENBRGF5RUdSQUFBQUFBQUFEQkFJUmtEUUNBWlJBQUFBQUFBQURCQW9pRVpJQVpCQVdzaUJnMEFDeUFJTFFBQVFTMUdCRUFnR1NBQm1pQVpvYUNhSVFFTUFRc2dBU0Fab0NBWm9TRUJDeUFTSUF3b0Fpd2lCaUFHUVI5MUlnWnpJQVpyclNBU0VBNGlCa1lFUUNBTVFUQTZBQThnREVFUGFpRUdDeUFQUVFKeUlRc2dCVUVnY1NFTklBd29BaXdoQnlBR1FRSnJJZ29nQlVFUGFqb0FBQ0FHUVFGclFTMUJLeUFIUVFCSUd6b0FBQ0FFUVFoeElRWWdERUVRYWlFSEEwQWdCeUlGQW44Z0FabEVBQUFBQUFBQTRFRmpCRUFnQWFvTUFRdEJnSUNBZ0hnTElnZEJvQ1ZxTFFBQUlBMXlPZ0FBSUFFZ0I3ZWhSQUFBQUFBQUFEQkFvaUVCQWtBZ0JVRUJhaUlISUF4QkVHcHJRUUZIRFFBQ1FDQUdEUUFnQTBFQVNnMEFJQUZFQUFBQUFBQUFBQUJoRFFFTElBVkJMam9BQVNBRlFRSnFJUWNMSUFGRUFBQUFBQUFBQUFCaURRQUxRWDhoQ1VIOS8vLy9CeUFMSUJJZ0Ntc2lCbW9pRFdzZ0EwZ05BQ0FBUVNBZ0FpQU5JQU5CQW1vZ0J5QU1RUkJxSWdkcklnVWdCVUVDYXlBRFNCc2dCU0FER3lJSmFpSURJQVFRQmlBQUlBZ2dDeEFGSUFCQk1DQUNJQU1nQkVHQWdBUnpFQVlnQUNBSElBVVFCU0FBUVRBZ0NTQUZhMEVBUVFBUUJpQUFJQW9nQmhBRklBQkJJQ0FDSUFNZ0JFR0F3QUJ6RUFZZ0F5QUNJQUlnQTBnYklRa0xJQXhCc0FScUpBQWdDUXUwQWdBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUZCQ1dzT0VnQUlDUW9JQ1FFQ0F3UUtDUW9LQ0FrRkJnY0xJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBU2dDQURZQ0FBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVElCQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVE1CQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVEFBQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVEVBQURjREFBOExJQUlnQWlnQ0FFRUhha0Y0Y1NJQlFRaHFOZ0lBSUFBZ0FTc0RBRGtEQUE4TEFBc1BDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUUwQWdBM0F3QVBDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUUxQWdBM0F3QVBDeUFDSUFJb0FnQkJCMnBCZUhFaUFVRUlhallDQUNBQUlBRXBBd0EzQXdBTGN3RUdmeUFBS0FJQUlnTXNBQUJCTUdzaUFVRUpTd1JBUVFBUEN3TkFRWDhoQkNBQ1FjeVpzK1lBVFFSQVFYOGdBU0FDUVFwc0lnVnFJQUVnQlVILy8vLy9CM05MR3lFRUN5QUFJQU5CQVdvaUJUWUNBQ0FETEFBQklRWWdCQ0VDSUFVaEF5QUdRVEJySWdGQkNra05BQXNnQWd1VEZBSVdmd0YrUWUwSklRVWpBRUhRQUdzaUJpUUFJQVpCN1FrMkFrd2dCa0UzYWlFVUlBWkJPR29oRHdKQUFrQUNRQUpBQTBCQkFDRUVBMEFnQlNFTElBUWdERUgvLy8vL0IzTktEUUlnQkNBTWFpRU1Ba0FDUUFKQUlBVWlCQzBBQUNJSkJFQURRQUpBQWtBZ0NVSC9BWEVpQlVVRVFDQUVJUVVNQVFzZ0JVRWxSdzBCSUFRaENRTkFJQWt0QUFGQkpVY0VRQ0FKSVFVTUFnc2dCRUVCYWlFRUlBa3RBQUloRnlBSlFRSnFJZ1VoQ1NBWFFTVkdEUUFMQ3lBRUlBdHJJZ1FnREVILy8vLy9CM01pRlVvTkNDQUFCRUFnQUNBTElBUVFCUXNnQkEwR0lBWWdCVFlDVENBRlFRRnFJUVJCZnlFT0FrQWdCU3dBQVVFd2F5SUhRUWxMRFFBZ0JTMEFBa0VrUncwQUlBVkJBMm9oQkVFQklSQWdCeUVPQ3lBR0lBUTJBa3hCQUNFS0FrQWdCQ3dBQUNJSlFTQnJJZ1ZCSDBzRVFDQUVJUWNNQVFzZ0JDRUhRUUVnQlhRaUJVR0owUVJ4UlEwQUEwQWdCaUFFUVFGcUlnYzJBa3dnQlNBS2NpRUtJQVFzQUFFaUNVRWdheUlGUVNCUERRRWdCeUVFUVFFZ0JYUWlCVUdKMFFSeERRQUxDd0pBSUFsQktrWUVRQUovQWtBZ0J5d0FBVUV3YXlJRVFRbExEUUFnQnkwQUFrRWtSdzBBQW44Z0FFVUVRQ0FESUFSQkFuUnFRUW8yQWdCQkFBd0JDeUFDSUFSQkEzUnFLQUlBQ3lFTklBZEJBMm9oQlVFQkRBRUxJQkFOQmlBSFFRRnFJUVVnQUVVRVFDQUdJQVUyQWt4QkFDRVFRUUFoRFF3REN5QUJJQUVvQWdBaUJFRUVhallDQUNBRUtBSUFJUTFCQUFzaEVDQUdJQVUyQWt3Z0RVRUFUZzBCUVFBZ0RXc2hEU0FLUVlEQUFISWhDZ3dCQ3lBR1Fjd0FhaEFwSWcxQkFFZ05DU0FHS0FKTUlRVUxRUUFoQkVGL0lRZ0NmMEVBSUFVdEFBQkJMa2NOQUJvZ0JTMEFBVUVxUmdSQUFuOENRQ0FGTEFBQ1FUQnJJZ2RCQ1VzTkFDQUZMUUFEUVNSSERRQWdCVUVFYWlFRkFuOGdBRVVFUUNBRElBZEJBblJxUVFvMkFnQkJBQXdCQ3lBQ0lBZEJBM1JxS0FJQUN3d0JDeUFRRFFZZ0JVRUNhaUVGUVFBZ0FFVU5BQm9nQVNBQktBSUFJZ2RCQkdvMkFnQWdCeWdDQUFzaENDQUdJQVUyQWt3Z0NFRUFUZ3dCQ3lBR0lBVkJBV28yQWt3Z0JrSE1BR29RS1NFSUlBWW9Ba3doQlVFQkN5RVJBMEFnQkNFU1FSd2hCeUFGSWhZc0FBQWlCRUg3QUd0QlJra05DaUFGUVFGcUlRVWdCQ0FTUVRwc2FrR1BJV290QUFBaUJFRUJhMEVJU1EwQUN5QUdJQVUyQWt3Q1FDQUVRUnRIQkVBZ0JFVU5DeUFPUVFCT0JFQWdBRVVFUUNBRElBNUJBblJxSUFRMkFnQU1Dd3NnQmlBQ0lBNUJBM1JxS1FNQU53TkFEQUlMSUFCRkRRY2dCa0ZBYXlBRUlBRVFLQXdCQ3lBT1FRQk9EUXBCQUNFRUlBQkZEUWNMSUFBdEFBQkJJSEVOQ2lBS1FmLy9lM0VpQ1NBS0lBcEJnTUFBY1JzaENrRUFJUTVCN0FnaEV5QVBJUWNDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FDQVdMQUFBSWdSQlUzRWdCQ0FFUVE5eFFRTkdHeUFFSUJJYklnUkIyQUJyRGlFRUZCUVVGQlFVRkJRT0ZBOEdEZzRPRkFZVUZCUVVBZ1VERkJRSkZBRVVGQVFBQ3dKQUlBUkJ3UUJyRGdjT0ZBc1VEZzRPQUFzZ0JFSFRBRVlOQ1F3VEN5QUdLUU5BSVJwQjdBZ01CUXRCQUNFRUFrQUNRQUpBQWtBQ1FBSkFBa0FnRWtIL0FYRU9DQUFCQWdNRUdnVUdHZ3NnQmlnQ1FDQU1OZ0lBREJrTElBWW9Ba0FnRERZQ0FBd1lDeUFHS0FKQUlBeXNOd01BREJjTElBWW9Ba0FnRERzQkFBd1dDeUFHS0FKQUlBdzZBQUFNRlFzZ0JpZ0NRQ0FNTmdJQURCUUxJQVlvQWtBZ0RLdzNBd0FNRXd0QkNDQUlJQWhCQ0UwYklRZ2dDa0VJY2lFS1FmZ0FJUVFMSUE4aEN5QUdLUU5BSWhwQ0FGSUVRQ0FFUVNCeElRVURRQ0FMUVFGcklnc2dHcWRCRDNGQm9DVnFMUUFBSUFWeU9nQUFJQnBDRDFZaEdDQWFRZ1NJSVJvZ0dBMEFDd3NnQmlrRFFGQU5BeUFLUVFoeFJRMERJQVJCQkhaQjdBaHFJUk5CQWlFT0RBTUxJQThoQkNBR0tRTkFJaHBDQUZJRVFBTkFJQVJCQVdzaUJDQWFwMEVIY1VFd2Nqb0FBQ0FhUWdkV0lSa2dHa0lEaUNFYUlCa05BQXNMSUFRaEN5QUtRUWh4UlEwQ0lBZ2dEeUFFYXlJRVFRRnFJQVFnQ0VnYklRZ01BZ3NnQmlrRFFDSWFRZ0JUQkVBZ0JrSUFJQnA5SWhvM0EwQkJBU0VPUWV3SURBRUxJQXBCZ0JCeEJFQkJBU0VPUWUwSURBRUxRZTRJUWV3SUlBcEJBWEVpRGhzTElSTWdHaUFQRUE0aEN3c2dFU0FJUVFCSWNRMFBJQXBCLy85N2NTQUtJQkViSVFvQ1FDQUdLUU5BSWhwQ0FGSU5BQ0FJRFFBZ0R5RUxRUUFoQ0F3TUN5QUlJQnBRSUE4Z0MydHFJZ1FnQkNBSVNCc2hDQXdMQ3dKL1FmLy8vLzhISUFnZ0NFSC8vLy8vQjA4Yklnb2lCVUVBUnlFSEFrQUNRQUpBSUFZb0FrQWlCRUhtQ1NBRUd5SUxJZ1JCQTNGRkRRQWdCVVVOQUFOQUlBUXRBQUJGRFFJZ0JVRUJheUlGUVFCSElRY2dCRUVCYWlJRVFRTnhSUTBCSUFVTkFBc0xJQWRGRFFFQ1FDQUVMUUFBUlEwQUlBVkJCRWtOQUFOQUlBUW9BZ0FpQjBGL2N5QUhRWUdDaEFocmNVR0FnWUtFZUhFTkFpQUVRUVJxSVFRZ0JVRUVheUlGUVFOTERRQUxDeUFGUlEwQkN3TkFJQVFnQkMwQUFFVU5BaG9nQkVFQmFpRUVJQVZCQVdzaUJRMEFDd3RCQUFzaUJDQUxheUFLSUFRYklnUWdDMm9oQnlBSVFRQk9CRUFnQ1NFS0lBUWhDQXdMQ3lBSklRb2dCQ0VJSUFjdEFBQU5EZ3dLQ3lBSUJFQWdCaWdDUUF3Q0MwRUFJUVFnQUVFZ0lBMUJBQ0FLRUFZTUFnc2dCa0VBTmdJTUlBWWdCaWtEUUQ0Q0NDQUdJQVpCQ0dvaUJEWUNRRUYvSVFnZ0JBc2hDVUVBSVFRRFFBSkFJQWtvQWdBaUMwVU5BQ0FHUVFScUlBc1FKaUlMUVFCSURROGdDeUFJSUFSclN3MEFJQWxCQkdvaENTQUVJQXRxSWdRZ0NFa05BUXNMUVQwaEJ5QUVRUUJJRFF3Z0FFRWdJQTBnQkNBS0VBWWdCRVVFUUVFQUlRUU1BUXRCQUNFSElBWW9Ba0FoQ1FOQUlBa29BZ0FpQzBVTkFTQUdRUVJxSWdnZ0N4QW1JZ3NnQjJvaUJ5QUVTdzBCSUFBZ0NDQUxFQVVnQ1VFRWFpRUpJQVFnQjBzTkFBc0xJQUJCSUNBTklBUWdDa0dBd0FCekVBWWdEU0FFSUFRZ0RVZ2JJUVFNQ0FzZ0VTQUlRUUJJY1EwSlFUMGhCeUFBSUFZckEwQWdEU0FJSUFvZ0JCQW5JZ1JCQUU0TkJ3d0tDeUFHSUFZcEEwQThBRGRCQVNFSUlCUWhDeUFKSVFvTUJBc2dCQzBBQVNFSklBUkJBV29oQkF3QUN3QUxJQUFOQ0NBUVJRMENRUUVoQkFOQUlBTWdCRUVDZEdvb0FnQWlBQVJBSUFJZ0JFRURkR29nQUNBQkVDaEJBU0VNSUFSQkFXb2lCRUVLUncwQkRBb0xDMEVCSVF3Z0JFRUtUdzBJQTBBZ0F5QUVRUUowYWlnQ0FBMEJJQVJCQVdvaUJFRUtSdzBBQ3d3SUMwRWNJUWNNQlFzZ0NDQUhJQXRySWdrZ0NDQUpTaHNpQ0NBT1FmLy8vLzhIYzBvTkEwRTlJUWNnRFNBSUlBNXFJZ1VnQlNBTlNCc2lCQ0FWU2cwRUlBQkJJQ0FFSUFVZ0NoQUdJQUFnRXlBT0VBVWdBRUV3SUFRZ0JTQUtRWUNBQkhNUUJpQUFRVEFnQ0NBSlFRQVFCaUFBSUFzZ0NSQUZJQUJCSUNBRUlBVWdDa0dBd0FCekVBWWdCaWdDVENFRkRBRUxDd3RCQUNFTURBTUxRVDBoQnd0QnVETWdCellDQUF0QmZ5RU1DeUFHUWRBQWFpUUFJQXdMZmdJQmZ3RitJQUM5SWdOQ05JaW5RZjhQY1NJQ1FmOFBSd1I4SUFKRkJFQWdBU0FBUkFBQUFBQUFBQUFBWVFSL1FRQUZJQUJFQUFBQUFBQUE4RU9pSUFFUUt5RUFJQUVvQWdCQlFHb0xOZ0lBSUFBUEN5QUJJQUpCL2dkck5nSUFJQU5DLy8vLy8vLy8vNGVBZjROQ2dJQ0FnSUNBZ1BBL2hMOEZJQUFMQzNvQkEzOENRQUpBSUFBaUFVRURjVVVOQUNBQkxRQUFSUVJBUVFBUEN3TkFJQUZCQVdvaUFVRURjVVVOQVNBQkxRQUFEUUFMREFFTEEwQWdBU0lDUVFScUlRRWdBaWdDQUNJRFFYOXpJQU5CZ1lLRUNHdHhRWUNCZ29SNGNVVU5BQXNEUUNBQ0lnRkJBV29oQWlBQkxRQUFEUUFMQ3lBQklBQnJDd0lBQzhnQ0FRWi9Jd0JCRUdzaUF5UUFJQU1nQURZQ0RDTUFRZEFCYXlJQkpBQWdBU0FBTmdMTUFTQUJRYUFCYWlJQVFRQkJLQkFIR2lBQklBRW9Bc3dCTmdMSUFRSkFRUUFnQVVISUFXb2dBVUhRQUdvZ0FCQXFRUUJJRFFCQjFDb29BZ0JCQUVnaEJrR0lLa0dJS2lnQ0FDSUVRVjl4TmdJQUFuOENRQUpBUWJncUtBSUFSUVJBUWJncVFkQUFOZ0lBUWFRcVFRQTJBZ0JCbUNwQ0FEY0RBRUcwS2lnQ0FDRUNRYlFxSUFFMkFnQU1BUXRCbUNvb0FnQU5BUXRCZjBHSUtoQWFEUUVhQzBHSUtpQUJRY2dCYWlBQlFkQUFhaUFCUWFBQmFoQXFDeUVGSUFJRWYwR0lLa0VBUVFCQnJDb29BZ0FSQWdBYVFiZ3FRUUEyQWdCQnRDb2dBallDQUVHa0trRUFOZ0lBUVp3cUtBSUFHa0dZS2tJQU53TUFRUUFGSUFVTEdrR0lLa0dJS2lnQ0FDQUVRU0J4Y2pZQ0FDQUdEUUFMSUFGQjBBRnFKQUFnQTBFUWFpUUFDNVFEQWdSL0Ezd2pBRUVRYXlJREpBQUNRQ0FBdkNJRVFmLy8vLzhIY1NJQ1FkcWZwTzRFVFFSQUlBRWdBTHNpQnlBSFJJUEl5VzB3WCtRL29rUUFBQUFBQUFBNFE2QkVBQUFBQUFBQU9NT2dJZ1pFQUFBQVVQc2grYitpb0NBR1JHTmlHbUcwRUZHK29xQWlDRGtEQUNBSVJBQUFBR0Q3SWVtL1l5RUZBbjhnQnBsRUFBQUFBQUFBNEVGakJFQWdCcW9NQVF0QmdJQ0FnSGdMSVFJZ0JRUkFJQUVnQnlBR1JBQUFBQUFBQVBDL29DSUdSQUFBQUZEN0lmbS9vcUFnQmtSallocGh0QkJSdnFLZ09RTUFJQUpCQVdzaEFnd0NDeUFJUkFBQUFHRDdJZWsvWkVVTkFTQUJJQWNnQmtRQUFBQUFBQUR3UDZBaUJrUUFBQUJRK3lINXY2S2dJQVpFWTJJYVliUVFVYjZpb0RrREFDQUNRUUZxSVFJTUFRc2dBa0dBZ0lEOEIwOEVRQ0FCSUFBZ0FKTzdPUU1BUVFBaEFnd0JDeUFESUFJZ0FrRVhka0dXQVdzaUFrRVhkR3UrdXprRENDQURRUWhxSUFNZ0FrRUJRUUFRTVNFQ0lBTXJBd0FoQmlBRVFRQklCRUFnQVNBR21qa0RBRUVBSUFKcklRSU1BUXNnQVNBR09RTUFDeUFEUVJCcUpBQWdBZ3U4Q2dNSGZ3UjhBWDRqQUVFd2F5SUVKQUFDUUFKQUFrQWdBTDBpRFVJZ2lLY2lBa0gvLy8vL0IzRWlBMEg2MUwyQUJFMEVRQ0FDUWYvL1AzRkIrOE1rUmcwQklBTkIvTEtMZ0FSTkJFQWdEVUlBV1FSQUlBRWdBRVFBQUVCVSt5SDV2NkFpQ1VReFkySWFZYlRRdmFBaUFEa0RBQ0FCSUFrZ0FLRkVNV05pR21HMDBMMmdPUU1JUVFFaEFnd0ZDeUFCSUFCRUFBQkFWUHNoK1QrZ0lnbEVNV05pR21HMDBEMmdJZ0E1QXdBZ0FTQUpJQUNoUkRGallocGh0TkE5b0RrRENFRi9JUUlNQkFzZ0RVSUFXUVJBSUFFZ0FFUUFBRUJVK3lFSndLQWlDVVF4WTJJYVliVGd2YUFpQURrREFDQUJJQWtnQUtGRU1XTmlHbUcwNEwyZ09RTUlRUUloQWd3RUN5QUJJQUJFQUFCQVZQc2hDVUNnSWdsRU1XTmlHbUcwNEQyZ0lnQTVBd0FnQVNBSklBQ2hSREZqWWhwaHRPQTlvRGtEQ0VGK0lRSU1Bd3NnQTBHN2pQR0FCRTBFUUNBRFFiejcxNEFFVFFSQUlBTkIvTExMZ0FSR0RRSWdEVUlBV1FSQUlBRWdBRVFBQURCL2ZOa1N3S0FpQ1VUS2xKT25rUTdwdmFBaUFEa0RBQ0FCSUFrZ0FLRkV5cFNUcDVFTzZiMmdPUU1JUVFNaEFnd0ZDeUFCSUFCRUFBQXdmM3paRWtDZ0lnbEV5cFNUcDVFTzZUMmdJZ0E1QXdBZ0FTQUpJQUNoUk1xVWs2ZVJEdWs5b0RrRENFRjlJUUlNQkFzZ0EwSDd3K1NBQkVZTkFTQU5RZ0JaQkVBZ0FTQUFSQUFBUUZUN0lSbkFvQ0lKUkRGallocGh0UEM5b0NJQU9RTUFJQUVnQ1NBQW9VUXhZMklhWWJUd3ZhQTVBd2hCQkNFQ0RBUUxJQUVnQUVRQUFFQlUreUVaUUtBaUNVUXhZMklhWWJUd1BhQWlBRGtEQUNBQklBa2dBS0ZFTVdOaUdtRzA4RDJnT1FNSVFYd2hBZ3dEQ3lBRFFmckQ1SWtFU3cwQkN5QUFJQUJFZzhqSmJUQmY1RCtpUkFBQUFBQUFBRGhEb0VRQUFBQUFBQUE0dzZBaUNrUUFBRUJVK3lINXY2S2dJZ3NnQ2tReFkySWFZYlRRUGFJaURLRWlDVVFZTFVSVSt5SHB2Mk1oQlFKL0lBcVpSQUFBQUFBQUFPQkJZd1JBSUFxcURBRUxRWUNBZ0lCNEN5RUNBa0FnQlFSQUlBSkJBV3NoQWlBS1JBQUFBQUFBQVBDL29DSUtSREZqWWhwaHROQTlvaUVNSUFBZ0NrUUFBRUJVK3lINXY2S2dJUXNNQVFzZ0NVUVlMVVJVK3lIcFAyUkZEUUFnQWtFQmFpRUNJQXBFQUFBQUFBQUE4RCtnSWdwRU1XTmlHbUcwMEQyaUlRd2dBQ0FLUkFBQVFGVDdJZm0vb3FBaEN3c2dBU0FMSUF5aElnQTVBd0FDUUNBRFFSUjJJZ1VnQUwxQ05JaW5RZjhQY1d0QkVVZ05BQ0FCSUFzZ0NrUUFBR0FhWWJUUVBhSWlBS0VpQ1NBS1JITndBeTZLR2FNN29pQUxJQW1oSUFDaG9TSU1vU0lBT1FNQUlBVWdBTDFDTklpblFmOFBjV3RCTWtnRVFDQUpJUXNNQVFzZ0FTQUpJQXBFQUFBQUxvb1pvenVpSWdDaElnc2dDa1RCU1NBbG1vTjdPYUlnQ1NBTG9TQUFvYUVpREtFaUFEa0RBQXNnQVNBTElBQ2hJQXloT1FNSURBRUxJQU5CZ0lEQS93ZFBCRUFnQVNBQUlBQ2hJZ0E1QXdBZ0FTQUFPUU1JUVFBaEFnd0JDeUFFUVJCcUlnSkJDSEloQnlBTlF2Ly8vLy8vLy84SGcwS0FnSUNBZ0lDQXNNRUFoTDhoQUVFQklRWURRQ0FDQW44Z0FKbEVBQUFBQUFBQTRFRmpCRUFnQUtvTUFRdEJnSUNBZ0hnTHR5SUpPUU1BSUFBZ0NhRkVBQUFBQUFBQWNFR2lJUUFnQmlFSVFRQWhCaUFISVFJZ0NBMEFDeUFFSUFBNUF5QkJBaUVDQTBBZ0FpSUZRUUZySVFJZ0JFRVFhaUlHSUFWQkEzUnFLd01BUkFBQUFBQUFBQUFBWVEwQUN5QUdJQVFnQTBFVWRrR1dDR3NnQlVFQmFrRUJFREVoQWlBRUt3TUFJUUFnRFVJQVV3UkFJQUVnQUpvNUF3QWdBU0FFS3dNSW1qa0RDRUVBSUFKcklRSU1BUXNnQVNBQU9RTUFJQUVnQkNzRENEa0RDQXNnQkVFd2FpUUFJQUlMd0JFQ0Ezd1hmeU1BUWJBRWF5SUpKQUFnQWlBQ1FRTnJRUmh0SWdoQkFDQUlRUUJLR3lJU1FXaHNhaUVNSUFSQkFuUkJzQXRxS0FJQUlnMGdBMEVCYXlJTGFrRUFUZ1JBSUFNZ0RXb2hDQ0FTSUF0cklRSURRQ0FKUWNBQ2FpQUtRUU4wYWlBQ1FRQklCSHhFQUFBQUFBQUFBQUFGSUFKQkFuUkJ3QXRxS0FJQXR3czVBd0FnQWtFQmFpRUNJQXBCQVdvaUNpQUlSdzBBQ3dzZ0RFRVlheUVQUVFBaENDQU5RUUFnRFVFQVNoc2hDaUFEUVFCTUlRNERRQUpBSUE0RVFFUUFBQUFBQUFBQUFDRUZEQUVMSUFnZ0Myb2hFVUVBSVFKRUFBQUFBQUFBQUFBaEJRTkFJQUFnQWtFRGRHb3JBd0FnQ1VIQUFtb2dFU0FDYTBFRGRHb3JBd0NpSUFXZ0lRVWdBa0VCYWlJQ0lBTkhEUUFMQ3lBSklBaEJBM1JxSUFVNUF3QWdDQ0FLUmlFWUlBaEJBV29oQ0NBWVJRMEFDMEV2SUF4cklSUkJNQ0FNYXlFUklBeEJHV3NoRlNBTklRZ0NRQU5BSUFrZ0NFRURkR29yQXdBaEJVRUFJUUlnQ0NFS0lBaEJBRXdpRUVVRVFBTkFJQWxCNEFOcUlBSkJBblJxQW44Q2Z5QUZSQUFBQUFBQUFIQStvaUlHbVVRQUFBQUFBQURnUVdNRVFDQUdxZ3dCQzBHQWdJQ0FlQXUzSWdaRUFBQUFBQUFBY01HaUlBV2dJZ1daUkFBQUFBQUFBT0JCWXdSQUlBV3FEQUVMUVlDQWdJQjRDellDQUNBSklBcEJBV3NpQ2tFRGRHb3JBd0FnQnFBaEJTQUNRUUZxSWdJZ0NFY05BQXNMQW44Z0JTQVBFQlFpQlNBRlJBQUFBQUFBQU1BL29weEVBQUFBQUFBQUlNQ2lvQ0lGbVVRQUFBQUFBQURnUVdNRVFDQUZxZ3dCQzBHQWdJQ0FlQXNoRGlBRklBNjNvU0VGQWtBQ1FBSkFBbjhnRDBFQVRDSVdSUVJBSUFoQkFuUWdDV29pQWlBQ0tBTGNBeUlDSUFJZ0VYVWlBaUFSZEdzaUNqWUMzQU1nQWlBT2FpRU9JQW9nRkhVTUFRc2dEdzBCSUFoQkFuUWdDV29vQXR3RFFSZDFDeUlMUVFCTURRSU1BUXRCQWlFTElBVkVBQUFBQUFBQTREOW1EUUJCQUNFTERBRUxRUUFoQWtFQUlRb2dFRVVFUUFOQUlBbEI0QU5xSUFKQkFuUnFJaGNvQWdBaEVFSC8vLzhISVJNQ2Z3SkFJQW9OQUVHQWdJQUlJUk1nRUEwQVFRQU1BUXNnRnlBVElCQnJOZ0lBUVFFTElRb2dBa0VCYWlJQ0lBaEhEUUFMQ3dKQUlCWU5BRUgvLy84RElRSUNRQUpBSUJVT0FnRUFBZ3RCLy8vL0FTRUNDeUFJUVFKMElBbHFJaEFnRUNnQzNBTWdBbkUyQXR3REN5QU9RUUZxSVE0Z0MwRUNSdzBBUkFBQUFBQUFBUEEvSUFXaElRVkJBaUVMSUFwRkRRQWdCVVFBQUFBQUFBRHdQeUFQRUJTaElRVUxJQVZFQUFBQUFBQUFBQUJoQkVCQkFDRUtJQWdoQWdKQUlBZ2dEVXdOQUFOQUlBbEI0QU5xSUFKQkFXc2lBa0VDZEdvb0FnQWdDbkloQ2lBQ0lBMUtEUUFMSUFwRkRRQWdEeUVNQTBBZ0RFRVlheUVNSUFsQjRBTnFJQWhCQVdzaUNFRUNkR29vQWdCRkRRQUxEQU1MUVFFaEFnTkFJQUlpQ2tFQmFpRUNJQWxCNEFOcUlBMGdDbXRCQW5ScUtBSUFSUTBBQ3lBSUlBcHFJUW9EUUNBSlFjQUNhaUFESUFocUlndEJBM1JxSUFoQkFXb2lDQ0FTYWtFQ2RFSEFDMm9vQWdDM09RTUFRUUFoQWtRQUFBQUFBQUFBQUNFRklBTkJBRW9FUUFOQUlBQWdBa0VEZEdvckF3QWdDVUhBQW1vZ0N5QUNhMEVEZEdvckF3Q2lJQVdnSVFVZ0FrRUJhaUlDSUFOSERRQUxDeUFKSUFoQkEzUnFJQVU1QXdBZ0NDQUtTQTBBQ3lBS0lRZ01BUXNMQWtBZ0JVRVlJQXhyRUJRaUJVUUFBQUFBQUFCd1FXWUVRQ0FKUWVBRGFpQUlRUUowYWdKL0FuOGdCVVFBQUFBQUFBQndQcUlpQnBsRUFBQUFBQUFBNEVGakJFQWdCcW9NQVF0QmdJQ0FnSGdMSWdLM1JBQUFBQUFBQUhEQm9pQUZvQ0lGbVVRQUFBQUFBQURnUVdNRVFDQUZxZ3dCQzBHQWdJQ0FlQXMyQWdBZ0NFRUJhaUVJREFFTEFuOGdCWmxFQUFBQUFBQUE0RUZqQkVBZ0Jhb01BUXRCZ0lDQWdIZ0xJUUlnRHlFTUN5QUpRZUFEYWlBSVFRSjBhaUFDTmdJQUMwUUFBQUFBQUFEd1B5QU1FQlFoQlFKQUlBaEJBRWdOQUNBSUlRTURRQ0FKSUFNaUFFRURkR29nQlNBSlFlQURhaUFBUVFKMGFpZ0NBTGVpT1FNQUlBQkJBV3NoQXlBRlJBQUFBQUFBQUhBK29pRUZJQUFOQUFzZ0NFRUFTQTBBSUFnaENnTkFSQUFBQUFBQUFBQUFJUVZCQUNFQ0lBMGdDQ0FLYXlJQUlBQWdEVW9iSWdOQkFFNEVRQU5BSUFKQkEzUkJrQ0ZxS3dNQUlBa2dBaUFLYWtFRGRHb3JBd0NpSUFXZ0lRVWdBaUFEUnlFWklBSkJBV29oQWlBWkRRQUxDeUFKUWFBQmFpQUFRUU4wYWlBRk9RTUFJQXBCQUVvaEdpQUtRUUZySVFvZ0dnMEFDd3NDUUFKQUFrQUNRQUpBSUFRT0JBRUNBZ0FFQzBRQUFBQUFBQUFBQUNFR0FrQWdDRUVBVEEwQUlBbEJvQUZxSUFoQkEzUnFLd01BSVFVZ0NDRUNBMEFnQ1VHZ0FXb2lBeUFDUVFOMGFpQUZJQUpCQVdzaUFFRURkQ0FEYWlJRUt3TUFJZ2NnQnlBRm9DSUZvYUE1QXdBZ0JDQUZPUU1BSUFKQkFVc2hHeUFBSVFJZ0d3MEFDeUFJUVFGR0RRQWdDRUVEZENBRGFpc0RBQ0VGSUFnaEFnTkFJQWxCb0FGcUlnTWdBa0VEZEdvZ0JTQURJQUpCQVdzaUFFRURkR29pQXlzREFDSUdJQVlnQmFBaUJhR2dPUU1BSUFNZ0JUa0RBQ0FDUVFKTElSd2dBQ0VDSUJ3TkFBdEVBQUFBQUFBQUFBQWhCaUFJUVFGR0RRQURRQ0FHSUFsQm9BRnFJQWhCQTNScUt3TUFvQ0VHSUFoQkFrb2hIU0FJUVFGcklRZ2dIUTBBQ3dzZ0NTc0RvQUVoQlNBTERRSWdBU0FGT1FNQUlBa3JBNmdCSVFVZ0FTQUdPUU1RSUFFZ0JUa0RDQXdEQzBRQUFBQUFBQUFBQUNFRklBaEJBRTRFUUFOQUlBZ2lBRUVCYXlFSUlBVWdDVUdnQVdvZ0FFRURkR29yQXdDZ0lRVWdBQTBBQ3dzZ0FTQUZtaUFGSUFzYk9RTUFEQUlMUkFBQUFBQUFBQUFBSVFVZ0NFRUFUZ1JBSUFnaEF3TkFJQU1pQUVFQmF5RURJQVVnQ1VHZ0FXb2dBRUVEZEdvckF3Q2dJUVVnQUEwQUN3c2dBU0FGbWlBRklBc2JPUU1BSUFrckE2QUJJQVdoSVFWQkFTRUNJQWhCQUVvRVFBTkFJQVVnQ1VHZ0FXb2dBa0VEZEdvckF3Q2dJUVVnQWlBSVJ5RWVJQUpCQVdvaEFpQWVEUUFMQ3lBQklBV2FJQVVnQ3hzNUF3Z01BUXNnQVNBRm1qa0RBQ0FKS3dPb0FTRUZJQUVnQnBvNUF4QWdBU0FGbWprRENBc2dDVUd3Qkdva0FDQU9RUWR4QzQ0UEFRaC9Ba0FnQVNBQUtBSU1JZ1FnQUNnQ0NDSURhMEVHZFNJQ1JnMEFBa0FnQVNBQ1N3UkFJQUVnQW1zaUJpQUFLQUlRSWdVZ0JDSURhMEVHZFUwRVFBSkFJQVpGRFFBZ0F5RUNJQVpCQTNFaUJRUkFRUUFoQkFOQUlBTDlEQUFBQUFBQUFBQUFBQUFBQUFBQUFBRDlDd0lrSUFMOURBQUFBQUFBQUFBQUFBQUFBQUFBQUFEOUN3SVVJQUw5REFBQUFBQUFBQUFBQUFBQUFBQUFBQUQ5Q3dJRUlBSkJnSUNBL0FNMkFqd2dBa0dBZ0lEOEF6WUNBQ0FDUWdBM0FqUWdBa0dBZ0lEOEF6WUNLQ0FDUVlDQWdQd0ROZ0lVSUFKQlFHc2hBaUFFUVFGcUlnUWdCVWNOQUFzTElBWkJCblFnQTJvaEF5QUdRUUZyUWYvLy94OXhRUU5KRFFBRFFDQUMvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNDSkNBQy9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0NGQ0FDL1F3QUFBQUFBQUFBQUFBQUFBQUFBQUFBL1FzQ1RDQUMvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNDWENBQy9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0NCQ0FDUWdBM0FrUWdBa0dBZ0lEOEF6WUNBQ0FDUW9DQWdQeURnSURBUHpjQ1BDQUNRWUNBZ1B3RE5nSjhJQUw5REFBQUFBQUFBQUFBQUFBQUFBQUFBQUQ5Q3dLRUFTQUNRZ0EzQWpRZ0F2ME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMExBbXdnQXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAwTEFwUUJJQUpDQURjQ3RBRWdBdjBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBMQXFRQklBSkJnSUNBL0FNMkFpZ2dBa0dBZ0lEOEF6WUNGQ0FDUVlDQWdQd0ROZ0pVSUFKQmdJQ0EvQU0yQW1nZ0FrR0FnSUQ4QXpZQ3ZBRWdBa0dBZ0lEOEF6WUNxQUVnQWtHQWdJRDhBellDbEFFZ0FrR0FnSUQ4QXpZQ2dBRWdBa0lBTndMMEFTQUMvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNDNUFFZ0F2ME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMExBdFFCSUFMOURBQUFBQUFBQUFBQUFBQUFBQUFBQUFEOUN3TEVBU0FDUVlDQWdQd0ROZ0w4QVNBQ1FZQ0FnUHdETmdMb0FTQUNRWUNBZ1B3RE5nTFVBU0FDUVlDQWdQd0ROZ0xBQVNBQ1FZQUNhaUlDSUFOSERRQUxDeUFBSUFNMkFnd01BZ3NDUUNBRElBQW9BZ2dpQW10QkJuVWlDQ0FHYWlJSFFZQ0FnQ0JKQkVCQkFDRURRZi8vL3g4Z0JTQUNheUlGUVFWMUlnSWdCeUFDSUFkTEd5QUZRY0QvLy84SFR4c2lCd1JBSUFkQmdJQ0FJRThOQWlBSFFRWjBFQXNoQXdzZ0F5QUlRUVowYWlJRUlRSWdCa0VEY1NJRkJFQURRQ0FDL1F3QUFBQUFBQUFBQUFBQUFBQUFBQUFBL1FzQ0pDQUMvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNDRkNBQy9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0NCQ0FDUVlDQWdQd0ROZ0k4SUFKQmdJQ0EvQU0yQWdBZ0FrSUFOd0kwSUFKQmdJQ0EvQU0yQWlnZ0FrR0FnSUQ4QXpZQ0ZDQUNRVUJySVFJZ0NVRUJhaUlKSUFWSERRQUxDeUFHUVFaMElBUnFJUWdnQmtFQmEwSC8vLzhmY1VFRFR3UkFBMEFnQXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAwTEFpUWdBdjBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBMQWhRZ0F2ME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMExBa3dnQXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAwTEFsd2dBdjBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBMQWdRZ0FrSUFOd0pFSUFKQmdJQ0EvQU0yQWdBZ0FrS0FnSUQ4ZzRDQXdEODNBandnQWtHQWdJRDhBellDZkNBQy9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0NoQUVnQWtJQU53STBJQUw5REFBQUFBQUFBQUFBQUFBQUFBQUFBQUQ5Q3dKc0lBTDlEQUFBQUFBQUFBQUFBQUFBQUFBQUFBRDlDd0tVQVNBQ1FnQTNBclFCSUFMOURBQUFBQUFBQUFBQUFBQUFBQUFBQUFEOUN3S2tBU0FDUVlDQWdQd0ROZ0lvSUFKQmdJQ0EvQU0yQWhRZ0FrR0FnSUQ4QXpZQ1ZDQUNRWUNBZ1B3RE5nSm9JQUpCZ0lDQS9BTTJBcndCSUFKQmdJQ0EvQU0yQXFnQklBSkJnSUNBL0FNMkFwUUJJQUpCZ0lDQS9BTTJBb0FCSUFKQ0FEY0M5QUVnQXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAwTEF1UUJJQUw5REFBQUFBQUFBQUFBQUFBQUFBQUFBQUQ5Q3dMVUFTQUMvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNDeEFFZ0FrR0FnSUQ4QXpZQy9BRWdBa0dBZ0lEOEF6WUM2QUVnQWtHQWdJRDhBellDMUFFZ0FrR0FnSUQ4QXpZQ3dBRWdBa0dBQW1vaUFpQUlSdzBBQ3dzZ0FDZ0NEQ0lDSUFBb0FnZ2lCVWNFUUFOQUlBUkJRR29pQkNBQ1FVQnFJZ0w5QUFJQS9Rc0NBQ0FFSUFMOUFBSXcvUXNDTUNBRUlBTDlBQUlnL1FzQ0lDQUVJQUw5QUFJUS9Rc0NFQ0FDSUFWSERRQUxJQUFvQWdnaEFnc2dBQ0FESUFkQkJuUnFOZ0lRSUFBZ0NEWUNEQ0FBSUFRMkFnZ2dBZ1JBSUFJUUZnc01Bd3NRRXdBTEVCSUFDeUFCSUFKUERRQWdBQ0FESUFGQkJuUnFOZ0lNQ3dKQUlBQW9BaGdnQUNnQ0ZDSURhMEVrYlNJQ0lBRkpCRUFnQUVFVWFpQUJJQUpyRURRTUFRc2dBU0FDVHcwQUlBQWdBeUFCUVNSc2FqWUNHQXNDUUNBQUtBSWtJQUFvQWlBaUEydEJCSFVpQWlBQlNRUkFJQUJCSUdvZ0FTQUNheEE3REFFTElBRWdBazhOQUNBQUlBTWdBVUVFZEdvMkFpUUxJQUFvQWpBZ0FDZ0NMQ0lEYTBFa2JTSUNJQUZKQkVBZ0FFRXNhaUFCSUFKckVEUVBDeUFCSUFKUERRQWdBQ0FESUFGQkpHeHFOZ0l3Q3d2bUNRTUVmdzU5RUhzakFFRkFhaUlESkFBZ0FDZ0NDQ0FCUVFaMGFpRUNJQUFvQWlBZ0FVRUVkR29pQlNnQ0FBUkFJQUZCSkd3aUJDQUFLQUlVYWlJQktnSU1JUWNDUUNBRktBSUVRUUZIQkVBZ0FTb0NDQ0VMSUFFcUFnUWhEaUFCS2dJQUlSQWdBU29DRkNFS0lBRXFBaEFoQ0F3QkN5QUFLQUlzSUFScUlnUXFBZ2doQ3lBRUtnSUVJUTRnQVNBQUtnSUVJZ1lnQkNvQ0FKUWdBU29DQUpJaUVEZ0NBQ0FCSUFZZ0RwUWdBU29DQkpJaURqZ0NCQ0FCSUFZZ0M1UWdBU29DQ0pJaUN6Z0NDQ0FFS2dJVUlRb2dCQ29DRUNFSUlBRWdCaUFFS2dJTWxDQUhraUlIT0FJTUlBRWdCaUFJbENBQktnSVFraUlJT0FJUUlBRWdCaUFLbENBQktnSVVraUlLT0FJVUlBUXFBaUFoRFNBRUtnSWNJUWtnQVNBR0lBUXFBaGlVSUFFcUFoaVNPQUlZSUFFZ0JpQUpsQ0FCS2dJY2tqZ0NIQ0FCSUFZZ0RaUWdBU29DSUpJNEFpQUxJQUpCQURZQ0xDQUNRUUEyQWh3Z0FrRUFOZ0lNSUFkRE5mcU9QSlJEQUFBQVA1UWlCeEFYSVEwZ0NFTTErbzQ4bEVNQUFBQS9sQ0lNRUJjaENDQUtRelg2amp5VVF3QUFBRCtVSWdvUUZ5RUdJQWNRR3lFSklBd1FHeUVNSUFJZ0N5QUpJQWlVSWc4Z0NoQWJJZ2VVSUFZZ0RTQU1sQ0lSbEpJaUNpQUdJQWtnREpRaUNaUWdCeUFOSUFpVUlneVVreUlOSUEyU0lnaVVJaElnQ1NBSGxDQU1JQWFVa2lJSklCRWdCNVFnQmlBUGxKTWlCaUFHa2lJTWxDSVBrNVE0QWlRZ0FpQUxJQVlnQ0pRaUVTQUpJQW9nQ3BJaUI1UWlFNUtVT0FJZ0lBSWdEaUFTSUErU2xEZ0NHQ0FDSUE0Z0JpQUhsQ0lQSUFrZ0NKUWlDWk9VT0FJUUlBSWdFQ0FSSUJPVGxEZ0NDQ0FDSUJBZ0R5QUprcFE0QWdRZ0FpQUxRd0FBZ0Q4Z0JpQU1sQ0lHSUFvZ0I1UWlDNUtUbERnQ0tDQUNJQTVEQUFDQVB5QUdJQTBnQ0pRaUJwS1RsRGdDRkNBQ0lCQkRBQUNBUHlBTElBYVNrNVE0QWdBZ0FpQUJLZ0lZT0FJd0lBSWdBU29DSERnQ05DQUJLZ0lnSVFZZ0FrR0FnSUQ4QXpZQ1BDQUNJQVk0QWpnZ0JTZ0NDQ0lCUVg5SEJFQWdBQ0FCRURNaEFDQUQvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNDSkNBRC9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0NGQ0FEUWdBM0FqUWdBMEdBZ0lEOEF6WUNLQ0FEUVlDQWdQd0ROZ0lVSUFQOURBQUFBQUFBQUFBQUFBQUFBQUFBQUFEOUN3SUVJQU5CZ0lDQS9BTTJBandnQTBHQWdJRDhBellDQUNBQy9Ra0NEQ0VZSUFMOUNRSUlJUmtnQXYwSkFnQWhHaUFDL1FrQ0JDRWJJQUw5Q1FJY0lSd2dBdjBKQWhnaEhTQUMvUWtDRUNFZUlBTDlDUUlVSVI4Z0F2MEpBaXdoSUNBQy9Ra0NLQ0VoSUFMOUNRSWdJU0lnQXYwSkFpUWhJeUFESUFEOUFBSXdJaFFnQXYwSkFqejk1Z0VnQVAwQUFpQWlGU0FDL1FrQ09QM21BU0FBL1FBQ0FDSVdJQUw5Q1FJdy9lWUJJQUQ5QUFJUUloY2dBdjBKQWpUOTVnSDk1QUg5NUFIOTVBSDlDd0l3SUFNZ0ZDQWcvZVlCSUJVZ0lmM21BU0FXSUNMOTVnRWdGeUFqL2VZQi9lUUIvZVFCL2VRQi9Rc0NJQ0FESUJRZ0hQM21BU0FWSUIzOTVnRWdGaUFlL2VZQklCY2dILzNtQWYza0FmM2tBZjNrQWYwTEFoQWdBeUFVSUJqOTVnRWdGU0FaL2VZQklCWWdHdjNtQVNBYklCZjk1Z0g5NUFIOTVBSDk1QUg5Q3dJQUlBSWdBLzBBQWpEOUN3SXdJQUlnQS8wQUFpRDlDd0lnSUFJZ0EvMEFBaEQ5Q3dJUUlBSWdBLzBBQWdEOUN3SUFDeUFGUVFBMkFnQUxJQU5CUUdza0FDQUNDN01EQVFkL0lBRWdBQ2dDQ0NJRUlBQW9BZ1FpQW10QkpHMU5CRUFnQUNBQkJIOGdBa0VBSUFGQkpHeEJKR3NpQUNBQVFTUndhMEVrYWlJQUVBY2dBR29GSUFJTE5nSUVEd3NDUUNBQ0lBQW9BZ0FpQm10QkpHMGlCeUFCYWlJRFFjamo4VGhKQkVCQngrUHhPQ0FFSUFaclFTUnRJZ1JCQVhRaUNDQURJQU1nQ0VrYklBUkI0L0c0SEU4YklnUUVRQ0FFUWNqajhUaFBEUUlnQkVFa2JCQUxJUVVMSUFkQkpHd2dCV29pQTBFQUlBRkJKR3hCSkdzaUFTQUJRU1J3YTBFa2FpSUhFQWNpQVNBSGFpRUhJQVVnQkVFa2JHb2hCQUpBSUFJZ0JrWUVRQ0FCSVFVTUFRc0RRQ0FEUVNScklnVWdBa0VrYXlJQktnSUFPQUlBSUFOQklHc2dBa0VnYXlvQ0FEZ0NBQ0FEUVJ4cklBSkJIR3NxQWdBNEFnQWdBMEVZYXlBQ1FSaHJLZ0lBT0FJQUlBTkJGR3NnQWtFVWF5b0NBRGdDQUNBRFFSQnJJQUpCRUdzcUFnQTRBZ0FnQTBFTWF5QUNRUXhyS2dJQU9BSUFJQU5CQ0dzZ0FrRUlheW9DQURnQ0FDQURRUVJySUFKQkJHc3FBZ0E0QWdBZ0JTRURJQUVpQWlBR1J3MEFDd3NnQUNBRU5nSUlJQUFnQnpZQ0JDQUFJQVUyQWdBZ0JnUkFJQVlRREFzUEN4QVRBQXNRRWdBTC9Bc0RCSDhnZkFON0l3QkJnQUZySWdNa0FDQUFLQUlJSUFGQkIzUnFJUUlnQUNnQ0lDQUJRUVIwYWlJRktBSUFCRUFnQVVISUFHd2lBU0FBS0FJVWFpSUVLd01ZSVFnQ2ZDQUZLQUlFUVFGSEJFQWdCQ3NERUNFTElBUXJBd0FoRENBRUt3TW9JUW9nQkNzRElDRUdJQVFyQXdnTUFRc2dBQ2dDTENBQmFpSUJLd01RSVFZZ0JDQUIvUUFEQUNBQUtnSUV1eUlIL1JRaUp2M3lBU0FFL1FBREFQM3dBU0luL1FzREFDQUVJQVlnQjZJZ0JDc0RFS0FpQ3prREVDQUVJQUVyQXhnZ0I2SWdDS0FpQ0RrREdDQUVJQUg5QUFNZ0lDYjk4Z0VnQlAwQUF5RDk4QUVpS1AwTEF5QWdBU3NEUUNFR0lBUWdBZjBBQXpBZ0p2M3lBU0FFL1FBRE1QM3dBZjBMQXpBZ0JDQUdJQWVpSUFRckEwQ2dPUU5BSUNmOUlRQWhEQ0FvL1NFQklRb2dLUDBoQUNFR0lDZjlJUUVMSVJBZ0FrSUFOd05ZSUFKQ0FEY0RPQ0FDUWdBM0F4Z2dDRVFBQUFDZ1J0K1JQNkpFQUFBQUFBQUE0RCtpSWdnUUdDRU5JQVpFQUFBQW9FYmZrVCtpUkFBQUFBQUFBT0Evb2lJSEVCZ2hEaUFLUkFBQUFLQkczNUUvb2tRQUFBQUFBQURnUDZJaUJoQVlJUThnQ0JBY0lRZ2dCeEFjSVFjZ0FpQUxJQWdnRHFJaUV5QUdFQndpQ2FJZ0R5QU5JQWVpSWdxaW9DSVJJQThnQ0NBSG9pSUlvaUFKSUEwZ0RxSWlCcUtoSWhRZ0ZLQWlFcUlpQnlBSUlBbWlJQVlnRDZLZ0lnMGdDaUFKb2lBUElCT2lvU0lKSUFtZ0loT2lJZ2Fob2prRFNDQUNJQXNnQ1NBU29pSUtJQTBnRVNBUm9DSU9vaUlJb0tJNUEwQWdBaUFRSUFjZ0JxQ2lPUU13SUFJZ0VDQUpJQTZpSWdjZ0RTQVNvaUlHb2FJNUF5QWdBaUFNSUFvZ0NLR2lPUU1RSUFJZ0RDQUhJQWFnb2prRENDQUNJQXRFQUFBQUFBQUE4RDhnQ1NBVG9pSUdJQkVnRHFJaUI2Q2hvamtEVUNBQ0lCQkVBQUFBQUFBQThEOGdCaUFVSUJLaUlnYWdvYUk1QXlnZ0FpQU1SQUFBQUFBQUFQQS9JQWNnQnFDaG9qa0RBQ0FDSUFRckF6QTVBMkFnQWlBRUt3TTRPUU5vSUFRckEwQWhCaUFDUW9DQWdJQ0FnSUQ0UHpjRGVDQUNJQVk1QTNBZ0JTZ0NDQ0lCUVg5SEJFQWdBQ0FCRURVaEFDQURRUWhxUVFCQjhBQVFCeG9nQTBLQWdJQ0FnSUNBK0Q4M0EzZ2dBMEtBZ0lDQWdJQ0ErRDgzQTFBZ0EwS0FnSUNBZ0lDQStEODNBeWdnQTBLQWdJQ0FnSUNBK0Q4M0F3QWdBaXNER0NFVklBSXJBeEFoRmlBQ0t3TUFJUmNnQWlzRENDRVlJQUlyQXpnaEdTQUNLd013SVJvZ0Fpc0RJQ0ViSUFJckF5Z2hIQ0FDS3dOWUlSMGdBaXNEVUNFZUlBSXJBMEFoSHlBQ0t3TklJU0FnQUNzRFlDRWhJQUFyQTBBaElpQUFLd01BSVNNZ0FDc0RJQ0VrSUFBckEyZ2hKU0FBS3dOSUlRc2dBQ3NEQ0NFTUlBQXJBeWdoRHlBQUt3TndJUkFnQUNzRFVDRUpJQUFyQXhBaEVTQUFLd013SVJJZ0F5QUFLd040SWhRZ0Fpc0RlQ0lOb2lBQUt3TllJZzRnQWlzRGNDSVRvaUFBS3dNWUlnb2dBaXNEWUNJSW9pQUFLd000SWdjZ0Fpc0RhQ0lHb3FDZ29Ea0RlQ0FESUJBZ0RhSWdDU0FUb2lBUklBaWlJQklnQnFLZ29LQTVBM0FnQXlBbElBMmlJQXNnRTZJZ0RDQUlvaUFQSUFhaW9LQ2dPUU5vSUFNZ0lTQU5vaUFpSUJPaUlDTWdDS0lnSkNBR29xQ2dvRGtEWUNBRElCUWdIYUlnRGlBZW9pQUtJQitpSUFjZ0lLS2dvS0E1QTFnZ0F5QVFJQjJpSUFrZ0hxSWdFU0Fmb2lBU0lDQ2lvS0NnT1FOUUlBTWdKU0Fkb2lBTElCNmlJQXdnSDZJZ0R5QWdvcUNnb0RrRFNDQURJQ0VnSGFJZ0lpQWVvaUFqSUIraUlDUWdJS0tnb0tBNUEwQWdBeUFVSUJtaUlBNGdHcUlnQ2lBYm9pQUhJQnlpb0tDZ09RTTRJQU1nRUNBWm9pQUpJQnFpSUJFZ0c2SWdFaUFjb3FDZ29Ea0RNQ0FESUNVZ0dhSWdDeUFhb2lBTUlCdWlJQThnSEtLZ29LQTVBeWdnQXlBaElCbWlJQ0lnR3FJZ0l5QWJvaUFrSUJ5aW9LQ2dPUU1nSUFNZ0ZDQVZvaUFPSUJhaUlBb2dGNklnR0NBSG9xQ2dvRGtER0NBRElCQWdGYUlnQ1NBV29pQVJJQmVpSUJnZ0VxS2dvS0E1QXhBZ0F5QWxJQldpSUFzZ0ZxSWdEQ0FYb2lBWUlBK2lvS0NnT1FNSUlBTWdJU0FWb2lBaUlCYWlJQ01nRjZJZ0pDQVlvcUNnb0RrREFDQUNJQU5CZ0FFUUZSb0xJQVZCQURZQ0FBc2dBMEdBQVdva0FDQUNDNGdMQVFkL0FrQWdBU0FBS0FJTUlnUWdBQ2dDQ0NJRGEwRUhkU0lDUmcwQUFrQWdBU0FDU3dSQUlBRWdBbXNpQmlBQUtBSVFJZ1VnQkNJRGEwRUhkVTBFUUFKQUlBWkZEUUFnQXlFQ0lBWkJBM0VpQlFSQVFRQWhCQU5BSUFKQkNHcEJBRUh3QUJBSEdpQUNRb0NBZ0lDQWdJRDRQemNEZUNBQ1FvQ0FnSUNBZ0lENFB6Y0RVQ0FDUW9DQWdJQ0FnSUQ0UHpjREtDQUNRb0NBZ0lDQWdJRDRQemNEQUNBQ1FZQUJhaUVDSUFSQkFXb2lCQ0FGUncwQUN3c2dCa0VIZENBRGFpRURJQVpCQVd0Qi8vLy9EM0ZCQTBrTkFBTkFJQUpCQ0dwQkFFSHdBQkFIR2lBQ1FvQ0FnSUNBZ0lENFB6Y0RlQ0FDUW9DQWdJQ0FnSUQ0UHpjRFVDQUNRb0NBZ0lDQWdJRDRQemNES0NBQ1FvQ0FnSUNBZ0lENFB6Y0RBQ0FDUVlnQmFrRUFRZkFBRUFjYUlBSkNnSUNBZ0lDQWdQZy9Od1A0QVNBQ1FvQ0FnSUNBZ0lENFB6Y0QwQUVnQWtLQWdJQ0FnSUNBK0Q4M0E2Z0JJQUpDZ0lDQWdJQ0FnUGcvTndPQUFTQUNRWWdDYWtFQVFmQUFFQWNhSUFKQ2dJQ0FnSUNBZ1BnL053UDRBaUFDUW9DQWdJQ0FnSUQ0UHpjRDBBSWdBa0tBZ0lDQWdJQ0ErRDgzQTZnQ0lBSkNnSUNBZ0lDQWdQZy9Od09BQWlBQ1FZZ0Rha0VBUWZBQUVBY2FJQUpDZ0lDQWdJQ0FnUGcvTndQNEF5QUNRb0NBZ0lDQWdJRDRQemNEMEFNZ0FrS0FnSUNBZ0lDQStEODNBNmdESUFKQ2dJQ0FnSUNBZ1BnL053T0FBeUFDUVlBRWFpSUNJQU5IRFFBTEN5QUFJQU0yQWd3TUFnc0NRQ0FESUFBb0FnZ2lBbXRCQjNVaUJDQUdhaUlIUVlDQWdCQkpCRUJCQUNFRFFmLy8vdzhnQlNBQ2F5SUZRUVoxSWdJZ0J5QUNJQWRMR3lBRlFZRC8vLzhIVHhzaUJ3UkFJQWRCZ0lDQUVFOE5BaUFIUVFkMEVBc2hDQXNnQ0NBRVFRZDBhaUlFSVFJZ0JrRURjU0lGQkVBRFFDQUNRUWhxUVFCQjhBQVFCeG9nQWtLQWdJQ0FnSUNBK0Q4M0EzZ2dBa0tBZ0lDQWdJQ0ErRDgzQTFBZ0FrS0FnSUNBZ0lDQStEODNBeWdnQWtLQWdJQ0FnSUNBK0Q4M0F3QWdBa0dBQVdvaEFpQURRUUZxSWdNZ0JVY05BQXNMSUFaQkIzUWdCR29oQlNBR1FRRnJRZi8vL3c5eFFRTlBCRUFEUUNBQ1FRaHFRUUJCOEFBUUJ4b2dBa0tBZ0lDQWdJQ0ErRDgzQTNnZ0FrS0FnSUNBZ0lDQStEODNBMUFnQWtLQWdJQ0FnSUNBK0Q4M0F5Z2dBa0tBZ0lDQWdJQ0ErRDgzQXdBZ0FrR0lBV3BCQUVId0FCQUhHaUFDUW9DQWdJQ0FnSUQ0UHpjRCtBRWdBa0tBZ0lDQWdJQ0ErRDgzQTlBQklBSkNnSUNBZ0lDQWdQZy9Od09vQVNBQ1FvQ0FnSUNBZ0lENFB6Y0RnQUVnQWtHSUFtcEJBRUh3QUJBSEdpQUNRb0NBZ0lDQWdJRDRQemNEK0FJZ0FrS0FnSUNBZ0lDQStEODNBOUFDSUFKQ2dJQ0FnSUNBZ1BnL053T29BaUFDUW9DQWdJQ0FnSUQ0UHpjRGdBSWdBa0dJQTJwQkFFSHdBQkFIR2lBQ1FvQ0FnSUNBZ0lENFB6Y0QrQU1nQWtLQWdJQ0FnSUNBK0Q4M0E5QURJQUpDZ0lDQWdJQ0FnUGcvTndPb0F5QUNRb0NBZ0lDQWdJRDRQemNEZ0FNZ0FrR0FCR29pQWlBRlJ3MEFDd3NnQUNnQ0RDSUNJQUFvQWdnaUEwY0VRQU5BSUFSQmdBRnJJZ1FnQWtHQUFXc2lBa0dBQVJBVkdpQUNJQU5IRFFBTElBQW9BZ2doQWdzZ0FDQUlJQWRCQjNScU5nSVFJQUFnQlRZQ0RDQUFJQVEyQWdnZ0FnUkFJQUlRRmdzTUF3c1FFd0FMRUJJQUN5QUJJQUpQRFFBZ0FDQURJQUZCQjNScU5nSU1Dd0pBSUFBb0FoZ2dBQ2dDRkNJRGEwSElBRzBpQWlBQlNRUkFJQUJCRkdvZ0FTQUNheEE4REFFTElBRWdBazhOQUNBQUlBTWdBVUhJQUd4cU5nSVlDd0pBSUFBb0FpUWdBQ2dDSUNJRGEwRUVkU0lDSUFGSkJFQWdBRUVnYWlBQklBSnJFRHNNQVFzZ0FTQUNUdzBBSUFBZ0F5QUJRUVIwYWpZQ0pBc2dBQ2dDTUNBQUtBSXNJZ05yUWNnQWJTSUNJQUZKQkVBZ0FFRXNhaUFCSUFKckVEd1BDeUFCSUFKUERRQWdBQ0FESUFGQnlBQnNhallDTUFzTEJ3QWdBQ2dDTEFzSEFDQUFLQUlnQ3djQUlBQW9BaFFMQndBZ0FDZ0NDQXZVQlFFSGZ5QUJJQUFvQWdnaUJ5QUFLQUlFSWdOclFRUjFUUVJBQWtBZ0FVVU5BQ0FESVFJZ0FVRUhjU0lGQkVBRFFDQUNRdi8vLy84UE53SUlJQUpDQURjQ0FDQUNRUkJxSVFJZ0JFRUJhaUlFSUFWSERRQUxDeUFCUVFSMElBTnFJUU1nQVVFQmEwSC8vLy8vQUhGQkIwa05BQU5BSUFKQy8vLy8vdzgzQW5nZ0FrSUFOd0p3SUFKQy8vLy8vdzgzQW1nZ0FrSUFOd0pnSUFKQy8vLy8vdzgzQWxnZ0FrSUFOd0pRSUFKQy8vLy8vdzgzQWtnZ0FrSUFOd0pBSUFKQy8vLy8vdzgzQWpnZ0FrSUFOd0l3SUFKQy8vLy8vdzgzQWlnZ0FrSUFOd0lnSUFKQy8vLy8vdzgzQWhnZ0FrSUFOd0lRSUFKQy8vLy8vdzgzQWdnZ0FrSUFOd0lBSUFKQmdBRnFJZ0lnQTBjTkFBc0xJQUFnQXpZQ0JBOExBa0FnQXlBQUtBSUFJZ0pyUVFSMUlnUWdBV29pQmtHQWdJQ0FBVWtFUUVILy8vLy9BQ0FISUFKcklnZEJBM1VpQWlBR0lBSWdCa3NiSUFkQjhQLy8vd2RQR3lJR0JFQWdCa0dBZ0lDQUFVOE5BaUFHUVFSMEVBc2hDQXNnQ0NBRVFRUjBhaUlFSVFJZ0FVRUhjU0lIQkVBRFFDQUNRdi8vLy84UE53SUlJQUpDQURjQ0FDQUNRUkJxSVFJZ0JVRUJhaUlGSUFkSERRQUxDeUFCUVFSMElBUnFJUVVnQVVFQmEwSC8vLy8vQUhGQkIwOEVRQU5BSUFKQy8vLy8vdzgzQW5nZ0FrSUFOd0p3SUFKQy8vLy8vdzgzQW1nZ0FrSUFOd0pnSUFKQy8vLy8vdzgzQWxnZ0FrSUFOd0pRSUFKQy8vLy8vdzgzQWtnZ0FrSUFOd0pBSUFKQy8vLy8vdzgzQWpnZ0FrSUFOd0l3SUFKQy8vLy8vdzgzQWlnZ0FrSUFOd0lnSUFKQy8vLy8vdzgzQWhnZ0FrSUFOd0lRSUFKQy8vLy8vdzgzQWdnZ0FrSUFOd0lBSUFKQmdBRnFJZ0lnQlVjTkFBc0xJQUFvQWdBaUFTQURSd1JBQTBBZ0JFRVFheUlFSUFOQkVHc2lBLzBBQWdEOUN3SUFJQUVnQTBjTkFBc2dBQ2dDQUNFREN5QUFJQWdnQmtFRWRHbzJBZ2dnQUNBRk5nSUVJQUFnQkRZQ0FDQURCRUFnQXhBTUN3OExFQk1BQ3hBU0FBdUxBd0VIZnlBQklBQW9BZ2dpQWlBQUtBSUVJZ05yUWNnQWJVMEVRQ0FBSUFFRWZ5QURRUUFnQVVISUFHeEJ5QUJySWdBZ0FFSElBSEJyUWNnQWFpSUFFQWNnQUdvRklBTUxOZ0lFRHdzQ1FDQURJQUFvQWdBaUJtdEJ5QUJ0SWdnZ0FXb2lCRUhrOGJnY1NRUkFRZVB4dUJ3Z0FpQUdhMEhJQUcwaUIwRUJkQ0lDSUFRZ0FpQUVTeHNnQjBIeHVKd09UeHNpQkFSQUlBUkI1UEc0SEU4TkFpQUVRY2dBYkJBTElRVUxJQVVnQ0VISUFHeHFJZ0pCQUNBQlFjZ0FiRUhJQUdzaUFTQUJRY2dBY0d0QnlBQnFJZ2NRQnlJQklBZHFJUWdnQlNBRVFjZ0FiR29oQndKQUlBTWdCa1lFUUNBQklRVU1BUXNEUUNBQ1FjZ0FheUlGSUFOQnlBQnJJZ0g5QUFNQS9Rc0RBQ0FDUVRocklBTkJPR3Y5QUFNQS9Rc0RBQ0FDUVNocklBTkJLR3Y5QUFNQS9Rc0RBQ0FDUVJocklBTkJHR3Y5QUFNQS9Rc0RBQ0FDUVFocklBTkJDR3NyQXdBNUF3QWdCU0VDSUFFaUF5QUdSdzBBQ3dzZ0FDQUhOZ0lJSUFBZ0NEWUNCQ0FBSUFVMkFnQWdCZ1JBSUFZUURBc1BDeEFUQUFzUUVnQUxHUUVCZjBHZ0t5Z0NBQ0lCSUFBZ0FTZ0NBQ2dDR0JFQkFBc1FBQ01BSUFCclFYQnhJZ0FrQUNBQUN3Y0FJQUFvQWdRTEJRQkJvd2tMQlFCQnpRa0xCUUJCa0FrTEZ3RUJmMEdnS3lnQ0FDSUFJQUFvQWdBb0FoUVJBQUFMRlFBZ0FFVUVRRUVBRHdzZ0FFSGtKaEFpUVFCSEN4b0FJQUFnQVNnQ0NDQUZFQW9FUUNBQklBSWdBeUFFRUNBTEN6Y0FJQUFnQVNnQ0NDQUZFQW9FUUNBQklBSWdBeUFFRUNBUEN5QUFLQUlJSWdBZ0FTQUNJQU1nQkNBRklBQW9BZ0FvQWhRUkNRQUxwd0VBSUFBZ0FTZ0NDQ0FFRUFvRVFBSkFJQUVvQWdRZ0FrY05BQ0FCS0FJY1FRRkdEUUFnQVNBRE5nSWNDdzhMQWtBZ0FDQUJLQUlBSUFRUUNrVU5BQUpBSUFJZ0FTZ0NFRWNFUUNBQktBSVVJQUpIRFFFTElBTkJBVWNOQVNBQlFRRTJBaUFQQ3lBQklBSTJBaFFnQVNBRE5nSWdJQUVnQVNnQ0tFRUJhallDS0FKQUlBRW9BaVJCQVVjTkFDQUJLQUlZUVFKSERRQWdBVUVCT2dBMkN5QUJRUVEyQWl3TEM0Z0NBQ0FBSUFFb0FnZ2dCQkFLQkVBQ1FDQUJLQUlFSUFKSERRQWdBU2dDSEVFQlJnMEFJQUVnQXpZQ0hBc1BDd0pBSUFBZ0FTZ0NBQ0FFRUFvRVFBSkFJQUlnQVNnQ0VFY0VRQ0FCS0FJVUlBSkhEUUVMSUFOQkFVY05BaUFCUVFFMkFpQVBDeUFCSUFNMkFpQUNRQ0FCS0FJc1FRUkdEUUFnQVVFQU93RTBJQUFvQWdnaUFDQUJJQUlnQWtFQklBUWdBQ2dDQUNnQ0ZCRUpBQ0FCTFFBMUJFQWdBVUVETmdJc0lBRXRBRFJGRFFFTUF3c2dBVUVFTmdJc0N5QUJJQUkyQWhRZ0FTQUJLQUlvUVFGcU5nSW9JQUVvQWlSQkFVY05BU0FCS0FJWVFRSkhEUUVnQVVFQk9nQTJEd3NnQUNnQ0NDSUFJQUVnQWlBRElBUWdBQ2dDQUNnQ0dCRUdBQXNMTVFBZ0FDQUJLQUlJUVFBUUNnUkFJQUVnQWlBREVDRVBDeUFBS0FJSUlnQWdBU0FDSUFNZ0FDZ0NBQ2dDSEJFSEFBc1lBQ0FBSUFFb0FnaEJBQkFLQkVBZ0FTQUNJQU1RSVFzTEZ3RUJmMEdnS3lnQ0FDSUFJQUFvQWdBb0FoQVJBQUFMbkFFQkFuOGpBRUZBYWlJREpBQUNmMEVCSUFBZ0FVRUFFQW9OQUJwQkFDQUJSUTBBR2tFQUlBRkJoQ1lRSWlJQlJRMEFHaUFEUVF4cVFRQkJOQkFIR2lBRFFRRTJBamdnQTBGL05nSVVJQU1nQURZQ0VDQURJQUUyQWdnZ0FTQURRUWhxSUFJb0FnQkJBU0FCS0FJQUtBSWNFUWNBSUFNb0FpQWlBRUVCUmdSQUlBSWdBeWdDR0RZQ0FBc2dBRUVCUmdzaEJDQURRVUJySkFBZ0JBc1hBUUYvUWFBcktBSUFJZ0FnQUNnQ0FDZ0NEQkVBQUFzWEFRRi9RYUFyS0FJQUlnQWdBQ2dDQUNnQ0NCRUFBQXNFQUVJQUN3UUFRUUFMOUFJQkNIOGpBRUVnYXlJREpBQWdBeUFBS0FJY0lnUTJBaEFnQUNnQ0ZDRUZJQU1nQWpZQ0hDQURJQUUyQWhnZ0F5QUZJQVJySWdFMkFoUWdBU0FDYWlFRlFRSWhCd0ovQWtBQ1FBSkFJQUFvQWp3Z0EwRVFhaUlCUVFJZ0EwRU1haEFBSWdRRWYwRzRNeUFFTmdJQVFYOEZRUUFMQkVBZ0FTRUVEQUVMQTBBZ0JTQURLQUlNSWdaR0RRSWdCa0VBU0FSQUlBRWhCQXdFQ3lBQklBWWdBU2dDQkNJSVN5SUpRUU4wYWlJRUlBWWdDRUVBSUFrYmF5SUlJQVFvQWdCcU5nSUFJQUZCREVFRUlBa2JhaUlCSUFFb0FnQWdDR3MyQWdBZ0JTQUdheUVGSUFBb0Fqd2dCQ0lCSUFjZ0NXc2lCeUFEUVF4cUVBQWlCZ1IvUWJneklBWTJBZ0JCZndWQkFBdEZEUUFMQ3lBRlFYOUhEUUVMSUFBZ0FDZ0NMQ0lCTmdJY0lBQWdBVFlDRkNBQUlBRWdBQ2dDTUdvMkFoQWdBZ3dCQ3lBQVFRQTJBaHdnQUVJQU53TVFJQUFnQUNnQ0FFRWdjallDQUVFQUlBZEJBa1lOQUJvZ0FpQUVLQUlFYXdzaENpQURRU0JxSkFBZ0Nnc1pBUUYvUWFBcktBSUFJZ0VnQUNBQktBSUFLQUlFRVFFQUN5Y0FJQUFnQXpnQ0JDQUJJQUpJQkVBRFFDQUFJQUVRTXhvZ0FVRUJhaUlCSUFKSERRQUxDd3VXQWdJQmZ3OTlJd0JCZ0FGcklnSWtBQ0FBS0FJSUlBRkJCblJxSWdBcUFnQWhBeUFBS2dJRUlRUWdBQ29DQ0NFRklBQXFBZ3doQmlBQUtnSVFJUWNnQUNvQ0ZDRUlJQUFxQWhnaENTQUFLZ0ljSVFvZ0FDb0NJQ0VMSUFBcUFpUWhEQ0FBS2dJb0lRMGdBQ29DTENFT0lBQXFBakFoRHlBQUtnSTBJUkFnQUNvQ09DRVJJQUlnQUNvQ1BMczVBM2dnQWlBUnV6a0RjQ0FDSUJDN09RTm9JQUlnRDdzNUEyQWdBaUFPdXprRFdDQUNJQTI3T1FOUUlBSWdETHM1QTBnZ0FrRkFheUFMdXprREFDQUNJQXE3T1FNNElBSWdDYnM1QXpBZ0FpQUl1emtES0NBQ0lBZTdPUU1nSUFJZ0JyczVBeGdnQWlBRnV6a0RFQ0FDSUFTN09RTUlJQUlnQTdzNUF3QWdBaEF1SUFKQmdBRnFKQUFMSlFBZ0FTQUFLQUlNSUFBb0FnaHJRUVoxUndSQUlBQWdBU0FBS0FJQUtBSUVFUUVBQ3dzbkFDQUFJQU00QWdRZ0FTQUNTQVJBQTBBZ0FDQUJFRFVhSUFGQkFXb2lBU0FDUncwQUN3c0xwZ0VDQVg4SGV5TUFRWUFCYXlJQ0pBQWdBQ2dDQ0NBQlFRZDBhaUlBL1FBREFDRURJQUQ5QUFNUUlRUWdBUDBBQXlBaEJTQUEvUUFETUNFR0lBRDlBQU5BSVFjZ0FQMEFBMUFoQ0NBQS9RQURZQ0VKSUFJZ0FQMEFBM0Q5Q3dSd0lBSWdDZjBMQkdBZ0FpQUkvUXNFVUNBQ1FVQnJJQWY5Q3dRQUlBSWdCdjBMQkRBZ0FpQUYvUXNFSUNBQ0lBVDlDd1FRSUFJZ0EvMExCQUFnQWhBdUlBSkJnQUZxSkFBTEpRQWdBU0FBS0FJTUlBQW9BZ2hyUVFkMVJ3UkFJQUFnQVNBQUtBSUFLQUlFRVFFQUN3di9BUUJCMUNvb0FnQWFBa0FDZjBHOENSQXNJZ0FDZjBIVUtpZ0NBRUVBU0FSQVFid0pJQUJCaUNvUUdRd0JDMEc4Q1NBQVFZZ3FFQmtMSWdFZ0FFWU5BQm9nQVFzZ0FFY05BQUpBUWRncUtBSUFRUXBHRFFCQm5Db29BZ0FpQUVHWUtpZ0NBRVlOQUVHY0tpQUFRUUZxTmdJQUlBQkJDam9BQUF3QkN5TUFRUkJySWdBa0FDQUFRUW82QUE4Q1FBSkFRWmdxS0FJQUlnRUVmeUFCQlVHSUtoQWFEUUpCbUNvb0FnQUxRWndxS0FJQUlnRkdEUUJCMkNvb0FnQkJDa1lOQUVHY0tpQUJRUUZxTmdJQUlBRkJDam9BQUF3QkMwR0lLaUFBUVE5cVFRRkJyQ29vQWdBUkFnQkJBVWNOQUNBQUxRQVBHZ3NnQUVFUWFpUUFDMEVBQ3gwQkFYOUJvQ3NvQWdBaUF5QUFJQUVnQWlBREtBSUFLQUljRVFzQUM0Y0NBUUYvUWFBcktBSUFJZ0pGQkVCQk9CQUxJZ05CQkdvaEFpQUJCRUFnQTBHSUNEWUNBQ0FDUVFBMkFqQWdBdjBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBMQWlBZ0F2ME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMExBaEFnQXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAwTEFnQWdBQVJBSUFNZ0FCQTJDMEdnS3lBRE5nSUFEd3NnQTBIZ0NqWUNBQ0FDUVFBMkFqQWdBdjBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBMQWlBZ0F2ME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMExBaEFnQXYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAwTEFnQWdBQVJBSUFNZ0FCQXlDMEdnS3lBRE5nSUFEd3NnQWlBQVFRQWdBaWdDQUNnQ0FCRURBQXNMb0NFVkFFR0VDQXVpQTJBRUFBQURBQUFBQkFBQUFBVUFBQUFHQUFBQUJ3QUFBQWdBQUFBSkFBQUFDZ0FBQURFNVRXRjBjbWw0UW1GMFkyaERiMjF3ZFhSbGNrbGtSUUF5TUVsTllYUnlhWGhDWVhSamFFTnZiWEIxZEdWeUFIZ1RBQUJCQkFBQW9CTUFBQ2dFQUFCWUJBQUFMU3NnSUNBd1dEQjRBQzB3V0Nzd1dDQXdXQzB3ZUNzd2VDQXdlQUIyWldOMGIzSUFjM1JrT2pwbGVHTmxjSFJwYjI0QWJtRnVBR0poWkY5aGNuSmhlVjl1WlhkZmJHVnVaM1JvQUdsdVpnQjNZWE50SUdoaGRtVWdiRzloWkdWa0FITjBaRG82WW1Ga1gyRnNiRzlqQUU1QlRnQkpUa1lBTGdBb2JuVnNiQ2tBV3lVdU1tWXNJQ1V1TW1Zc0lDVXVNbVlzSUNVdU1tWmREUXBiSlM0eVppd2dKUzR5Wml3Z0pTNHlaaXdnSlM0eVpsME5DbHNsTGpKbUxDQWxMakptTENBbExqSm1MQ0FsTGpKbVhRMEtXeVV1TW1Zc0lDVXVNbVlzSUNVdU1tWXNJQ1V1TW1aZERRb0FBQUFBQUFBQW5BVUFBQXNBQUFBTUFBQUFEUUFBQUE0QUFBQVBBQUFBRUFBQUFCRUFBQUFTQUFBQU1UbE5ZWFJ5YVhoQ1lYUmphRU52YlhCMWRHVnlTV1pGQUFBQUFLQVRBQUNBQlFBQVdBUUFRYkFMQzljVkF3QUFBQVFBQUFBRUFBQUFCZ0FBQUlQNW9nQkVUbTRBL0NrVkFORlhKd0RkTlBVQVl0dkFBRHlabFFCQmtFTUFZMUgrQUx2ZXF3QzNZY1VBT200a0FOSk5RZ0JKQnVBQUNlb3VBQnlTMFFEckhmNEFLYkVjQU9nK3B3RDFOWUlBUkxzdUFKenBoQUMwSm5BQVFYNWZBTmFST1FCVGd6a0FuUFE1QUl0ZmhBQW8rYjBBK0I4N0FONy9sd0FQbUFVQUVTL3ZBQXBhaXdCdEgyMEF6MzQyQUFuTEp3QkdUN2NBbm1ZL0FDM3FYd0M2SjNVQTVldkhBRDE3OFFEM09RY0FrbEtLQVB0cjZnQWZzVjhBQ0YyTkFEQURWZ0I3L0VZQThLdHJBQ0M4endBMjlKb0E0NmtkQUY1aGtRQUlHK1lBaFpsbEFLQVVYd0NOUUdnQWdOai9BQ2R6VFFBR0JqRUF5bFlWQU1tb2N3Qjc0bUFBYTR6QUFCbkVSd0ROWjhNQUNlamNBRm1ES2dDTGRzUUFwaHlXQUVTdjNRQVpWOUVBcFQ0RkFBVUgvd0F6Zmo4QXdqTG9BSmhQM2dDN2ZUSUFKajNEQUI1cjd3Q2YrRjRBTlI4NkFIL3l5Z0R4aHgwQWZKQWhBR29rZkFEVmJ2b0FNQzEzQUJVN1F3QzFGTVlBd3htZEFLM0V3Z0FzVFVFQURBQmRBSVo5UmdEamNTMEFtOGFhQUROaUFBQzAwbndBdEtlWEFEZFYxUURYUHZZQW94QVlBRTEyL0FCa25Tb0FjTmVyQUdOOCtBQjZzRmNBRnhYbkFNQkpWZ0E3MXRrQXA0UTRBQ1FqeXdEV2luY0FXbFFqQUFBZnVRRHhDaHNBR2M3ZkFKOHgvd0JtSG1vQW1WZGhBS3o3UndCK2Y5Z0FJbVczQURMb2lRRG12MkFBNzhUTkFHdzJDUUJkUDlRQUZ0N1hBRmc3M2dEZW01SUEwaUlvQUNpRzZBRGlXRTBBeHNveUFBampGZ0RnZmNzQUY4QlFBUE1kcHdBWTRGc0FMaE0wQUlNU1lnQ0RTQUVBOVk1YkFLMndmd0FlNmZJQVNFcERBQkJuMHdDcTNkZ0FybDlDQUdwaHpnQUtLS1FBMDVtMEFBYW04Z0JjZDM4QW84S0RBR0U4aUFDS2MzZ0FyNHhhQUcvWHZRQXRwbU1BOUwvTEFJMkI3d0Ftd1djQVZjcEZBTXJaTmdBb3FOSUF3bUdOQUJMSmR3QUVKaFFBRWthYkFNUlp4QURJeFVRQVRiS1JBQUFYOHdEVVE2MEFLVW5sQVAzVkVBQUF2dndBSHBUTUFIRE83Z0FUUHZVQTdQR0FBTFBud3dESCtDZ0Frd1dVQU1GeFBnQXVDYk1BQzBYekFJZ1NuQUNySUhzQUxyV2ZBRWVTd2dCN01pOEFERlZ0QUhLbmtBQnI1eDhBTWN1V0FIa1dTZ0JCZWVJQTlOK0pBT2lVbHdEaTVvUUFtVEdYQUlqdGF3QmZYellBdS8wT0FFaWF0QUJucEd3QWNYSkNBSTFkTWdDZkZiZ0F2T1VKQUkweEpRRDNkRGtBTUFVY0FBME1BUUJMQ0dnQUxPNVlBRWVxa0FCMDV3SUF2ZFlrQVBkOXBnQnVTSElBbnhidkFJNlVwZ0Mwa2ZZQTBWTlJBTThLOGdBZ21ETUE5VXQrQUxKamFBRGRQbDhBUUYwREFJV0pmd0JWVWlrQU4yVEFBRzNZRUFBeVNESUFXMHgxQUU1eDFBQkZWRzRBQ3duQkFDcjFhUUFVWnRVQUp3ZWRBRjBFVUFDME85c0E2bmJGQUlmNUZ3QkphMzBBSFNlNkFKWnBLUURHekt3QXJSUlVBSkRpYWdDSTJZa0FMSEpRQUFTa3ZnQjNCNVFBOHpCd0FBRDhKd0RxY2FnQVpzSkpBR1RnUFFDWDNZTUFveitYQUVPVS9RQU5ob3dBTVVIZUFKSTVuUURkY0l3QUY3Zm5BQWpmT3dBVk55c0FYSUNnQUZxQWt3QVFFWklBRCtqWUFHeUFyd0RiLzBzQU9KQVBBRmtZZGdCaXBSVUFZY3U3QU1lSnVRQVFRTDBBMHZJRUFFbDFKd0RydHZZQTJ5SzdBQW9VcWdDSkppOEFaSU4yQUFrN013QU9sQm9BVVRxcUFCMmp3Z0N2N2E0QVhDWVNBRzNDVFFBdGVwd0F3RmFYQUFNL2d3QUo4UFlBSzBDTUFHMHhtUUE1dEFjQURDQVZBTmpEV3dEMWtzUUF4cTFMQUU3S3BRQ25OODBBNXFrMkFLdVNsQURkUW1nQUdXUGVBSGFNN3dCb2kxSUEvTnMzQUs2aHF3RGZGVEVBQUs2aEFBejcyZ0JrVFdZQTdRVzNBQ2xsTUFCWFZyOEFSLzg2QUdyNXVRQjF2dk1BS0pQZkFLdUFNQUJtalBZQUJNc1ZBUG9pQmdEWjVCMEFQYk9rQUZjYmp3QTJ6UWtBVGtMcEFCTytwQUF6STdVQThLb2FBRTlscUFEU3dhVUFDejhQQUZ0NHpRQWorWFlBZTRzRUFJa1hjZ0RHcGxNQWIyN2lBTy9yQUFDYlNsZ0F4TnEzQUtwbXVnQjJ6ODhBMFFJZEFMSHhMUUNNbWNFQXc2MTNBSVpJMmdEM1hhQUF4b0QwQUt6d0x3RGQ3Sm9BUDF5OEFORGViUUNReHg4QUt0dTJBS01sT2dBQXI1b0FyVk9UQUxaWEJBQXBMYlFBUzRCK0FOb0hwd0IycWc0QWUxbWhBQllTS2dEY3R5MEErdVg5QUluYi9nQ0p2djBBNUhac0FBYXAvQUErZ0hBQWhXNFZBUDJIL3dBb1BnY0FZV2N6QUNvWWhnQk52ZW9BcytldkFJOXRiZ0NWWnprQU1iOWJBSVRYU0FBdzN4WUF4eTFEQUNWaE5RREpjTTRBTU11NEFMOXMvUUNrQUtJQUJXemtBRnJkb0FBaGIwY0FZaExTQUxsY2hBQndZVWtBYTFiZ0FKbFNBUUJRVlRjQUh0VzNBRFB4eEFBVGJsOEFYVERrQUlVdXFRQWRzc01Bb1RJMkFBaTNwQURxc2RRQUZ2Y2hBSTlwNUFBbi8zY0FEQU9BQUkxQUxRQlB6YUFBSUtXWkFMT2kwd0F2WFFvQXRQbENBQkhheXdCOXZ0QUFtOXZCQUtzWHZRREtvb0VBQ0dwY0FDNVZGd0FuQUZVQWZ4VHdBT0VIaGdBVUMyUUFsa0dOQUllKzNnRGEvU29BYXlXMkFIdUpOQUFGOC80QXViK2VBR2hxVHdCS0txZ0FUOFJhQUMzNHZBRFhXcGdBOU1lVkFBMU5qUUFnT3FZQXBGZGZBQlEvc1FDQU9KVUF6Q0FCQUhIZGhnREozcllBdjJEMUFFMWxFUUFCQjJzQWpMQ3NBTExBMEFCUlZVZ0FIdnNPQUpWeXd3Q2pCanNBd0VBMUFBYmNld0RnUmN3QVRpbjZBTmJLeUFEbzgwRUFmR1RlQUp0azJBRFp2akVBcEpmREFIZFkxQUJwNDhVQThOb1RBTG82UEFCR0dFWUFWWFZmQU5LOTlRQnVrc1lBckM1ZEFBNUU3UUFjUGtJQVljU0hBQ245NlFEbjF2TUFJbnpLQUcrUk5RQUk0TVVBLzllTkFHNXE0Z0N3L2NZQWt3akJBSHhkZEFCcnJiSUF6VzZkQUQ1eWV3REdFV29BOTgrcEFDbHozd0MxeWJvQXR3QlJBT0t5RFFCMHVpUUE1WDFnQUhUWWlnQU5GU3dBZ1JnTUFINW1sQUFCS1JZQW4zcDJBUDM5dmdCV1JlOEEyWDQyQU96WkV3Q0x1cmtBeEpmOEFER29Kd0R4YnNNQWxNVTJBTmlvVmdDMHFMVUF6OHdPQUJLSkxRQnZWelFBTEZhSkFKbk80d0RXSUxrQWExNnFBRDRxbkFBUlg4d0EvUXRLQU9IMCt3Q09PMjBBNG9Zc0FPblVoQUQ4dEtrQTcrN1JBQzQxeVFBdk9XRUFPQ0ZFQUJ2WnlBQ0IvQW9BKzBwcUFDOGMyQUJUdElRQVRwbU1BRlFpekFBcVZkd0F3TWJXQUFzWmxnQWFjTGdBYVpWa0FDWmFZQUEvVXU0QWZ4RVBBUFMxRVFEOHkvVUFOTHd0QURTODdnRG9YY3dBM1Y1Z0FHZU9td0NTTSs4QXlSZTRBR0ZZbXdEaFY3d0FVWVBHQU5nK0VBRGRjVWdBTFJ6ZEFLOFlvUUFoTEVZQVdmUFhBTmw2bUFDZVZNQUFUNGI2QUZZRy9BRGxlYTRBaVNJMkFEaXRJZ0Juazl3QVZlaXFBSUltT0FESzU1c0FVUTJrQUprenNRQ3AxdzRBYVFWSUFHV3k4QUIvaUtjQWlFeVhBUG5STmdBaGtyTUFlNEpLQUpqUElRQkFuOXdBM0VkVkFPRjBPZ0JuNjBJQS9wM2ZBRjdVWHdCN1o2UUF1cXg2QUZYMm9nQXJpQ01BUWJwVkFGbHVDQUFoS29ZQU9VZURBSW5qNWdEbG50UUFTZnRBQVA5VzZRQWNEOG9BeFZtS0FKVDZLd0RUd2NVQUQ4WFBBTnRhcmdCSHhZWUFoVU5pQUNHR093QXNlWlFBRUdHSEFDcE1ld0NBTEJvQVE3OFNBSWdta0FCNFBJa0FxTVRrQU9YYmV3REVPc0lBSnZUcUFQZG5pZ0FOa3I4QVphTXJBRDJUc1FDOWZBc0FwRkhjQUNmZFl3QnA0ZDBBbXBRWkFLZ3BsUUJvemlnQUNlMjBBRVNmSUFCT21Nb0FjSUpqQUg1OEl3QVB1VElBcC9XT0FCUlc1d0FoOFFnQXRaMHFBRzkrVFFDbEdWRUF0Zm1yQUlMZjFnQ1czV0VBRmpZQ0FNUTZud0NEb3FFQWN1MXRBRG1OZWdDQ3VLa0FhekpjQUVZbld3QUFOTzBBMGdCM0FQejBWUUFCV1UwQTRIR0FBRUdUSVF0K1FQc2grVDhBQUFBQUxVUjBQZ0FBQUlDWVJ2ZzhBQUFBWUZITWVEc0FBQUNBZ3h2d09RQUFBRUFnSlhvNEFBQUFnQ0tDNHpZQUFBQUFIZk5wTlJrQUNnQVpHUmtBQUFBQUJRQUFBQUFBQUFrQUFBQUFDd0FBQUFBQUFBQUFHUUFSQ2hrWkdRTUtCd0FCQUFrTEdBQUFDUVlMQUFBTEFBWVpBQUFBR1JrWkFFR2hJZ3NoRGdBQUFBQUFBQUFBR1FBS0RSa1pHUUFOQUFBQ0FBa09BQUFBQ1FBT0FBQU9BRUhiSWdzQkRBQkI1eUlMRlJNQUFBQUFFd0FBQUFBSkRBQUFBQUFBREFBQURBQkJsU01MQVJBQVFhRWpDeFVQQUFBQUJBOEFBQUFBQ1JBQUFBQUFBQkFBQUJBQVFjOGpDd0VTQUVIYkl3c2VFUUFBQUFBUkFBQUFBQWtTQUFBQUFBQVNBQUFTQUFBYUFBQUFHaG9hQUVHU0pBc09HZ0FBQUJvYUdnQUFBQUFBQUFrQVFjTWtDd0VVQUVIUEpBc1ZGd0FBQUFBWEFBQUFBQWtVQUFBQUFBQVVBQUFVQUVIOUpBc0JGZ0JCaVNVTC9RUVZBQUFBQUJVQUFBQUFDUllBQUFBQUFCWUFBQllBQURBeE1qTTBOVFkzT0RsQlFrTkVSVVpPTVRCZlgyTjRlR0ZpYVhZeE1UWmZYM05vYVcxZmRIbHdaVjlwYm1adlJRQUFBQUNnRXdBQXNCSUFBQUFWQUFCT01UQmZYMk40ZUdGaWFYWXhNVGRmWDJOc1lYTnpYM1I1Y0dWZmFXNW1iMFVBQUFDZ0V3QUE0QklBQU5RU0FBQk9NVEJmWDJONGVHRmlhWFl4TVRkZlgzQmlZWE5sWDNSNWNHVmZhVzVtYjBVQUFBQ2dFd0FBRUJNQUFOUVNBQUJPTVRCZlgyTjRlR0ZpYVhZeE1UbGZYM0J2YVc1MFpYSmZkSGx3WlY5cGJtWnZSUUNnRXdBQVFCTUFBRFFUQUFBQUFBQUFCQk1BQUJjQUFBQVlBQUFBR1FBQUFCb0FBQUFiQUFBQUhBQUFBQjBBQUFBZUFBQUFBQUFBQU9nVEFBQVhBQUFBSHdBQUFCa0FBQUFhQUFBQUd3QUFBQ0FBQUFBaEFBQUFJZ0FBQUU0eE1GOWZZM2g0WVdKcGRqRXlNRjlmYzJsZlkyeGhjM05mZEhsd1pWOXBibVp2UlFBQUFBQ2dFd0FBd0JNQUFBUVRBQUFBQUFBQVdCUUFBQUVBQUFBakFBQUFKQUFBQUFBQUFBQ0FGQUFBQVFBQUFDVUFBQUFtQUFBQUFBQUFBRUFVQUFBQkFBQUFKd0FBQUNnQUFBQlRkRGxsZUdObGNIUnBiMjRBQUFBQWVCTUFBREFVQUFCVGREbGlZV1JmWVd4c2IyTUFBQUFBb0JNQUFFZ1VBQUJBRkFBQVUzUXlNR0poWkY5aGNuSmhlVjl1WlhkZmJHVnVaM1JvQUFBQUFLQVRBQUJrRkFBQVdCUUFBQUFBQUFDd0ZBQUFBZ0FBQUNrQUFBQXFBQUFBVTNReE1XeHZaMmxqWDJWeWNtOXlBS0FUQUFDZ0ZBQUFRQlFBQUFBQUFBRGtGQUFBQWdBQUFDc0FBQUFxQUFBQVUzUXhNbXhsYm1kMGFGOWxjbkp2Y2dBQUFBQ2dFd0FBMEJRQUFMQVVBQUJUZERsMGVYQmxYMmx1Wm04QUFBQUFlQk1BQVBBVUFFR0lLZ3NCQlFCQmxDb0xBUk1BUWF3cUN3NFVBQUFBRlFBQUFMZ1ZBQUFBQkFCQnhDb0xBUUVBUWRRcUN3WC8vLy8vQ2dCQm1Dc0xBM0FjQVE9PSI7aWYoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpe3dhc21CaW5hcnlGaWxlPWxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpfWZ1bmN0aW9uIGdldEJpbmFyeVN5bmMoZmlsZSl7aWYoZmlsZT09d2FzbUJpbmFyeUZpbGUmJndhc21CaW5hcnkpe3JldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KX12YXIgYmluYXJ5PXRyeVBhcnNlQXNEYXRhVVJJKGZpbGUpO2lmKGJpbmFyeSl7cmV0dXJuIGJpbmFyeX1pZihyZWFkQmluYXJ5KXtyZXR1cm4gcmVhZEJpbmFyeShmaWxlKX10aHJvdyJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZCJ9ZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+Z2V0QmluYXJ5U3luYyhiaW5hcnlGaWxlKSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMscmVjZWl2ZXIpe3JldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpLnRoZW4oYmluYXJ5PT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksaW1wb3J0cykpLnRoZW4ocmVjZWl2ZXIscmVhc29uPT57ZXJyKGBmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAke3JlYXNvbn1gKTthYm9ydChyZWFzb24pfSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBc3luYyhiaW5hcnksYmluYXJ5RmlsZSxpbXBvcnRzLGNhbGxiYWNrKXtyZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMsY2FsbGJhY2spfWZ1bmN0aW9uIGNyZWF0ZVdhc20oKXt2YXIgaW5mbz17ImEiOndhc21JbXBvcnRzfTtmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsbW9kdWxlKXt3YXNtRXhwb3J0cz1pbnN0YW5jZS5leHBvcnRzO3dhc21NZW1vcnk9d2FzbUV4cG9ydHNbImYiXTt1cGRhdGVNZW1vcnlWaWV3cygpO2FkZE9uSW5pdCh3YXNtRXhwb3J0c1siZyJdKTtyZW1vdmVSdW5EZXBlbmRlbmN5KCJ3YXNtLWluc3RhbnRpYXRlIik7cmV0dXJuIHdhc21FeHBvcnRzfWFkZFJ1bkRlcGVuZGVuY3koIndhc20taW5zdGFudGlhdGUiKTtmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpe3JlY2VpdmVJbnN0YW5jZShyZXN1bHRbImluc3RhbmNlIl0pfWlmKE1vZHVsZVsiaW5zdGFudGlhdGVXYXNtIl0pe3RyeXtyZXR1cm4gTW9kdWxlWyJpbnN0YW50aWF0ZVdhc20iXShpbmZvLHJlY2VpdmVJbnN0YW5jZSl9Y2F0Y2goZSl7ZXJyKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2V9YCk7cmVhZHlQcm9taXNlUmVqZWN0KGUpfX1pbnN0YW50aWF0ZUFzeW5jKHdhc21CaW5hcnksd2FzbUJpbmFyeUZpbGUsaW5mbyxyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCkuY2F0Y2gocmVhZHlQcm9taXNlUmVqZWN0KTtyZXR1cm57fX1mdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cyl7dGhpcy5uYW1lPSJFeGl0U3RhdHVzIjt0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtzdGF0dXN9KWA7dGhpcy5zdGF0dXM9c3RhdHVzfXZhciBjYWxsUnVudGltZUNhbGxiYWNrcz1jYWxsYmFja3M9Pnt3aGlsZShjYWxsYmFja3MubGVuZ3RoPjApe2NhbGxiYWNrcy5zaGlmdCgpKE1vZHVsZSl9fTt2YXIgbm9FeGl0UnVudGltZT1Nb2R1bGVbIm5vRXhpdFJ1bnRpbWUiXXx8dHJ1ZTtjbGFzcyBFeGNlcHRpb25JbmZve2NvbnN0cnVjdG9yKGV4Y1B0cil7dGhpcy5leGNQdHI9ZXhjUHRyO3RoaXMucHRyPWV4Y1B0ci0yNH1zZXRfdHlwZSh0eXBlKXtIRUFQVTMyW3RoaXMucHRyKzQ+PjJdPXR5cGV9Z2V0X3R5cGUoKXtyZXR1cm4gSEVBUFUzMlt0aGlzLnB0cis0Pj4yXX1zZXRfZGVzdHJ1Y3RvcihkZXN0cnVjdG9yKXtIRUFQVTMyW3RoaXMucHRyKzg+PjJdPWRlc3RydWN0b3J9Z2V0X2Rlc3RydWN0b3IoKXtyZXR1cm4gSEVBUFUzMlt0aGlzLnB0cis4Pj4yXX1zZXRfY2F1Z2h0KGNhdWdodCl7Y2F1Z2h0PWNhdWdodD8xOjA7SEVBUDhbdGhpcy5wdHIrMTJdPWNhdWdodH1nZXRfY2F1Z2h0KCl7cmV0dXJuIEhFQVA4W3RoaXMucHRyKzEyXSE9MH1zZXRfcmV0aHJvd24ocmV0aHJvd24pe3JldGhyb3duPXJldGhyb3duPzE6MDtIRUFQOFt0aGlzLnB0cisxM109cmV0aHJvd259Z2V0X3JldGhyb3duKCl7cmV0dXJuIEhFQVA4W3RoaXMucHRyKzEzXSE9MH1pbml0KHR5cGUsZGVzdHJ1Y3Rvcil7dGhpcy5zZXRfYWRqdXN0ZWRfcHRyKDApO3RoaXMuc2V0X3R5cGUodHlwZSk7dGhpcy5zZXRfZGVzdHJ1Y3RvcihkZXN0cnVjdG9yKX1zZXRfYWRqdXN0ZWRfcHRyKGFkanVzdGVkUHRyKXtIRUFQVTMyW3RoaXMucHRyKzE2Pj4yXT1hZGp1c3RlZFB0cn1nZXRfYWRqdXN0ZWRfcHRyKCl7cmV0dXJuIEhFQVBVMzJbdGhpcy5wdHIrMTY+PjJdfWdldF9leGNlcHRpb25fcHRyKCl7dmFyIGlzUG9pbnRlcj1fX19jeGFfaXNfcG9pbnRlcl90eXBlKHRoaXMuZ2V0X3R5cGUoKSk7aWYoaXNQb2ludGVyKXtyZXR1cm4gSEVBUFUzMlt0aGlzLmV4Y1B0cj4+Ml19dmFyIGFkanVzdGVkPXRoaXMuZ2V0X2FkanVzdGVkX3B0cigpO2lmKGFkanVzdGVkIT09MClyZXR1cm4gYWRqdXN0ZWQ7cmV0dXJuIHRoaXMuZXhjUHRyfX12YXIgZXhjZXB0aW9uTGFzdD0wO3ZhciB1bmNhdWdodEV4Y2VwdGlvbkNvdW50PTA7dmFyIF9fX2N4YV90aHJvdz0ocHRyLHR5cGUsZGVzdHJ1Y3Rvcik9Pnt2YXIgaW5mbz1uZXcgRXhjZXB0aW9uSW5mbyhwdHIpO2luZm8uaW5pdCh0eXBlLGRlc3RydWN0b3IpO2V4Y2VwdGlvbkxhc3Q9cHRyO3VuY2F1Z2h0RXhjZXB0aW9uQ291bnQrKzt0aHJvdyBleGNlcHRpb25MYXN0fTt2YXIgX2Fib3J0PSgpPT57YWJvcnQoIiIpfTt2YXIgX2Vtc2NyaXB0ZW5fbWVtY3B5X2pzPShkZXN0LHNyYyxudW0pPT5IRUFQVTguY29weVdpdGhpbihkZXN0LHNyYyxzcmMrbnVtKTt2YXIgZ2V0SGVhcE1heD0oKT0+MjE0NzQ4MzY0ODt2YXIgZ3Jvd01lbW9yeT1zaXplPT57dmFyIGI9d2FzbU1lbW9yeS5idWZmZXI7dmFyIHBhZ2VzPShzaXplLWIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e3dhc21NZW1vcnkuZ3JvdyhwYWdlcyk7dXBkYXRlTWVtb3J5Vmlld3MoKTtyZXR1cm4gMX1jYXRjaChlKXt9fTt2YXIgX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXA9cmVxdWVzdGVkU2l6ZT0+e3ZhciBvbGRTaXplPUhFQVBVOC5sZW5ndGg7cmVxdWVzdGVkU2l6ZT4+Pj0wO3ZhciBtYXhIZWFwU2l6ZT1nZXRIZWFwTWF4KCk7aWYocmVxdWVzdGVkU2l6ZT5tYXhIZWFwU2l6ZSl7cmV0dXJuIGZhbHNlfXZhciBhbGlnblVwPSh4LG11bHRpcGxlKT0+eCsobXVsdGlwbGUteCVtdWx0aXBsZSklbXVsdGlwbGU7Zm9yKHZhciBjdXREb3duPTE7Y3V0RG93bjw9NDtjdXREb3duKj0yKXt2YXIgb3Zlckdyb3duSGVhcFNpemU9b2xkU2l6ZSooMSsuMi9jdXREb3duKTtvdmVyR3Jvd25IZWFwU2l6ZT1NYXRoLm1pbihvdmVyR3Jvd25IZWFwU2l6ZSxyZXF1ZXN0ZWRTaXplKzEwMDY2MzI5Nik7dmFyIG5ld1NpemU9TWF0aC5taW4obWF4SGVhcFNpemUsYWxpZ25VcChNYXRoLm1heChyZXF1ZXN0ZWRTaXplLG92ZXJHcm93bkhlYXBTaXplKSw2NTUzNikpO3ZhciByZXBsYWNlbWVudD1ncm93TWVtb3J5KG5ld1NpemUpO2lmKHJlcGxhY2VtZW50KXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfTt2YXIgcHJpbnRDaGFyQnVmZmVycz1bbnVsbCxbXSxbXV07dmFyIFVURjhEZWNvZGVyPXR5cGVvZiBUZXh0RGVjb2RlciE9InVuZGVmaW5lZCI/bmV3IFRleHREZWNvZGVyKCJ1dGY4Iik6dW5kZWZpbmVkO3ZhciBVVEY4QXJyYXlUb1N0cmluZz0oaGVhcE9yQXJyYXksaWR4LG1heEJ5dGVzVG9SZWFkKT0+e3ZhciBlbmRJZHg9aWR4K21heEJ5dGVzVG9SZWFkO3ZhciBlbmRQdHI9aWR4O3doaWxlKGhlYXBPckFycmF5W2VuZFB0cl0mJiEoZW5kUHRyPj1lbmRJZHgpKSsrZW5kUHRyO2lmKGVuZFB0ci1pZHg+MTYmJmhlYXBPckFycmF5LmJ1ZmZlciYmVVRGOERlY29kZXIpe3JldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcE9yQXJyYXkuc3ViYXJyYXkoaWR4LGVuZFB0cikpfXZhciBzdHI9IiI7d2hpbGUoaWR4PGVuZFB0cil7dmFyIHUwPWhlYXBPckFycmF5W2lkeCsrXTtpZighKHUwJjEyOCkpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7Y29udGludWV9dmFyIHUxPWhlYXBPckFycmF5W2lkeCsrXSY2MztpZigodTAmMjI0KT09MTkyKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKHUwJjMxKTw8Nnx1MSk7Y29udGludWV9dmFyIHUyPWhlYXBPckFycmF5W2lkeCsrXSY2MztpZigodTAmMjQwKT09MjI0KXt1MD0odTAmMTUpPDwxMnx1MTw8Nnx1Mn1lbHNle3UwPSh1MCY3KTw8MTh8dTE8PDEyfHUyPDw2fGhlYXBPckFycmF5W2lkeCsrXSY2M31pZih1MDw2NTUzNil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKX1lbHNle3ZhciBjaD11MC02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpfX1yZXR1cm4gc3RyfTt2YXIgcHJpbnRDaGFyPShzdHJlYW0sY3Vycik9Pnt2YXIgYnVmZmVyPXByaW50Q2hhckJ1ZmZlcnNbc3RyZWFtXTtpZihjdXJyPT09MHx8Y3Vycj09PTEwKXsoc3RyZWFtPT09MT9vdXQ6ZXJyKShVVEY4QXJyYXlUb1N0cmluZyhidWZmZXIsMCkpO2J1ZmZlci5sZW5ndGg9MH1lbHNle2J1ZmZlci5wdXNoKGN1cnIpfX07dmFyIFVURjhUb1N0cmluZz0ocHRyLG1heEJ5dGVzVG9SZWFkKT0+cHRyP1VURjhBcnJheVRvU3RyaW5nKEhFQVBVOCxwdHIsbWF4Qnl0ZXNUb1JlYWQpOiIiO3ZhciBTWVNDQUxMUz17dmFyYXJnczp1bmRlZmluZWQsZ2V0KCl7dmFyIHJldD1IRUFQMzJbK1NZU0NBTExTLnZhcmFyZ3M+PjJdO1NZU0NBTExTLnZhcmFyZ3MrPTQ7cmV0dXJuIHJldH0sZ2V0cCgpe3JldHVybiBTWVNDQUxMUy5nZXQoKX0sZ2V0U3RyKHB0cil7dmFyIHJldD1VVEY4VG9TdHJpbmcocHRyKTtyZXR1cm4gcmV0fX07dmFyIF9mZF93cml0ZT0oZmQsaW92LGlvdmNudCxwbnVtKT0+e3ZhciBudW09MDtmb3IodmFyIGk9MDtpPGlvdmNudDtpKyspe3ZhciBwdHI9SEVBUFUzMltpb3Y+PjJdO3ZhciBsZW49SEVBUFUzMltpb3YrND4+Ml07aW92Kz04O2Zvcih2YXIgaj0wO2o8bGVuO2orKyl7cHJpbnRDaGFyKGZkLEhFQVBVOFtwdHIral0pfW51bSs9bGVufUhFQVBVMzJbcG51bT4+Ml09bnVtO3JldHVybiAwfTt2YXIgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXI9MDt2YXIga2VlcFJ1bnRpbWVBbGl2ZT0oKT0+bm9FeGl0UnVudGltZXx8cnVudGltZUtlZXBhbGl2ZUNvdW50ZXI+MDt2YXIgX3Byb2NfZXhpdD1jb2RlPT57RVhJVFNUQVRVUz1jb2RlO2lmKCFrZWVwUnVudGltZUFsaXZlKCkpe01vZHVsZVsib25FeGl0Il0/Lihjb2RlKTtBQk9SVD10cnVlfXF1aXRfKGNvZGUsbmV3IEV4aXRTdGF0dXMoY29kZSkpfTt2YXIgZXhpdEpTPShzdGF0dXMsaW1wbGljaXQpPT57RVhJVFNUQVRVUz1zdGF0dXM7X3Byb2NfZXhpdChzdGF0dXMpfTt2YXIgaGFuZGxlRXhjZXB0aW9uPWU9PntpZihlIGluc3RhbmNlb2YgRXhpdFN0YXR1c3x8ZT09InVud2luZCIpe3JldHVybiBFWElUU1RBVFVTfXF1aXRfKDEsZSl9O3ZhciBsZW5ndGhCeXRlc1VURjg9c3RyPT57dmFyIGxlbj0wO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciBjPXN0ci5jaGFyQ29kZUF0KGkpO2lmKGM8PTEyNyl7bGVuKyt9ZWxzZSBpZihjPD0yMDQ3KXtsZW4rPTJ9ZWxzZSBpZihjPj01NTI5NiYmYzw9NTczNDMpe2xlbis9NDsrK2l9ZWxzZXtsZW4rPTN9fXJldHVybiBsZW59O3ZhciBzdHJpbmdUb1VURjhBcnJheT0oc3RyLGhlYXAsb3V0SWR4LG1heEJ5dGVzVG9Xcml0ZSk9PntpZighKG1heEJ5dGVzVG9Xcml0ZT4wKSlyZXR1cm4gMDt2YXIgc3RhcnRJZHg9b3V0SWR4O3ZhciBlbmRJZHg9b3V0SWR4K21heEJ5dGVzVG9Xcml0ZS0xO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciB1PXN0ci5jaGFyQ29kZUF0KGkpO2lmKHU+PTU1Mjk2JiZ1PD01NzM0Myl7dmFyIHUxPXN0ci5jaGFyQ29kZUF0KCsraSk7dT02NTUzNisoKHUmMTAyMyk8PDEwKXx1MSYxMDIzfWlmKHU8PTEyNyl7aWYob3V0SWR4Pj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109dX1lbHNlIGlmKHU8PTIwNDcpe2lmKG91dElkeCsxPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MTkyfHU+PjY7aGVhcFtvdXRJZHgrK109MTI4fHUmNjN9ZWxzZSBpZih1PD02NTUzNSl7aWYob3V0SWR4KzI+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0yMjR8dT4+MTI7aGVhcFtvdXRJZHgrK109MTI4fHU+PjYmNjM7aGVhcFtvdXRJZHgrK109MTI4fHUmNjN9ZWxzZXtpZihvdXRJZHgrMz49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTI0MHx1Pj4xODtoZWFwW291dElkeCsrXT0xMjh8dT4+MTImNjM7aGVhcFtvdXRJZHgrK109MTI4fHU+PjYmNjM7aGVhcFtvdXRJZHgrK109MTI4fHUmNjN9fWhlYXBbb3V0SWR4XT0wO3JldHVybiBvdXRJZHgtc3RhcnRJZHh9O3ZhciBzdHJpbmdUb1VURjg9KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKT0+c3RyaW5nVG9VVEY4QXJyYXkoc3RyLEhFQVBVOCxvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKTt2YXIgc3RyaW5nVG9VVEY4T25TdGFjaz1zdHI9Pnt2YXIgc2l6ZT1sZW5ndGhCeXRlc1VURjgoc3RyKSsxO3ZhciByZXQ9c3RhY2tBbGxvYyhzaXplKTtzdHJpbmdUb1VURjgoc3RyLHJldCxzaXplKTtyZXR1cm4gcmV0fTt2YXIgd2FzbUltcG9ydHM9e2I6X19fY3hhX3Rocm93LGM6X2Fib3J0LGU6X2Vtc2NyaXB0ZW5fbWVtY3B5X2pzLGQ6X2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAsYTpfZmRfd3JpdGV9O3ZhciB3YXNtRXhwb3J0cz1jcmVhdGVXYXNtKCk7dmFyIF9fX3dhc21fY2FsbF9jdG9ycz0oKT0+KF9fX3dhc21fY2FsbF9jdG9ycz13YXNtRXhwb3J0c1siZyJdKSgpO3ZhciBfaW5pdGlhbGl6ZT1Nb2R1bGVbIl9pbml0aWFsaXplIl09KGEwLGExLGEyKT0+KF9pbml0aWFsaXplPU1vZHVsZVsiX2luaXRpYWxpemUiXT13YXNtRXhwb3J0c1siaCJdKShhMCxhMSxhMik7dmFyIF9hbGxvY01hdHJpeD1Nb2R1bGVbIl9hbGxvY01hdHJpeCJdPWEwPT4oX2FsbG9jTWF0cml4PU1vZHVsZVsiX2FsbG9jTWF0cml4Il09d2FzbUV4cG9ydHNbImkiXSkoYTApO3ZhciBfZ2V0TWF0cml4QnVmZmVyUHRyPU1vZHVsZVsiX2dldE1hdHJpeEJ1ZmZlclB0ciJdPSgpPT4oX2dldE1hdHJpeEJ1ZmZlclB0cj1Nb2R1bGVbIl9nZXRNYXRyaXhCdWZmZXJQdHIiXT13YXNtRXhwb3J0c1siaiJdKSgpO3ZhciBfZ2V0U1JUUHRyPU1vZHVsZVsiX2dldFNSVFB0ciJdPSgpPT4oX2dldFNSVFB0cj1Nb2R1bGVbIl9nZXRTUlRQdHIiXT13YXNtRXhwb3J0c1siayJdKSgpO3ZhciBfZ2V0SW5mb1B0cj1Nb2R1bGVbIl9nZXRJbmZvUHRyIl09KCk9PihfZ2V0SW5mb1B0cj1Nb2R1bGVbIl9nZXRJbmZvUHRyIl09d2FzbUV4cG9ydHNbImwiXSkoKTt2YXIgX2dldENvbnRpbnVlZFNSVFB0cj1Nb2R1bGVbIl9nZXRDb250aW51ZWRTUlRQdHIiXT0oKT0+KF9nZXRDb250aW51ZWRTUlRQdHI9TW9kdWxlWyJfZ2V0Q29udGludWVkU1JUUHRyIl09d2FzbUV4cG9ydHNbIm0iXSkoKTt2YXIgX3ByaW50TWF0cml4PU1vZHVsZVsiX3ByaW50TWF0cml4Il09YTA9PihfcHJpbnRNYXRyaXg9TW9kdWxlWyJfcHJpbnRNYXRyaXgiXT13YXNtRXhwb3J0c1sibiJdKShhMCk7dmFyIF91cGRhdGVBbGxNYXRyaXhDb250aW51ZVRyYW5zZm9ybT1Nb2R1bGVbIl91cGRhdGVBbGxNYXRyaXhDb250aW51ZVRyYW5zZm9ybSJdPShhMCxhMSxhMik9PihfdXBkYXRlQWxsTWF0cml4Q29udGludWVUcmFuc2Zvcm09TW9kdWxlWyJfdXBkYXRlQWxsTWF0cml4Q29udGludWVUcmFuc2Zvcm0iXT13YXNtRXhwb3J0c1sibyJdKShhMCxhMSxhMik7dmFyIF9tYWluPU1vZHVsZVsiX21haW4iXT0oYTAsYTEpPT4oX21haW49TW9kdWxlWyJfbWFpbiJdPXdhc21FeHBvcnRzWyJwIl0pKGEwLGExKTt2YXIgc3RhY2tBbGxvYz1hMD0+KHN0YWNrQWxsb2M9d2FzbUV4cG9ydHNbInIiXSkoYTApO3ZhciBfX19jeGFfaXNfcG9pbnRlcl90eXBlPWEwPT4oX19fY3hhX2lzX3BvaW50ZXJfdHlwZT13YXNtRXhwb3J0c1sicyJdKShhMCk7dmFyIGNhbGxlZFJ1bjtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9ZnVuY3Rpb24gcnVuQ2FsbGVyKCl7aWYoIWNhbGxlZFJ1bilydW4oKTtpZighY2FsbGVkUnVuKWRlcGVuZGVuY2llc0Z1bGZpbGxlZD1ydW5DYWxsZXJ9O2Z1bmN0aW9uIGNhbGxNYWluKGFyZ3M9W10pe3ZhciBlbnRyeUZ1bmN0aW9uPV9tYWluO2FyZ3MudW5zaGlmdCh0aGlzUHJvZ3JhbSk7dmFyIGFyZ2M9YXJncy5sZW5ndGg7dmFyIGFyZ3Y9c3RhY2tBbGxvYygoYXJnYysxKSo0KTt2YXIgYXJndl9wdHI9YXJndjthcmdzLmZvckVhY2goYXJnPT57SEVBUFUzMlthcmd2X3B0cj4+Ml09c3RyaW5nVG9VVEY4T25TdGFjayhhcmcpO2FyZ3ZfcHRyKz00fSk7SEVBUFUzMlthcmd2X3B0cj4+Ml09MDt0cnl7dmFyIHJldD1lbnRyeUZ1bmN0aW9uKGFyZ2MsYXJndik7ZXhpdEpTKHJldCx0cnVlKTtyZXR1cm4gcmV0fWNhdGNoKGUpe3JldHVybiBoYW5kbGVFeGNlcHRpb24oZSl9fWZ1bmN0aW9uIHJ1bihhcmdzPWFyZ3VtZW50c18pe2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59cHJlUnVuKCk7aWYocnVuRGVwZW5kZW5jaWVzPjApe3JldHVybn1mdW5jdGlvbiBkb1J1bigpe2lmKGNhbGxlZFJ1bilyZXR1cm47Y2FsbGVkUnVuPXRydWU7TW9kdWxlWyJjYWxsZWRSdW4iXT10cnVlO2lmKEFCT1JUKXJldHVybjtpbml0UnVudGltZSgpO3ByZU1haW4oKTtyZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7aWYoTW9kdWxlWyJvblJ1bnRpbWVJbml0aWFsaXplZCJdKU1vZHVsZVsib25SdW50aW1lSW5pdGlhbGl6ZWQiXSgpO2lmKHNob3VsZFJ1bk5vdyljYWxsTWFpbihhcmdzKTtwb3N0UnVuKCl9aWYoTW9kdWxlWyJzZXRTdGF0dXMiXSl7TW9kdWxlWyJzZXRTdGF0dXMiXSgiUnVubmluZy4uLiIpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TW9kdWxlWyJzZXRTdGF0dXMiXSgiIil9LDEpO2RvUnVuKCl9LDEpfWVsc2V7ZG9SdW4oKX19aWYoTW9kdWxlWyJwcmVJbml0Il0pe2lmKHR5cGVvZiBNb2R1bGVbInByZUluaXQiXT09ImZ1bmN0aW9uIilNb2R1bGVbInByZUluaXQiXT1bTW9kdWxlWyJwcmVJbml0Il1dO3doaWxlKE1vZHVsZVsicHJlSW5pdCJdLmxlbmd0aD4wKXtNb2R1bGVbInByZUluaXQiXS5wb3AoKSgpfX12YXIgc2hvdWxkUnVuTm93PXRydWU7aWYoTW9kdWxlWyJub0luaXRpYWxSdW4iXSlzaG91bGRSdW5Ob3c9ZmFsc2U7cnVuKCk7CgoKICByZXR1cm4gbW9kdWxlQXJnLnJlYWR5Cn0KKTsKfSkoKTsKZXhwb3J0IGRlZmF1bHQgTW9kdWxlOw==",import.meta.url)),p=(I,M)=>(I=Ln(I)?new URL(I):Q.normalize(I),U.readFileSync(I,M?void 0:"utf8")),B=I=>{var M=p(I,!0);return M.buffer||(M=new Uint8Array(M)),M},!e.thisProgram&&process.argv.length>1&&(l=process.argv[1].replace(/\\/g,"/")),o=process.argv.slice(2),h=(I,M)=>{throw process.exitCode=I,M}}else(c||u)&&(u?f=self.location.href:typeof document<"u"&&document.currentScript&&(f=document.currentScript.src),n&&(f=n),f.startsWith("blob:")?f="":f=f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1),p=E=>{var I=new XMLHttpRequest;return I.open("GET",E,!1),I.send(null),I.responseText},u&&(B=E=>{var I=new XMLHttpRequest;return I.open("GET",E,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)}));var y=e.print||console.log.bind(console),b=e.printErr||console.error.bind(console);Object.assign(e,i),i=null,e.arguments&&(o=e.arguments),e.thisProgram&&(l=e.thisProgram),e.quit&&(h=e.quit);var x;e.wasmBinary&&(x=e.wasmBinary);function w(E){if(typeof d<"u"&&d){var I=Buffer.from(E,"base64");return new Uint8Array(I.buffer,I.byteOffset,I.length)}for(var M=atob(E),te=new Uint8Array(M.length),ge=0;ge<M.length;++ge)te[ge]=M.charCodeAt(ge);return te}function D(E){if(ns(E))return w(E.slice(ss.length))}var O,L=!1,$,J,ue,ee;function se(){var E=O.buffer;e.HEAP8=J=new Int8Array(E),e.HEAP16=new Int16Array(E),e.HEAPU8=ue=new Uint8Array(E),e.HEAPU16=new Uint16Array(E),e.HEAP32=new Int32Array(E),e.HEAPU32=ee=new Uint32Array(E),e.HEAPF32=new Float32Array(E),e.HEAPF64=new Float64Array(E)}var Ce=[],me=[],Oe=[],Ye=[];function He(){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)Cr(e.preRun.shift());va(Ce)}function ot(){va(me)}function Qe(){va(Oe)}function dt(){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;)Qa(e.postRun.shift());va(Ye)}function Cr(E){Ce.unshift(E)}function Qr(E){me.unshift(E)}function Qa(E){Ye.unshift(E)}var wt=0,or=null;function kn(E){var I;wt++,(I=e.monitorRunDependencies)==null||I.call(e,wt)}function Pn(E){var M;if(wt--,(M=e.monitorRunDependencies)==null||M.call(e,wt),wt==0&&or){var I=or;or=null,I()}}function is(E){var M;(M=e.onAbort)==null||M.call(e,E),E="Aborted("+E+")",b(E),L=!0,$=1,E+=". Build with -sASSERTIONS for more info.";var I=new WebAssembly.RuntimeError(E);throw a(I),I}var ss="data:application/octet-stream;base64,",ns=E=>E.startsWith(ss),Ln=E=>E.startsWith("file://"),Pr;Pr="data:application/octet-stream;base64,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gICAgID4PzcD0AIgAkKAgICAgICA+D83A6gCIAJCgICAgICAgPg/NwOAAiACQYgDakEAQfAAEAcaIAJCgICAgICAgPg/NwP4AyACQoCAgICAgID4PzcD0AMgAkKAgICAgICA+D83A6gDIAJCgICAgICAgPg/NwOAAyACQYAEaiICIANHDQALCyAAIAM2AgwMAgsCQCADIAAoAggiAmtBB3UiBCAGaiIHQYCAgBBJBEBBACEDQf///w8gBSACayIFQQZ1IgIgByACIAdLGyAFQYD///8HTxsiBwRAIAdBgICAEE8NAiAHQQd0EAshCAsgCCAEQQd0aiIEIQIgBkEDcSIFBEADQCACQQhqQQBB8AAQBxogAkKAgICAgICA+D83A3ggAkKAgICAgICA+D83A1AgAkKAgICAgICA+D83AyggAkKAgICAgICA+D83AwAgAkGAAWohAiADQQFqIgMgBUcNAAsLIAZBB3QgBGohBSAGQQFrQf///w9xQQNPBEADQCACQQhqQQBB8AAQBxogAkKAgICAgICA+D83A3ggAkKAgICAgICA+D83A1AgAkKAgICAgICA+D83AyggAkKAgICAgICA+D83AwAgAkGIAWpBAEHwABAHGiACQoCAgICAgID4PzcD+AEgAkKAgICAgICA+D83A9ABIAJCgICAgICAgPg/NwOoASACQoCAgICAgID4PzcDgAEgAkGIAmpBAEHwABAHGiACQoCAgICAgID4PzcD+AIgAkKAgICAgICA+D83A9ACIAJCgICAgICAgPg/NwOoAiACQoCAgICAgID4PzcDgAIgAkGIA2pBAEHwABAHGiACQoCAgICAgID4PzcD+AMgAkKAgICAgICA+D83A9ADIAJCgICAgICAgPg/NwOoAyACQoCAgICAgID4PzcDgAMgAkGABGoiAiAFRw0ACwsgACgCDCICIAAoAggiA0cEQANAIARBgAFrIgQgAkGAAWsiAkGAARAVGiACIANHDQALIAAoAgghAgsgACAIIAdBB3RqNgIQIAAgBTYCDCAAIAQ2AgggAgRAIAIQFgsMAwsQEwALEBIACyABIAJPDQAgACADIAFBB3RqNgIMCwJAIAAoAhggACgCFCIDa0HIAG0iAiABSQRAIABBFGogASACaxA8DAELIAEgAk8NACAAIAMgAUHIAGxqNgIYCwJAIAAoAiQgACgCICIDa0EEdSICIAFJBEAgAEEgaiABIAJrEDsMAQsgASACTw0AIAAgAyABQQR0ajYCJAsgACgCMCAAKAIsIgNrQcgAbSICIAFJBEAgAEEsaiABIAJrEDwPCyABIAJPDQAgACADIAFByABsajYCMAsLBwAgACgCLAsHACAAKAIgCwcAIAAoAhQLBwAgACgCCAvUBQEHfyABIAAoAggiByAAKAIEIgNrQQR1TQRAAkAgAUUNACADIQIgAUEHcSIFBEADQCACQv////8PNwIIIAJCADcCACACQRBqIQIgBEEBaiIEIAVHDQALCyABQQR0IANqIQMgAUEBa0H/////AHFBB0kNAANAIAJC/////w83AnggAkIANwJwIAJC/////w83AmggAkIANwJgIAJC/////w83AlggAkIANwJQIAJC/////w83AkggAkIANwJAIAJC/////w83AjggAkIANwIwIAJC/////w83AiggAkIANwIgIAJC/////w83AhggAkIANwIQIAJC/////w83AgggAkIANwIAIAJBgAFqIgIgA0cNAAsLIAAgAzYCBA8LAkAgAyAAKAIAIgJrQQR1IgQgAWoiBkGAgICAAUkEQEH/////ACAHIAJrIgdBA3UiAiAGIAIgBksbIAdB8P///wdPGyIGBEAgBkGAgICAAU8NAiAGQQR0EAshCAsgCCAEQQR0aiIEIQIgAUEHcSIHBEADQCACQv////8PNwIIIAJCADcCACACQRBqIQIgBUEBaiIFIAdHDQALCyABQQR0IARqIQUgAUEBa0H/////AHFBB08EQANAIAJC/////w83AnggAkIANwJwIAJC/////w83AmggAkIANwJgIAJC/////w83AlggAkIANwJQIAJC/////w83AkggAkIANwJAIAJC/////w83AjggAkIANwIwIAJC/////w83AiggAkIANwIgIAJC/////w83AhggAkIANwIQIAJC/////w83AgggAkIANwIAIAJBgAFqIgIgBUcNAAsLIAAoAgAiASADRwRAA0AgBEEQayIEIANBEGsiA/0AAgD9CwIAIAEgA0cNAAsgACgCACEDCyAAIAggBkEEdGo2AgggACAFNgIEIAAgBDYCACADBEAgAxAMCw8LEBMACxASAAuLAwEHfyABIAAoAggiAiAAKAIEIgNrQcgAbU0EQCAAIAEEfyADQQAgAUHIAGxByABrIgAgAEHIAHBrQcgAaiIAEAcgAGoFIAMLNgIEDwsCQCADIAAoAgAiBmtByABtIgggAWoiBEHk8bgcSQRAQePxuBwgAiAGa0HIAG0iB0EBdCICIAQgAiAESxsgB0HxuJwOTxsiBARAIARB5PG4HE8NAiAEQcgAbBALIQULIAUgCEHIAGxqIgJBACABQcgAbEHIAGsiASABQcgAcGtByABqIgcQByIBIAdqIQggBSAEQcgAbGohBwJAIAMgBkYEQCABIQUMAQsDQCACQcgAayIFIANByABrIgH9AAMA/QsDACACQThrIANBOGv9AAMA/QsDACACQShrIANBKGv9AAMA/QsDACACQRhrIANBGGv9AAMA/QsDACACQQhrIANBCGsrAwA5AwAgBSECIAEiAyAGRw0ACwsgACAHNgIIIAAgCDYCBCAAIAU2AgAgBgRAIAYQDAsPCxATAAsQEgALGQEBf0GgKygCACIBIAAgASgCACgCGBEBAAsQACMAIABrQXBxIgAkACAACwcAIAAoAgQLBQBBowkLBQBBzQkLBQBBkAkLFwEBf0GgKygCACIAIAAoAgAoAhQRAAALFQAgAEUEQEEADwsgAEHkJhAiQQBHCxoAIAAgASgCCCAFEAoEQCABIAIgAyAEECALCzcAIAAgASgCCCAFEAoEQCABIAIgAyAEECAPCyAAKAIIIgAgASACIAMgBCAFIAAoAgAoAhQRCQALpwEAIAAgASgCCCAEEAoEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQCkUNAAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNASABQQE2AiAPCyABIAI2AhQgASADNgIgIAEgASgCKEEBajYCKAJAIAEoAiRBAUcNACABKAIYQQJHDQAgAUEBOgA2CyABQQQ2AiwLC4gCACAAIAEoAgggBBAKBEACQCABKAIEIAJHDQAgASgCHEEBRg0AIAEgAzYCHAsPCwJAIAAgASgCACAEEAoEQAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNAiABQQE2AiAPCyABIAM2AiACQCABKAIsQQRGDQAgAUEAOwE0IAAoAggiACABIAIgAkEBIAQgACgCACgCFBEJACABLQA1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",ns(Pr)||(Pr=A(Pr));function On(E){if(E==Pr&&x)return new Uint8Array(x);var I=D(E);if(I)return I;if(B)return B(E);throw"both async and sync fetching of the wasm failed"}function Gn(E){return Promise.resolve().then(()=>On(E))}function Wn(E,I,M){return Gn(E).then(te=>WebAssembly.instantiate(te,I)).then(M,te=>{b(`failed to asynchronously prepare wasm: ${te}`),is(te)})}function Jn(E,I,M,te){return Wn(I,M,te)}function zn(){var E={a:co};function I(te,ge){return Ke=te.exports,O=Ke.f,se(),Qr(Ke.g),Pn(),Ke}kn();function M(te){I(te.instance)}if(e.instantiateWasm)try{return e.instantiateWasm(E,I)}catch(te){b(`Module.instantiateWasm callback failed with error: ${te}`),a(te)}return Jn(x,Pr,E,M).catch(a),{}}function os(E){this.name="ExitStatus",this.message=`Program terminated with exit(${E})`,this.status=E}var va=E=>{for(;E.length>0;)E.shift()(e)};e.noExitRuntime;class Zn{constructor(I){this.excPtr=I,this.ptr=I-24}set_type(I){ee[this.ptr+4>>2]=I}get_type(){return ee[this.ptr+4>>2]}set_destructor(I){ee[this.ptr+8>>2]=I}get_destructor(){return ee[this.ptr+8>>2]}set_caught(I){I=I?1:0,J[this.ptr+12]=I}get_caught(){return J[this.ptr+12]!=0}set_rethrown(I){I=I?1:0,J[this.ptr+13]=I}get_rethrown(){return J[this.ptr+13]!=0}init(I,M){this.set_adjusted_ptr(0),this.set_type(I),this.set_destructor(M)}set_adjusted_ptr(I){ee[this.ptr+16>>2]=I}get_adjusted_ptr(){return ee[this.ptr+16>>2]}get_exception_ptr(){var I=us(this.get_type());if(I)return ee[this.excPtr>>2];var M=this.get_adjusted_ptr();return M!==0?M:this.excPtr}}var ls=0,Xn=(E,I,M)=>{var te=new Zn(E);throw te.init(I,M),ls=E,ls},Yn=()=>{is("")},Hn=(E,I,M)=>ue.copyWithin(E,I,I+M),Kn=()=>2147483648,jn=E=>{var I=O.buffer,M=(E-I.byteLength+65535)/65536;try{return O.grow(M),se(),1}catch{}},qn=E=>{var I=ue.length;E>>>=0;var M=Kn();if(E>M)return!1;for(var te=(Qt,Lr)=>Qt+(Lr-Qt%Lr)%Lr,ge=1;ge<=4;ge*=2){var Re=I*(1+.2/ge);Re=Math.min(Re,E+100663296);var pe=Math.min(M,te(Math.max(E,Re),65536)),fe=jn(pe);if(fe)return!0}return!1},$n=[null,[],[]],hs=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,eo=(E,I,M)=>{for(var te=I+M,ge=I;E[ge]&&!(ge>=te);)++ge;if(ge-I>16&&E.buffer&&hs)return hs.decode(E.subarray(I,ge));for(var Re="";I<ge;){var pe=E[I++];if(!(pe&128)){Re+=String.fromCharCode(pe);continue}var fe=E[I++]&63;if((pe&224)==192){Re+=String.fromCharCode((pe&31)<<6|fe);continue}var Qt=E[I++]&63;if((pe&240)==224?pe=(pe&15)<<12|fe<<6|Qt:pe=(pe&7)<<18|fe<<12|Qt<<6|E[I++]&63,pe<65536)Re+=String.fromCharCode(pe);else{var Lr=pe-65536;Re+=String.fromCharCode(55296|Lr>>10,56320|Lr&1023)}}return Re},to=(E,I)=>{var M=$n[E];I===0||I===10?((E===1?y:b)(eo(M,0)),M.length=0):M.push(I)},ro=(E,I,M,te)=>{for(var ge=0,Re=0;Re<M;Re++){var pe=ee[I>>2],fe=ee[I+4>>2];I+=8;for(var Qt=0;Qt<fe;Qt++)to(E,ue[pe+Qt]);ge+=fe}return ee[te>>2]=ge,0},ao=E=>{$=E,h(E,new os(E))},io=(E,I)=>{$=E,ao(E)},so=E=>{if(E instanceof os||E=="unwind")return $;h(1,E)},no=E=>{for(var I=0,M=0;M<E.length;++M){var te=E.charCodeAt(M);te<=127?I++:te<=2047?I+=2:te>=55296&&te<=57343?(I+=4,++M):I+=3}return I},oo=(E,I,M,te)=>{if(!(te>0))return 0;for(var ge=M,Re=M+te-1,pe=0;pe<E.length;++pe){var fe=E.charCodeAt(pe);if(fe>=55296&&fe<=57343){var Qt=E.charCodeAt(++pe);fe=65536+((fe&1023)<<10)|Qt&1023}if(fe<=127){if(M>=Re)break;I[M++]=fe}else if(fe<=2047){if(M+1>=Re)break;I[M++]=192|fe>>6,I[M++]=128|fe&63}else if(fe<=65535){if(M+2>=Re)break;I[M++]=224|fe>>12,I[M++]=128|fe>>6&63,I[M++]=128|fe&63}else{if(M+3>=Re)break;I[M++]=240|fe>>18,I[M++]=128|fe>>12&63,I[M++]=128|fe>>6&63,I[M++]=128|fe&63}}return I[M]=0,M-ge},lo=(E,I,M)=>oo(E,ue,I,M),ho=E=>{var I=no(E)+1,M=hi(I);return lo(E,M,I),M},co={b:Xn,c:Yn,e:Hn,d:qn,a:ro},Ke=zn();e._initialize=(E,I,M)=>(e._initialize=Ke.h)(E,I,M),e._allocMatrix=E=>(e._allocMatrix=Ke.i)(E),e._getMatrixBufferPtr=()=>(e._getMatrixBufferPtr=Ke.j)(),e._getSRTPtr=()=>(e._getSRTPtr=Ke.k)(),e._getInfoPtr=()=>(e._getInfoPtr=Ke.l)(),e._getContinuedSRTPtr=()=>(e._getContinuedSRTPtr=Ke.m)(),e._printMatrix=E=>(e._printMatrix=Ke.n)(E),e._updateAllMatrixContinueTransform=(E,I,M)=>(e._updateAllMatrixContinueTransform=Ke.o)(E,I,M);var cs=e._main=(E,I)=>(cs=e._main=Ke.p)(E,I),hi=E=>(hi=Ke.r)(E),us=E=>(us=Ke.s)(E),Sa;or=function E(){Sa||ds(),Sa||(or=E)};function uo(E=[]){var I=cs;E.unshift(l);var M=E.length,te=hi((M+1)*4),ge=te;E.forEach(pe=>{ee[ge>>2]=ho(pe),ge+=4}),ee[ge>>2]=0;try{var Re=I(M,te);return io(Re,!0),Re}catch(pe){return so(pe)}}function ds(E=o){if(wt>0||(He(),wt>0))return;function I(){Sa||(Sa=!0,e.calledRun=!0,!L&&(ot(),Qe(),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),fs&&uo(E),dt()))}e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),I()},1)):I()}if(e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();var fs=!0;return e.noInitialRun&&(fs=!1),ds(),t.ready}})();function lr(n,t,e){return C.setting.doublePrecision?new Float64Array(n,t,e):new Float32Array(n,t,e)}const xe=class xe{static async init(t,e=!1){this.wasm=await El(),this.useDoublePrecision=e,this.wasm._initialize(t,e,0),this.allocMatrix(t)}static allocMatrix(t){t>Z.maxCount&&console.error(`The maximum allocation size is exceeded! current:${t}, limit:${Z.maxCount}`),this.wasm._allocMatrix(t),this.matrixBufferPtr=this.wasm._getMatrixBufferPtr(),this.matrixSRTBufferPtr=this.wasm._getSRTPtr(),this.matrixStateBufferPtr=this.wasm._getInfoPtr(),this.matrixContinuedSRTBufferPtr=this.wasm._getContinuedSRTPtr(),this.useDoublePrecision?(this.matrixBuffer=lr(this.wasm.HEAPF64.buffer,this.matrixBufferPtr,16*t),this.matrixSRTBuffer=lr(this.wasm.HEAPF64.buffer,this.matrixSRTBufferPtr,3*3*t),this.matrixContinuedSRTBuffer=lr(this.wasm.HEAPF64.buffer,this.matrixContinuedSRTBufferPtr,3*3*t),Z.blockBytes=Z.block*8):(this.matrixBuffer=lr(this.wasm.HEAPF32.buffer,this.matrixBufferPtr,16*t),this.matrixSRTBuffer=lr(this.wasm.HEAPF32.buffer,this.matrixSRTBufferPtr,3*3*t),this.matrixContinuedSRTBuffer=lr(this.wasm.HEAPF32.buffer,this.matrixContinuedSRTBufferPtr,3*3*t),Z.blockBytes=Z.block*4),this.matrixStateBuffer=new Int32Array(this.wasm.HEAP32.buffer,this.matrixStateBufferPtr,xe.stateStruct*t),Z.allocMatrix(t)}static updateAllContinueTransform(t,e,r){this.wasm._updateAllMatrixContinueTransform(t,e,r)}static setParent(t,e,r){this.matrixStateBuffer[t*xe.stateStruct+2]=e>=0?e:-1,this.matrixStateBuffer[t*xe.stateStruct+3]=r}static setTranslate(t,e,r,a){this.matrixSRTBuffer[t*9+6]=e,this.matrixSRTBuffer[t*9+7]=r,this.matrixSRTBuffer[t*9+8]=a}static setRotation(t,e,r,a){this.matrixSRTBuffer[t*9+3]=e%360,this.matrixSRTBuffer[t*9+4]=r%360,this.matrixSRTBuffer[t*9+5]=a%360}static setScale(t,e,r,a){this.matrixSRTBuffer[t*9+0]=e,this.matrixSRTBuffer[t*9+1]=r,this.matrixSRTBuffer[t*9+2]=a}static setContinueTranslate(t,e,r,a){(e!=0||r!=0||a!=0)&&(this.matrixContinuedSRTBuffer[t*9+6]=e,this.matrixContinuedSRTBuffer[t*9+7]=r,this.matrixContinuedSRTBuffer[t*9+8]=a,this.matrixStateBuffer[t*xe.stateStruct+1]=1)}static setContinueRotation(t,e,r,a){(e!=0||r!=0||a!=0)&&(this.matrixContinuedSRTBuffer[t*9+3]=e,this.matrixContinuedSRTBuffer[t*9+4]=r,this.matrixContinuedSRTBuffer[t*9+5]=a,this.matrixStateBuffer[t*xe.stateStruct+1]=1)}static setContinueScale(t,e,r,a){(e!=0||r!=0||a!=0)&&(this.matrixContinuedSRTBuffer[t*9+0]=e,this.matrixContinuedSRTBuffer[t*9+1]=r,this.matrixContinuedSRTBuffer[t*9+2]=a,this.matrixStateBuffer[t*xe.stateStruct+1]=1)}};s(xe,"matrixBuffer"),s(xe,"matrixSRTBuffer"),s(xe,"matrixContinuedSRTBuffer"),s(xe,"matrixStateBuffer"),s(xe,"matrixBufferPtr"),s(xe,"matrixSRTBufferPtr"),s(xe,"matrixContinuedSRTBufferPtr"),s(xe,"matrixStateBufferPtr"),s(xe,"wasm"),s(xe,"stateStruct",4),s(xe,"useDoublePrecision",!1);let he=xe;class Wt{}s(Wt,"AXIS_ANGLE","axisAngle"),s(Wt,"EULER_ANGLES","eulerAngles"),s(Wt,"QUATERNION","quaternion");const Ee=class Ee{constructor(t=0,e=0,r=0,a=1){s(this,"x",0);s(this,"y",0);s(this,"z",0);s(this,"w",1);this.x=t,this.y=e,this.z=r,this.w=a}static identity(){return Ee._zero}static quaternionToMatrix(t,e){let r=t.x*2,a=t.y*2,i=t.z*2,o=t.x*r,l=t.y*a,h=t.z*i,c=t.x*a,u=t.x*i,d=t.y*i,f=t.w*r,A=t.w*a,p=t.w*i;e.rawData[0]=1-(l+h),e.rawData[1]=c+p,e.rawData[2]=u-A,e.rawData[3]=0,e.rawData[4]=c-p,e.rawData[5]=1-(o+h),e.rawData[6]=d+f,e.rawData[7]=0,e.rawData[8]=u+A,e.rawData[9]=d-f,e.rawData[10]=1-(o+l),e.rawData[11]=0,e.rawData[12]=0,e.rawData[13]=0,e.rawData[14]=0,e.rawData[15]=1}get magnitude(){return Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z)}set(t=0,e=0,r=0,a=1){return this.x=t,this.y=e,this.z=r,this.w=a,this}divide(t){return t instanceof Ee?new Ee(this.x/t.x,this.y/t.y,this.z/t.z):(this.x=this.x/t,this.y=this.y/t,this.z=this.z/t,this)}setFromArray(t){return this.x=t[0],this.y=t[1],this.z=t[2],this.w=t[3],this}multiply(t,e){var r=t.w,a=t.x,i=t.y,o=t.z,l=e.w,h=e.x,c=e.y,u=e.z;this.w=r*l-a*h-i*c-o*u,this.x=r*h+a*l+i*u-o*c,this.y=r*c-a*u+i*l+o*h,this.z=r*u+a*c-i*h+o*l}multiplyVector(t,e=null){e||(e=new Ee);var r=t.x,a=t.y,i=t.z;return e.w=-this.x*r-this.y*a-this.z*i,e.x=this.w*r+this.y*i-this.z*a,e.y=this.w*a-this.x*i+this.z*r,e.z=this.w*i+this.x*a-this.y*r,e}fromAxisAngle(t,e){e*=Math.PI/180;var r=e*.5,a=Math.sin(r);this.w=Math.cos(r),this.x=t.x*a,this.y=t.y*a,this.z=t.z*a,this.normalize()}toAxisAngle(t){var e=this.x*this.x+this.y*this.y+this.z*this.z,r=0;return e>0?(r=2*Math.acos(this.w),e=1/Math.sqrt(e),t.x=this.x*e,t.y=this.y*e,t.z=this.z*e):(r=0,t.x=1,t.y=0,t.z=0),r}slerp(t,e,r){var a=t.w,i=t.x,o=t.y,l=t.z,h=e.w,c=e.x,u=e.y,d=e.z,f=a*h+i*c+o*u+l*d;if(f<0&&(f=-f,h=-h,c=-c,u=-u,d=-d),f<.95){var A=Math.acos(f),p=1/Math.sin(A),B=Math.sin(A*(1-r))*p,F=Math.sin(A*r)*p;this.w=a*B+h*F,this.x=i*B+c*F,this.y=o*B+u*F,this.z=l*B+d*F}else{this.w=a+r*(h-a),this.x=i+r*(c-i),this.y=o+r*(u-o),this.z=l+r*(d-l);var U=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z);this.w*=U,this.x*=U,this.y*=U,this.z*=U}}lerp(t,e,r){var a=t.w,i=t.x,o=t.y,l=t.z,h=e.w,c=e.x,u=e.y,d=e.z,f;a*h+i*c+o*u+l*d<0&&(h=-h,c=-c,u=-u,d=-d),this.w=a+r*(h-a),this.x=i+r*(c-i),this.y=o+r*(u-o),this.z=l+r*(d-l),f=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z),this.w*=f,this.x*=f,this.y*=f,this.z*=f}fromEulerAngles(t,e,r){t*=Ze,e*=Ze,r*=Ze;var a=t*.5,i=e*.5,o=r*.5,l=Math.cos(a),h=Math.sin(a),c=Math.cos(i),u=Math.sin(i),d=Math.cos(o),f=Math.sin(o);return this.w=l*c*d+h*u*f,this.x=h*c*d-l*u*f,this.y=l*u*d+h*c*f,this.z=l*c*f-h*u*d,this}setFromRotationMatrix(t){const e=t.rawData,r=e[0],a=e[4],i=e[8],o=e[1],l=e[5],h=e[9],c=e[2],u=e[6],d=e[10],f=r+l+d;if(f>0){const A=.5/Math.sqrt(f+1);this.w=.25/A,this.x=(u-h)*A,this.y=(i-c)*A,this.z=(o-a)*A}else if(r>l&&r>d){const A=2*Math.sqrt(1+r-l-d);this.w=(u-h)/A,this.x=.25*A,this.y=(a+o)/A,this.z=(i+c)/A}else if(l>d){const A=2*Math.sqrt(1+l-r-d);this.w=(i-c)/A,this.x=(a+o)/A,this.y=.25*A,this.z=(h+u)/A}else{const A=2*Math.sqrt(1+d-r-l);this.w=(o-a)/A,this.x=(i+c)/A,this.y=(h+u)/A,this.z=.25*A}return this}getEulerAngles(t){var e,r,a,i,o,l,h,c;return t||(t=new g),i=this.x,o=this.y,l=this.z,h=this.w,c=2*(h*o-i*l),c<=-.99999?(e=2*Math.atan2(i,h),r=-Math.PI/2,a=0):c>=.99999?(e=2*Math.atan2(i,h),r=Math.PI/2,a=0):(e=Math.atan2(2*(h*i+o*l),1-2*(i*i+o*o)),r=Math.asin(c),a=Math.atan2(2*(h*l+i*o),1-2*(o*o+l*l))),t.set(e,r,a).scaleBy(Ca)}normalize(t=1){var e=t/Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);this.x*=e,this.y*=e,this.z*=e,this.w*=e}toString(){return"{x:"+this.x+" y:"+this.y+" z:"+this.z+" w:"+this.w+"}"}fromMatrix(t){var e=t.decompose(Wt.QUATERNION)[1];this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w}inverse(t=null){t||(t=new Ee);var e=this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z;if(e>0){var r=1/e;t.w=this.w*r,t.x=-this.x*r,t.y=-this.y*r,t.z=-this.z*r}return t}clone(){return new Ee(this.x,this.y,this.z,this.w)}transformVector(t,e=null){var r,a,i,o,l=t.x,h=t.y,c=t.z;return e||(e=new g),o=-this.x*l-this.y*h-this.z*c,r=this.w*l+this.y*c-this.z*h,a=this.w*h-this.x*c+this.z*l,i=this.w*c+this.x*h-this.y*l,e.x=-o*this.x+r*this.w-a*this.z+i*this.y,e.y=-o*this.y+r*this.z+a*this.w-i*this.x,e.z=-o*this.z-r*this.y+a*this.x+i*this.w,e}copyFrom(t){var e=this;return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,this}mul(t,e,r){let a=r||new Ee;return a.x=t.w*e.x+t.x*e.w+t.y*e.z-t.z*e.y,a.y=t.w*e.y+t.y*e.w+t.z*e.x-t.x*e.z,a.z=t.w*e.z+t.z*e.w+t.x*e.y-t.y*e.x,a.w=t.w*e.w-t.x*e.x-t.y*e.y-t.z*e.z,a}clampf(t,e,r){if(e>r){var a=e;e=r,r=a}return t<e?e:t<r?t:r}static serialize(t){return new Ee(t.x,t.y,t.z,t.w)}};s(Ee,"HELP_0",new Ee(0,0,0,1)),s(Ee,"HELP_1",new Ee(0,0,0,1)),s(Ee,"HELP_2",new Ee(0,0,0,1)),s(Ee,"_zero",new Ee(0,0,0,1)),s(Ee,"CALCULATION_QUATERNION",new Ee);let X=Ee,Ca=180/Math.PI,Ze=Math.PI/180;function yt(n,t,e){return Math.max(t,Math.min(e,n))}class At{static gaussFunction(t,e,r,a){let i=Math.pow(t-r,2),o=2*Math.pow(a,2),l=-1*(i/o),h=Math.pow(Math.E,l);return Math.round(h*e)}static computeGaussian(t,e){return 1/Math.sqrt(2*Math.PI*e)*Math.exp(-(t*t)/(2*e*e))}static gaussCoef(t){t<.5&&(t=.5);let e=Math.exp(.726*.726)/t,r=Math.exp(-e),a=Math.exp(-2*e),i=(1-r)*(1-r)/(1+2*e*r-a),o=i,l=i*(e-1)*r,h=i*(e+1)*r,c=-i*a,u=2*r,d=-a,f=(o+l)/(1-u-d),A=(h+c)/(1-u-d);return new Float32Array([o,l,h,c,u,d,f,A])}static clampf(t,e,r){if(e>r){let a=e;e=r,r=a}return t<e?e:t<r?t:r}static normalizeAngle(t){for(;t>180;)t-=360;for(;t<-180;)t+=360;return t}static fract(t){return t-Math.floor(t)}static getRandDirXZ(t){let e=t*Math.random(),r=360*Math.random()*Ze,a=Math.cos(r)*e,i=Math.sin(r)*e;return{x:a,z:i}}static getRandDirXYZ(t){let e=t*Math.random(),r=360*Math.random()*Ze,a=Math.cos(r)*e,i=Math.tan(r)*e,o=Math.sin(r)*e;return new g(a,i,o)}static getCycleXYZ(t){let e=t*Math.random(),r=360*Math.random()*Ze,a=Math.cos(r)*e,i=t*Math.random()-t*.5,o=Math.sin(r)*e;return new g(a,i,o)}static angle(t,e){let r=Ie.HELP_0,a=Ie.HELP_1;return r.set(t.x,t.z),a.set(e.x,e.z),Math.acos((r.x*a.x+r.y*a.y)/(r.abs()*a.abs()))}static angle_360(t,e){let r=g.HELP_0;return t.crossProduct(e,r),r.z>0?At.angle(t,e):360-At.angle(t,e)}getRotationY(t){return At.normalizeAngle(Math.atan2(t.z,t.x)*Ca)}static fromToRotation(t,e,r=null){r||(r=new X);let a=Z.help_matrix_2;return Z.fromToRotation(t,e,a),r.fromMatrix(a),r}static getEularDir_yUp(t){let e=X.HELP_0;return e.fromEulerAngles(0,t,0),e.transformVector(g.Z_AXIS,g.HELP_5),g.HELP_5}static transformVector(t,e,r=null){r||(r=new g);let a=t.rawData,i=a[0],o=a[1],l=a[2],h=a[3],c=a[4],u=a[5],d=a[6],f=a[7],A=a[8],p=a[9],B=a[10],F=a[11],U=a[12],Q=a[13],y=a[14],b=a[15],x=e.x,w=e.y,D=e.z;return r.x=i*x+c*w+A*D+U,r.y=o*x+u*w+p*D+Q,r.z=l*x+d*w+B*D+y,r.w=h*x+f*w+F*D+b,r}}let Fs=function(n,t,e){let r=e-t;return Math.floor(n/r)%2==0?n%r+t:e-n%r+t},Cs=function(n,t,e){let r=e-t;return n%r+t};function Fi(n,t){return n instanceof g&&t instanceof g||n instanceof X&&t instanceof X?n.x*t.x+n.y*t.y+n.z*t.z:n.x*t.x+n.y*t.y}function yl(n){return Fi(n,n)}function Il(n,t){return n-Math.floor(n/t)*t}const _=class _{constructor(t=!1){s(this,"index",0);s(this,"offset",0);s(this,"rawData");s(this,"_position");if(_.useCount>=_.allocCount){let e=_.allocCount+_.allocOnceCount;he.allocMatrix(e)}this.index=_.useCount,this.offset=_.wasmMatrixPtr+this.index*_.blockBytes,_.dynamicGlobalMatrixRef[this.index]=this,_.useCount++,this.rawData=lr(_.dynamicMatrixBytes.buffer,this.offset,16),this._position=new g,this.identity()}static allocMatrix(t){this.allocCount=t,_.dynamicMatrixBytes=he.matrixBuffer,_.buffer=_.dynamicMatrixBytes.buffer,_.wasmMatrixPtr=he.matrixBufferPtr,this.dynamicGlobalMatrixRef||(this.dynamicGlobalMatrixRef=[]),this.dynamicGlobalMatrixRef.forEach(e=>{e.offset=_.wasmMatrixPtr+e.index*_.blockBytes,e.rawData=lr(_.dynamicMatrixBytes.buffer,e.offset,16)}),_.help_matrix_0||(_.help_matrix_0=new _),_.help_matrix_1||(_.help_matrix_1=new _),_.help_matrix_2||(_.help_matrix_2=new _),_.helpMatrix||(_.helpMatrix=new _),_.helpMatrix2||(_.helpMatrix2=new _),_._getEulerMatrix||(_._getEulerMatrix=new _),_._getEulerMatrix.identity()}static fromToRotation(t,e,r){return r||(r=new _),r.transformDir(t,e),r}static getAxisRotation(t,e,r,a){let i=new _,o=a*(Math.PI/180),l=Math.cos(o),h=Math.sin(o),c=1-l,u,d;return i.rawData[0]=l+t*t*c,i.rawData[5]=l+e*e*c,i.rawData[10]=l+r*r*c,u=t*e*c,d=r*h,i.rawData[1]=u+d,i.rawData[4]=u-d,u=t*r*c,d=e*h,i.rawData[8]=u+d,i.rawData[2]=u-d,u=e*r*c,d=t*h,i.rawData[9]=u-d,i.rawData[6]=u+d,i}static sanitizeEuler(t){_.makePositive(t)}static makePositive(t){let e=-1e-4,r=Math.PI*2-1e-4;t.x<e?t.x+=2*Math.PI:t.x>r&&(t.x-=2*Math.PI),t.y<e?t.y+=2*Math.PI:t.y>r&&(t.y-=2*Math.PI),t.z<e?t.z+=2*Math.PI:t.z>r&&(t.z-=2*Math.PI)}static matrixToEuler(t,e){return t.get(1,2)<.999?t.get(1,2)>-.999?(e.x=Math.asin(-t.get(1,2)),e.y=Math.atan2(t.get(0,2),t.get(2,2)),e.z=Math.atan2(t.get(1,0),t.get(1,1)),_.sanitizeEuler(e),!0):(e.x=Math.PI*.5,e.y=Math.atan2(t.get(0,1),t.get(0,0)),e.z=0,_.sanitizeEuler(e),!1):(e.x=-Math.PI*.5,e.y=Math.atan2(-t.get(0,1),t.get(0,0)),e.z=0,_.sanitizeEuler(e),!1)}static matrixMultiply(t,e,r){_.wasm.Matrix_Multiply(t.index,e.index,r.index)}static matrixAppend(t,e,r){_.wasm.Matrix_Append(t.index,e.index,r.index)}static matrixRotateY(t,e){_.wasm.Matrix_Append(t,e.index)}static matrixRotate(t,e,r){_.wasm.Matrix_Rotate(t,e,r.index)}lookAt(t,e,r=g.Y_AXIS){let a=this.rawData,i=e.subtract(t,g.HELP_0);i.length===0&&(i.z=1),i.normalize();let o=r.crossProduct(i,g.HELP_1);o.length===0&&(Math.abs(r.z)===1?i.x+=1e-4:i.z-=1e-4,i.normalize(),o=r.crossProduct(i,g.HELP_1)),o.normalize();let l=i.crossProduct(o,g.HELP_2);a[0]=o.x,a[1]=l.x,a[2]=i.x,a[3]=0,a[4]=o.y,a[5]=l.y,a[6]=i.y,a[7]=0,a[8]=o.z,a[9]=l.z,a[10]=i.z,a[11]=0,a[12]=-o.dotProduct(t),a[13]=-l.dotProduct(t),a[14]=-i.dotProduct(t),a[15]=1}multiply(t){let e=this.rawData,r=t.rawData,a=_.floatArray;a[0]=e[0]*r[0]+e[1]*r[4]+e[2]*r[8]+e[3]*r[12],a[1]=e[0]*r[1]+e[1]*r[5]+e[2]*r[9]+e[3]*r[13],a[2]=e[0]*r[2]+e[1]*r[6]+e[2]*r[10]+e[3]*r[14],a[3]=e[0]*r[3]+e[1]*r[7]+e[2]*r[11]+e[3]*r[15],a[4]=e[4]*r[0]+e[5]*r[4]+e[6]*r[8]+e[7]*r[12],a[5]=e[4]*r[1]+e[5]*r[5]+e[6]*r[9]+e[7]*r[13],a[6]=e[4]*r[2]+e[5]*r[6]+e[6]*r[10]+e[7]*r[14],a[7]=e[4]*r[3]+e[5]*r[7]+e[6]*r[11]+e[7]*r[15],a[8]=e[8]*r[0]+e[9]*r[4]+e[10]*r[8]+e[11]*r[12],a[9]=e[8]*r[1]+e[9]*r[5]+e[10]*r[9]+e[11]*r[13],a[10]=e[8]*r[2]+e[9]*r[6]+e[10]*r[10]+e[11]*r[14],a[11]=e[8]*r[3]+e[9]*r[7]+e[10]*r[11]+e[11]*r[15],a[12]=e[12]*r[0]+e[13]*r[4]+e[14]*r[8]+e[15]*r[12],a[13]=e[12]*r[1]+e[13]*r[5]+e[14]*r[9]+e[15]*r[13],a[14]=e[12]*r[2]+e[13]*r[6]+e[14]*r[10]+e[15]*r[14],a[15]=e[12]*r[3]+e[13]*r[7]+e[14]*r[11]+e[15]*r[15],e[0]=a[0],e[1]=a[1],e[2]=a[2],e[3]=a[3],e[4]=a[4],e[5]=a[5],e[6]=a[6],e[7]=a[7],e[8]=a[8],e[9]=a[9],e[10]=a[10],e[11]=a[11],e[12]=a[12],e[13]=a[13],e[14]=a[14],e[15]=a[15]}multiplyMatrices(t,e){const r=t.rawData,a=e.rawData,i=this.rawData,o=r[0],l=r[4],h=r[8],c=r[12],u=r[1],d=r[5],f=r[9],A=r[13],p=r[2],B=r[6],F=r[10],U=r[14],Q=r[3],y=r[7],b=r[11],x=r[15],w=a[0],D=a[4],O=a[8],L=a[12],$=a[1],J=a[5],ue=a[9],ee=a[13],se=a[2],Ce=a[6],me=a[10],Oe=a[14],Ye=a[3],He=a[7],ot=a[11],Qe=a[15];return i[0]=o*w+l*$+h*se+c*Ye,i[4]=o*D+l*J+h*Ce+c*He,i[8]=o*O+l*ue+h*me+c*ot,i[12]=o*L+l*ee+h*Oe+c*Qe,i[1]=u*w+d*$+f*se+A*Ye,i[5]=u*D+d*J+f*Ce+A*He,i[9]=u*O+d*ue+f*me+A*ot,i[13]=u*L+d*ee+f*Oe+A*Qe,i[2]=p*w+B*$+F*se+U*Ye,i[6]=p*D+B*J+F*Ce+U*He,i[10]=p*O+B*ue+F*me+U*ot,i[14]=p*L+B*ee+F*Oe+U*Qe,i[3]=Q*w+y*$+b*se+x*Ye,i[7]=Q*D+y*J+b*Ce+x*He,i[11]=Q*O+y*ue+b*me+x*ot,i[15]=Q*L+y*ee+b*Oe+x*Qe,this}multiplyPoint3(t,e){e||(e=new g);let r=this.rawData;return e.x=r[0]*t.x+r[4]*t.y+r[8]*t.z+r[12],e.y=r[1]*t.x+r[5]*t.y+r[9]*t.z+r[13],e.z=r[2]*t.x+r[6]*t.y+r[10]*t.z+r[14],e}multiplyVector4(t,e){e||(e=new g);let r=this.rawData,a=t.x,i=t.y,o=t.z,l=r[3]*a+r[7]*i+r[11]*o+r[15];return l=l||1,e.x=(r[0]*a+r[4]*i+r[8]*o+r[12])/l,e.y=(r[1]*a+r[5]*i+r[9]*o+r[13])/l,e.z=(r[2]*a+r[6]*i+r[10]*o+r[14])/l,e.w=1,e}transformVector4(t,e){let r=this.rawData;e||(e=new g);let a=t.x,i=t.y,o=t.z,l=t.w;return e.x=a*r[0]+i*r[4]+o*r[8]+l*r[12],e.y=a*r[1]+i*r[5]+o*r[9]+l*r[13],e.z=a*r[2]+i*r[6]+o*r[10]+l*r[14],e.w=a*r[3]+i*r[7]+o*r[11]+l*r[15],e}perspectiveMultiplyPoint3(t,e){let r=g.HELP_2,a,i=this.rawData;if(r.x=i[0]*t.x+i[4]*t.y+i[8]*t.z+i[12],r.y=i[1]*t.x+i[5]*t.y+i[9]*t.z+i[13],r.z=i[2]*t.x+i[6]*t.y+i[10]*t.z+i[14],a=i[3]*t.x+i[7]*t.y+i[11]*t.z+i[15],Math.abs(a)>1e-7){let o=1/a;return e.x=r.x*o,e.y=r.y*o,e.z=r.z*o,!0}else return e.x=0,e.y=0,e.z=0,!1}perspective(t,e,r,a){let i=this.rawData,o=t*Ze/2,l=Math.cos(o)/Math.sin(o);i[0]=-l/e,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=l,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=a/(a-r),i[11]=1,i[12]=0,i[13]=0,i[14]=-r*a/(a-r),i[15]=0}perspective3(t,e,r,a){var i=Math.tan(t*Math.PI/360)*r,o=i*e;this.frustum(-o,o,-i,i,r,a)}frustum(t,e,r,a,i,o){var l=this.rawData;l[0]=-2*i/(e-t),l[1]=0,l[2]=0,l[3]=0,l[4]=0,l[5]=2*i/(a-r),l[6]=0,l[7]=0,l[8]=(e+t)/(e-t),l[9]=(a+r)/(a-r),l[10]=o/(o-i),l[11]=1,l[12]=0,l[13]=0,l[14]=-o*i/(o-i),l[15]=0}ortho(t,e,r,a){let i=this.rawData;return i[0]=2/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=2/e,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1/(a-r),i[11]=0,i[12]=0,i[13]=0,i[14]=r/(r-a),i[15]=1,this}orthoZO(t,e,r,a,i,o){let l=this.rawData,h=1/(t-e),c=1/(r-a),u=1/(i-o);return l[0]=-2*h,l[1]=0,l[2]=0,l[3]=0,l[4]=0,l[5]=-2*c,l[6]=0,l[7]=0,l[8]=0,l[9]=0,l[10]=u,l[11]=0,l[12]=(t+e)*h,l[13]=(a+r)*c,l[14]=i*u,l[15]=1,this}orthoOffCenter(t,e,r,a,i,o){let l=this.rawData;l[0]=-2/(e-t),l[1]=0,l[2]=0,l[3]=0,l[4]=0,l[5]=2/(a-r),l[6]=0,l[7]=0,l[8]=0,l[9]=0,l[10]=1/(o-i),l[11]=0,l[12]=(t+e)/(t-e),l[13]=(a+r)/(r-a),l[14]=i/(i-o),l[15]=1}transformDir(t,e){let r=this.rawData,a=1e-6,i=g.ZERO;e.crossProduct(t,i);let o=e.dotProduct(t);if(o>1-a)this.identity();else if(o<-1+a){let l=g.HELP_1,h=g.HELP_2,c=0,u,d,f,A,p,B,F,U,Q,y,b,x,w,D,O,L,$,J;h.x=0,h.y=t.z,h.z=-t.y,h.dotProduct(h)<a&&(h.x=-t.z,h.y=0,h.z=t.x),c=1/Math.sqrt(h.dotProduct(h)),h.x*=c,h.y*=c,h.z*=c,h.crossProduct(t,l),u=-t.x*t.x,d=-t.y*t.y,f=-t.z*t.z,A=-t.x*t.y,p=-t.x*t.z,B=-t.y*t.z,F=l.x*l.x,U=l.y*l.y,Q=l.z*l.z,y=l.x*l.y,b=l.x*l.z,x=l.y*l.z,w=-h.x*h.x,D=-h.y*h.y,O=-h.z*h.z,L=-h.x*h.y,$=-h.x*h.z,J=-h.y*h.z,r[0]=u+F+w,r[1]=A+y+L,r[2]=p+b+$,r[4]=r[1],r[5]=d+U+D,r[6]=B+x+J,r[8]=r[2],r[9]=r[6],r[10]=f+Q+O,r[3]=0,r[7]=0,r[11]=0,r[15]=1}else{let l,h,c,u,d,f=i.dotProduct(i),A=(1-o)/f;l=A*i.x,h=A*i.z,c=l*i.y,u=l*i.z,d=h*i.y,r[0]=o+l*i.x,r[1]=c-i.z,r[2]=u+i.y,r[4]=c+i.z,r[5]=o+A*i.y*i.y,r[6]=d-i.x,r[8]=u-i.y,r[9]=d+i.x,r[10]=o+h*i.z,r[3]=0,r[7]=0,r[11]=0,r[15]=1}return this}append(t){let e=this.rawData,r=e[0],a=e[4],i=e[8],o=e[12],l=e[1],h=e[5],c=e[9],u=e[13],d=e[2],f=e[6],A=e[10],p=e[14],B=e[3],F=e[7],U=e[11],Q=e[15];e[0]=r*t.rawData[0]+l*t.rawData[4]+d*t.rawData[8]+B*t.rawData[12],e[1]=r*t.rawData[1]+l*t.rawData[5]+d*t.rawData[9]+B*t.rawData[13],e[2]=r*t.rawData[2]+l*t.rawData[6]+d*t.rawData[10]+B*t.rawData[14],e[3]=r*t.rawData[3]+l*t.rawData[7]+d*t.rawData[11]+B*t.rawData[15],e[4]=a*t.rawData[0]+h*t.rawData[4]+f*t.rawData[8]+F*t.rawData[12],e[5]=a*t.rawData[1]+h*t.rawData[5]+f*t.rawData[9]+F*t.rawData[13],e[6]=a*t.rawData[2]+h*t.rawData[6]+f*t.rawData[10]+F*t.rawData[14],e[7]=a*t.rawData[3]+h*t.rawData[7]+f*t.rawData[11]+F*t.rawData[15],e[8]=i*t.rawData[0]+c*t.rawData[4]+A*t.rawData[8]+U*t.rawData[12],e[9]=i*t.rawData[1]+c*t.rawData[5]+A*t.rawData[9]+U*t.rawData[13],e[10]=i*t.rawData[2]+c*t.rawData[6]+A*t.rawData[10]+U*t.rawData[14],e[11]=i*t.rawData[3]+c*t.rawData[7]+A*t.rawData[11]+U*t.rawData[15],e[12]=o*t.rawData[0]+u*t.rawData[4]+p*t.rawData[8]+Q*t.rawData[12],e[13]=o*t.rawData[1]+u*t.rawData[5]+p*t.rawData[9]+Q*t.rawData[13],e[14]=o*t.rawData[2]+u*t.rawData[6]+p*t.rawData[10]+Q*t.rawData[14],e[15]=o*t.rawData[3]+u*t.rawData[7]+p*t.rawData[11]+Q*t.rawData[15]}add(t){let e=this.rawData,r=e[0],a=e[4],i=e[8],o=e[12],l=e[1],h=e[5],c=e[9],u=e[13],d=e[2],f=e[6],A=e[10],p=e[14],B=e[3],F=e[7],U=e[11],Q=e[15],y=t.rawData[0],b=t.rawData[4],x=t.rawData[8],w=t.rawData[12],D=t.rawData[1],O=t.rawData[5],L=t.rawData[9],$=t.rawData[13],J=t.rawData[2],ue=t.rawData[6],ee=t.rawData[10],se=t.rawData[14],Ce=t.rawData[3],me=t.rawData[7],Oe=t.rawData[11],Ye=t.rawData[15];return e[0]=r+y,e[1]=l+D,e[2]=d+J,e[3]=B+Ce,e[4]=a+b,e[5]=h+O,e[6]=f+ue,e[7]=F+me,e[8]=i+x,e[9]=c+L,e[10]=A+ee,e[11]=U+Oe,e[12]=o+w,e[13]=u+$,e[14]=p+se,e[15]=Q+Ye,this}sub(t){let e=this.rawData,r=e[0],a=e[4],i=e[8],o=e[12],l=e[1],h=e[5],c=e[9],u=e[13],d=e[2],f=e[6],A=e[10],p=e[14],B=e[3],F=e[7],U=e[11],Q=e[15],y=t.rawData[0],b=t.rawData[4],x=t.rawData[8],w=t.rawData[12],D=t.rawData[1],O=t.rawData[5],L=t.rawData[9],$=t.rawData[13],J=t.rawData[2],ue=t.rawData[6],ee=t.rawData[10],se=t.rawData[14],Ce=t.rawData[3],me=t.rawData[7],Oe=t.rawData[11],Ye=t.rawData[15];return e[0]=r-y,e[1]=l-D,e[2]=d-J,e[3]=B-Ce,e[4]=a-b,e[5]=h-O,e[6]=f-ue,e[7]=F-me,e[8]=i-x,e[9]=c-L,e[10]=A-ee,e[11]=U-Oe,e[12]=o-w,e[13]=u-$,e[14]=p-se,e[15]=Q-Ye,this}mult(t){let e=this.rawData;return e[0]*=t,e[1]*=t,e[2]*=t,e[3]*=t,e[4]*=t,e[5]*=t,e[6]*=t,e[7]*=t,e[8]*=t,e[9]*=t,e[10]*=t,e[11]*=t,e[12]*=t,e[13]*=t,e[14]*=t,e[15]*=t,this}appendRotation(t,e){let r=_.getAxisRotation(e.x,e.y,e.z,t);this.append(r)}createByRotation(t,e){let r=_.helpMatrix,a,i,o=t*Ze;return a=Math.sin(o),i=Math.cos(o),e.x==1&&(r.rawData[0]=1,r.rawData[1]=0,r.rawData[2]=0,r.rawData[3]=0,r.rawData[4]=0,r.rawData[5]=i,r.rawData[6]=a,r.rawData[7]=0,r.rawData[8]=0,r.rawData[9]=-a,r.rawData[10]=i,r.rawData[11]=0,r.rawData[12]=0,r.rawData[13]=0,r.rawData[14]=0,r.rawData[15]=1),e.y==1&&(r.rawData[0]=i,r.rawData[1]=0,r.rawData[2]=-a,r.rawData[3]=0,r.rawData[4]=0,r.rawData[5]=1,r.rawData[6]=0,r.rawData[7]=0,r.rawData[8]=a,r.rawData[9]=0,r.rawData[10]=i,r.rawData[11]=0,r.rawData[12]=0,r.rawData[13]=0,r.rawData[14]=0,r.rawData[15]=1),e.z==1&&(r.rawData[0]=i,r.rawData[1]=a,r.rawData[2]=0,r.rawData[3]=0,r.rawData[4]=-a,r.rawData[5]=i,r.rawData[6]=0,r.rawData[7]=0,r.rawData[8]=0,r.rawData[9]=0,r.rawData[10]=1,r.rawData[11]=0,r.rawData[12]=0,r.rawData[13]=0,r.rawData[14]=0,r.rawData[15]=1),this.append(r),this}appendScale(t,e,r){_.helpMatrix.createByScale(t,e,r),this.append(_.helpMatrix)}createByScale(t,e,r){let a=this.rawData;a[0]=t,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=e,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=r,a[11]=0,a[12]=0,a[13]=0,a[14]=0,a[15]=1}appendTranslation(t,e,r){let a=this.rawData;a[12]+=t,a[13]+=e,a[14]+=r}clone(){let t=new _;return t.copyFrom(this),t}copyRowFrom(t,e){let r=this.rawData;switch(t){case 0:r[0]=e.x,r[1]=e.y,r[2]=e.z,r[3]=e.w;break;case 1:r[4]=e.x,r[5]=e.y,r[6]=e.z,r[7]=e.w;break;case 2:r[8]=e.x,r[9]=e.y,r[10]=e.z,r[11]=e.w;break;case 3:r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=e.w;break}}copyRowTo(t,e){let r=this.rawData;switch(t){case 0:e.x=r[0],e.y=r[1],e.z=r[2],e.w=r[3];break;case 1:e.x=r[4],e.y=r[5],e.z=r[6],e.w=r[7];break;case 2:e.x=r[8],e.y=r[9],e.z=r[10],e.w=r[11];break;case 3:e.x=r[12],e.y=r[13],e.z=r[14],e.w=r[15];break}}copyFrom(t){let e=this.rawData;return e[0]=t.rawData[0],e[1]=t.rawData[1],e[2]=t.rawData[2],e[3]=t.rawData[3],e[4]=t.rawData[4],e[5]=t.rawData[5],e[6]=t.rawData[6],e[7]=t.rawData[7],e[8]=t.rawData[8],e[9]=t.rawData[9],e[10]=t.rawData[10],e[11]=t.rawData[11],e[12]=t.rawData[12],e[13]=t.rawData[13],e[14]=t.rawData[14],e[15]=t.rawData[15],this}copyRawDataTo(t,e=0,r=!1){let a=this.rawData;t[0+e]=a[0],t[1+e]=a[1],t[2+e]=a[2],t[3+e]=a[3],t[4+e]=a[4],t[5+e]=a[5],t[6+e]=a[6],t[7+e]=a[7],t[8+e]=a[8],t[9+e]=a[9],t[10+e]=a[10],t[11+e]=a[11],t[12+e]=a[12],t[13+e]=a[13],t[14+e]=a[14],t[15+e]=a[15]}copyColFrom(t,e){let r=this.rawData;switch(t){case 0:r[0]=e.x,r[4]=e.y,r[8]=e.z,r[12]=e.w;break;case 1:r[1]=e.x,r[5]=e.y,r[9]=e.z,r[13]=e.w;break;case 2:r[2]=e.x,r[6]=e.y,r[10]=e.z,r[14]=e.w;break;case 3:r[3]=e.x,r[7]=e.y,r[11]=e.z,r[15]=e.w;break}}copyColTo(t,e){let r=this.rawData;switch(t){case 0:e.x=r[0],e.y=r[4],e.z=r[8],e.w=r[12];break;case 1:e.x=r[1],e.y=r[5],e.z=r[9],e.w=r[13];break;case 2:e.x=r[2],e.y=r[6],e.z=r[10],e.w=r[14];break;case 3:e.x=r[3],e.y=r[7],e.z=r[11],e.w=r[15];break}}copyToMatrix3D(t){t.rawData=this.rawData.slice(0)}makeRotationFromQuaternion(t){return this.compose(_._zero,t,_._one),this}decompose(t="eulerAngles",e){let r=X.CALCULATION_QUATERNION,a=e||_._prs;this.copyRawDataTo(_.decomposeRawData);let i=_.decomposeRawData,o=a[0];o.x=i[12],o.y=i[13],o.z=i[14],i[12]=0,i[13]=0,i[14]=0;let l=a[2];l.x=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]),l.y=Math.sqrt(i[4]*i[4]+i[5]*i[5]+i[6]*i[6]),l.z=Math.sqrt(i[8]*i[8]+i[9]*i[9]+i[10]*i[10]),i[0]*(i[5]*i[10]-i[6]*i[9])-i[1]*(i[4]*i[10]-i[6]*i[8])+i[2]*(i[4]*i[9]-i[5]*i[8])<0&&(l.z=-l.z),i[0]/=l.x,i[1]/=l.x,i[2]/=l.x,i[4]/=l.y,i[5]/=l.y,i[6]/=l.y,i[8]/=l.z,i[9]/=l.z,i[10]/=l.z;let h=a[1],c;switch(t){case Wt.AXIS_ANGLE:h.w=Math.acos((i[0]+i[5]+i[10]-1)/2);let u=Math.sqrt((i[6]-i[9])*(i[6]-i[9])+(i[8]-i[2])*(i[8]-i[2])+(i[1]-i[4])*(i[1]-i[4]));h.x=(i[6]-i[9])/u,h.y=(i[8]-i[2])/u,h.z=(i[1]-i[4])/u;break;case Wt.QUATERNION:c=i[0]+i[5]+i[10],c>0?(h.w=Math.sqrt(1+c)/2,h.x=(i[6]-i[9])/(4*h.w),h.y=(i[8]-i[2])/(4*h.w),h.z=(i[1]-i[4])/(4*h.w)):i[0]>i[5]&&i[0]>i[10]?(h.x=Math.sqrt(1+i[0]-i[5]-i[10])/2,h.w=(i[6]-i[9])/(4*h.x),h.y=(i[1]+i[4])/(4*h.x),h.z=(i[8]+i[2])/(4*h.x)):i[5]>i[10]?(h.y=Math.sqrt(1+i[5]-i[0]-i[10])/2,h.x=(i[1]+i[4])/(4*h.y),h.w=(i[8]-i[2])/(4*h.y),h.z=(i[6]+i[9])/(4*h.y)):(h.z=Math.sqrt(1+i[10]-i[0]-i[5])/2,h.x=(i[8]+i[2])/(4*h.z),h.y=(i[6]+i[9])/(4*h.z),h.w=(i[1]-i[4])/(4*h.z));break;case Wt.EULER_ANGLES:c=i[0]+i[5]+i[10],c>0?(r.w=Math.sqrt(1+c)/2,r.x=(i[6]-i[9])/(4*r.w),r.y=(i[8]-i[2])/(4*r.w),r.z=(i[1]-i[4])/(4*r.w)):i[0]>i[5]&&i[0]>i[10]?(r.x=Math.sqrt(1+i[0]-i[5]-i[10])/2,r.w=(i[6]-i[9])/(4*r.x),r.y=(i[1]+i[4])/(4*r.x),r.z=(i[8]+i[2])/(4*r.x)):i[5]>i[10]?(h.y=Math.sqrt(1+i[5]-i[0]-i[10])/2,r.x=(i[1]+i[4])/(4*r.y),r.w=(i[8]-i[2])/(4*r.y),r.z=(i[6]+i[9])/(4*r.y)):(r.z=Math.sqrt(1+i[10]-i[0]-i[5])/2,r.x=(i[8]+i[2])/(4*r.z),r.y=(i[6]+i[9])/(4*r.z),r.w=(i[1]-i[4])/(4*r.z)),r.getEulerAngles(h);break}return a[0]=o,a[1]=h,a[2]=l,a}static getEuler(t,e,r=!0,a){return t||(t=new g),_._getEulerMatrix.makeRotationFromQuaternion(e).makeEuler(t,r,a),t}compose(t,e,r){const a=this.rawData,i=e.x,o=e.y,l=e.z,h=e.w,c=i+i,u=o+o,d=l+l,f=i*c,A=i*u,p=i*d,B=o*u,F=o*d,U=l*d,Q=h*c,y=h*u,b=h*d,x=r.x,w=r.y,D=r.z;return a[0]=(1-(B+U))*x,a[1]=(A+b)*x,a[2]=(p-y)*x,a[3]=0,a[4]=(A-b)*w,a[5]=(1-(f+U))*w,a[6]=(F+Q)*w,a[7]=0,a[8]=(p+y)*D,a[9]=(F-Q)*D,a[10]=(1-(f+B))*D,a[11]=0,a[12]=t.x,a[13]=t.y,a[14]=t.z,a[15]=1,this}deltaTransformVector(t,e){e||(e=new g);let r=this.rawData,a=t.x,i=t.y,o=t.z;return e.x=a*r[0]+i*r[4]+o*r[8],e.y=a*r[1]+i*r[5]+o*r[9],e.z=a*r[2]+i*r[6]+o*r[10],e.w=a*r[3]+i*r[7]+o*r[11],e}identity(){let t=this.rawData;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}fill(t){let e=this.rawData;e[1]=t,e[2]=t,e[3]=t,e[4]=t,e[6]=t,e[7]=t,e[8]=t,e[9]=t,e[11]=t,e[12]=t,e[13]=t,e[14]=t,e[0]=t,e[5]=t,e[10]=t,e[15]=t}invers33(){let t=this.rawData,e=t[5]*t[10]-t[9]*t[6],r=t[8]*t[6]-t[4]*t[10],a=t[4]*t[9]-t[8]*t[5],i=t[9]*t[2]-t[1]*t[10],o=t[0]*t[10]-t[8]*t[2],l=t[8]*t[1]-t[0]*t[9],h=t[1]*t[6]-t[5]*t[2],c=t[4]*t[2]-t[0]*t[6],u=t[0]*t[5]-t[4]*t[1],d=t[0]*e+t[4]*i+t[8]*h;if(Math.abs(d)>1e-11){let f=1/d;t[0]=f*e,t[4]=f*r,t[8]=f*a,t[1]=f*i,t[5]=f*o,t[9]=f*l,t[2]=f*h,t[6]=f*c,t[10]=f*u}}invert(){let t=this.determinant,e=Math.abs(t)>1e-11,r=this.rawData;if(e){t=1/t;let a=r[0],i=r[4],o=r[8],l=r[12],h=r[1],c=r[5],u=r[9],d=r[13],f=r[2],A=r[6],p=r[10],B=r[14],F=r[3],U=r[7],Q=r[11],y=r[15];r[0]=t*(c*(p*y-B*Q)-u*(A*y-B*U)+d*(A*Q-p*U)),r[1]=-t*(h*(p*y-B*Q)-u*(f*y-B*F)+d*(f*Q-p*F)),r[2]=t*(h*(A*y-B*U)-c*(f*y-B*F)+d*(f*U-A*F)),r[3]=-t*(h*(A*Q-p*U)-c*(f*Q-p*F)+u*(f*U-A*F)),r[4]=-t*(i*(p*y-B*Q)-o*(A*y-B*U)+l*(A*Q-p*U)),r[5]=t*(a*(p*y-B*Q)-o*(f*y-B*F)+l*(f*Q-p*F)),r[6]=-t*(a*(A*y-B*U)-i*(f*y-B*F)+l*(f*U-A*F)),r[7]=t*(a*(A*Q-p*U)-i*(f*Q-p*F)+o*(f*U-A*F)),r[8]=t*(i*(u*y-d*Q)-o*(c*y-d*U)+l*(c*Q-u*U)),r[9]=-t*(a*(u*y-d*Q)-o*(h*y-d*F)+l*(h*Q-u*F)),r[10]=t*(a*(c*y-d*U)-i*(h*y-d*F)+l*(h*U-c*F)),r[11]=-t*(a*(c*Q-u*U)-i*(h*Q-u*F)+o*(h*U-c*F)),r[12]=-t*(i*(u*B-d*p)-o*(c*B-d*A)+l*(c*p-u*A)),r[13]=t*(a*(u*B-d*p)-o*(h*B-d*f)+l*(h*p-u*f)),r[14]=-t*(a*(c*B-d*A)-i*(h*B-d*f)+l*(h*A-c*f)),r[15]=t*(a*(c*p-u*A)-i*(h*p-u*f)+o*(h*A-c*f))}return e}transformPoint(t,e){let r=this.rawData;e||(e=new g);let a=t.x,i=t.y,o=t.z;return e.x=a*r[0]+i*r[4]+o*r[8]+r[12],e.y=a*r[1]+i*r[5]+o*r[9]+r[13],e.z=a*r[2]+i*r[6]+o*r[10]+r[14],e}transformVector(t,e){let r=this.rawData;e||(e=new g);let a=t.x,i=t.y,o=t.z;return e.x=a*r[0]+i*r[4]+o*r[8],e.y=a*r[1]+i*r[5]+o*r[9],e.z=a*r[2]+i*r[6]+o*r[10],e}transpose(){let t=this.rawData;for(let e=0;e<_.helpMatrix.rawData.length;e++)_.helpMatrix.rawData[e]=t[e];t[1]=_.helpMatrix.rawData[4],t[2]=_.helpMatrix.rawData[8],t[3]=_.helpMatrix.rawData[12],t[4]=_.helpMatrix.rawData[1],t[6]=_.helpMatrix.rawData[9],t[7]=_.helpMatrix.rawData[13],t[8]=_.helpMatrix.rawData[2],t[9]=_.helpMatrix.rawData[6],t[11]=_.helpMatrix.rawData[14],t[12]=_.helpMatrix.rawData[3],t[13]=_.helpMatrix.rawData[7],t[14]=_.helpMatrix.rawData[11]}get determinant(){let t=this.rawData;return(t[0]*t[5]-t[4]*t[1])*(t[10]*t[15]-t[14]*t[11])-(t[0]*t[9]-t[8]*t[1])*(t[6]*t[15]-t[14]*t[7])+(t[0]*t[13]-t[12]*t[1])*(t[6]*t[11]-t[10]*t[7])+(t[4]*t[9]-t[8]*t[5])*(t[2]*t[15]-t[14]*t[3])-(t[4]*t[13]-t[12]*t[5])*(t[2]*t[11]-t[10]*t[3])+(t[8]*t[13]-t[12]*t[9])*(t[2]*t[7]-t[6]*t[3])}getPosition(t){t||(t=new g);let e=this.rawData;return t.x=e[12],t.y=e[13],t.z=e[14],t}get position(){return this._position.set(this.rawData[12],this.rawData[13],this.rawData[14]),this._position}set position(t){let e=this.rawData;e[12]=t.x,e[13]=t.y,e[14]=t.z}get scale(){let t=this.rawData;return new g(t[0],t[5],t[10])}set scale(t){let e=this.rawData;e[0]=t.x,e[5]=t.y,e[10]=t.z}toString(){let t=this.rawData;return"matrix3d("+Math.round(t[0]*1e3)/1e3+","+Math.round(t[1]*1e3)/1e3+","+Math.round(t[2]*1e3)/1e3+","+Math.round(t[3]*1e3)/1e3+","+Math.round(t[4]*1e3)/1e3+","+Math.round(t[5]*1e3)/1e3+","+Math.round(t[6]*1e3)/1e3+","+Math.round(t[7]*1e3)/1e3+","+Math.round(t[8]*1e3)/1e3+","+Math.round(t[9]*1e3)/1e3+","+Math.round(t[10]*1e3)/1e3+","+Math.round(t[11]*1e3)/1e3+","+Math.round(t[12]*1e3)/1e3+","+Math.round(t[13]*1e3)/1e3+","+Math.round(t[14]*1e3)/1e3+","+Math.round(t[15]*1e3)/1e3+")"}lerp(t,e,r){this.copyFrom(e).sub(t).mult(r).add(t)}get(t,e){return this.rawData[t+e*4]}set(t,e,r){this.rawData[t+e*4]=r}getMaxScaleOnAxis(){let t=this.rawData,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],r=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],a=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,r,a))}translate(t){let e=this.get(0,0)*t.x+this.get(0,1)*t.y+this.get(0,2)*t.z+this.get(0,3),r=this.get(1,0)*t.x+this.get(1,1)*t.y+this.get(1,2)*t.z+this.get(1,3),a=this.get(2,0)*t.x+this.get(2,1)*t.y+this.get(2,2)*t.z+this.get(2,3),i=this.get(3,0)*t.x+this.get(3,1)*t.y+this.get(3,2)*t.z+this.get(3,3);return this.set(0,3,e),this.set(1,3,r),this.set(2,3,a),this.set(3,3,i),this}setTRInverse(t,e){e=e.inverse(),X.quaternionToMatrix(e,this),this.translate(new g(-t.x,-t.y,-t.z))}setScale(t){return this.set(0,0,t.x),this.set(0,1,0),this.set(0,2,0),this.set(0,3,0),this.set(1,0,0),this.set(1,1,t.y),this.set(1,2,0),this.set(1,3,0),this.set(2,0,0),this.set(2,1,0),this.set(2,2,t.z),this.set(2,3,0),this.set(3,0,0),this.set(3,1,0),this.set(3,2,0),this.set(3,3,1),this}makeBasis(t,e,r){return this.setElements(t.x,e.x,r.x,0,t.y,e.y,r.y,0,t.z,e.z,r.z,0,0,0,0,1),this}makeRotationAxis(t,e){const r=Math.cos(e),a=Math.sin(e),i=1-r,o=t.x,l=t.y,h=t.z,c=i*o,u=i*l;return this.setElements(c*o+r,c*l-a*h,c*h+a*l,0,c*l+a*h,u*l+r,u*h-a*o,0,c*h-a*l,u*h+a*o,i*h*h+r,0,0,0,0,1),this}static transpose(t,e){e||(e=new _);let r=t.rawData,a=e.rawData;return a[0]=r[0],a[1]=r[4],a[2]=r[8],a[3]=r[12],a[4]=r[1],a[5]=r[5],a[6]=r[9],a[7]=r[13],a[8]=r[2],a[9]=r[6],a[10]=r[10],a[11]=r[14],a[12]=r[3],a[13]=r[7],a[14]=r[11],a[15]=r[15],e}static inverse(t,e){e||(e=new _);let r=t.rawData,a=e.rawData;a[0]=r[5]*r[10]*r[15]-r[5]*r[14]*r[11]-r[6]*r[9]*r[15]+r[6]*r[13]*r[11]+r[7]*r[9]*r[14]-r[7]*r[13]*r[10],a[1]=-r[1]*r[10]*r[15]+r[1]*r[14]*r[11]+r[2]*r[9]*r[15]-r[2]*r[13]*r[11]-r[3]*r[9]*r[14]+r[3]*r[13]*r[10],a[2]=r[1]*r[6]*r[15]-r[1]*r[14]*r[7]-r[2]*r[5]*r[15]+r[2]*r[13]*r[7]+r[3]*r[5]*r[14]-r[3]*r[13]*r[6],a[3]=-r[1]*r[6]*r[11]+r[1]*r[10]*r[7]+r[2]*r[5]*r[11]-r[2]*r[9]*r[7]-r[3]*r[5]*r[10]+r[3]*r[9]*r[6],a[4]=-r[4]*r[10]*r[15]+r[4]*r[14]*r[11]+r[6]*r[8]*r[15]-r[6]*r[12]*r[11]-r[7]*r[8]*r[14]+r[7]*r[12]*r[10],a[5]=r[0]*r[10]*r[15]-r[0]*r[14]*r[11]-r[2]*r[8]*r[15]+r[2]*r[12]*r[11]+r[3]*r[8]*r[14]-r[3]*r[12]*r[10],a[6]=-r[0]*r[6]*r[15]+r[0]*r[14]*r[7]+r[2]*r[4]*r[15]-r[2]*r[12]*r[7]-r[3]*r[4]*r[14]+r[3]*r[12]*r[6],a[7]=r[0]*r[6]*r[11]-r[0]*r[10]*r[7]-r[2]*r[4]*r[11]+r[2]*r[8]*r[7]+r[3]*r[4]*r[10]-r[3]*r[8]*r[6],a[8]=r[4]*r[9]*r[15]-r[4]*r[13]*r[11]-r[5]*r[8]*r[15]+r[5]*r[12]*r[11]+r[7]*r[8]*r[13]-r[7]*r[12]*r[9],a[9]=-r[0]*r[9]*r[15]+r[0]*r[13]*r[11]+r[1]*r[8]*r[15]-r[1]*r[12]*r[11]-r[3]*r[8]*r[13]+r[3]*r[12]*r[9],a[10]=r[0]*r[5]*r[15]-r[0]*r[13]*r[7]-r[1]*r[4]*r[15]+r[1]*r[12]*r[7]+r[3]*r[4]*r[13]-r[3]*r[12]*r[5],a[11]=-r[0]*r[5]*r[11]+r[0]*r[9]*r[7]+r[1]*r[4]*r[11]-r[1]*r[8]*r[7]-r[3]*r[4]*r[9]+r[3]*r[8]*r[5],a[12]=-r[4]*r[9]*r[14]+r[4]*r[13]*r[10]+r[5]*r[8]*r[14]-r[5]*r[12]*r[10]-r[6]*r[8]*r[13]+r[6]*r[12]*r[9],a[13]=r[0]*r[9]*r[14]-r[0]*r[13]*r[10]-r[1]*r[8]*r[14]+r[1]*r[12]*r[10]+r[2]*r[8]*r[13]-r[2]*r[12]*r[9],a[14]=-r[0]*r[5]*r[14]+r[0]*r[13]*r[6]+r[1]*r[4]*r[14]-r[1]*r[12]*r[6]-r[2]*r[4]*r[13]+r[2]*r[12]*r[5],a[15]=r[0]*r[5]*r[10]-r[0]*r[9]*r[6]-r[1]*r[4]*r[10]+r[1]*r[8]*r[6]+r[2]*r[4]*r[9]-r[2]*r[8]*r[5];let i=r[0]*a[0]+r[1]*a[4]+r[2]*a[8]+r[3]*a[12];for(let o=0;o<16;o++)a[o]/=i;return e}makeEuler(t,e,r="XYZ"){const a=this.rawData,i=a[0],o=a[4],l=a[8],h=a[1],c=a[5],u=a[9],d=a[2],f=a[6],A=a[10];switch(r){case"XYZ":t.y=Math.asin(yt(l,-1,1)),Math.abs(l)<.9999999?(t.x=Math.atan2(-u,A),t.z=Math.atan2(-o,i)):(t.x=Math.atan2(f,c),t.z=0);break;case"YXZ":t.x=Math.asin(-yt(u,-1,1)),Math.abs(u)<.9999999?(t.y=Math.atan2(l,A),t.z=Math.atan2(h,c)):(t.y=Math.atan2(-d,i),t.z=0);break;case"ZXY":t.x=Math.asin(yt(f,-1,1)),Math.abs(f)<.9999999?(t.y=Math.atan2(-d,A),t.z=Math.atan2(-o,c)):(t.y=0,t.z=Math.atan2(h,i));break;case"ZYX":t.y=Math.asin(-yt(d,-1,1)),Math.abs(d)<.9999999?(t.x=Math.atan2(f,A),t.z=Math.atan2(h,i)):(t.x=0,t.z=Math.atan2(-o,c));break;case"YZX":t.z=Math.asin(yt(h,-1,1)),Math.abs(h)<.9999999?(t.x=Math.atan2(-u,c),t.y=Math.atan2(-d,i)):(t.x=0,t.y=Math.atan2(l,A));break;case"XZY":t.z=Math.asin(-yt(o,-1,1)),Math.abs(o)<.9999999?(t.x=Math.atan2(f,c),t.y=Math.atan2(l,i)):(t.x=Math.atan2(-u,A),t.y=0);break}return e&&t.multiplyScalar(Ca),t}setElements(t,e,r,a,i,o,l,h,c,u,d,f,A,p,B,F){const U=this.rawData;return U[0]=t,U[4]=e,U[8]=r,U[12]=a,U[1]=i,U[5]=o,U[9]=l,U[13]=h,U[2]=c,U[6]=u,U[10]=d,U[14]=f,U[3]=A,U[7]=p,U[11]=B,U[15]=F,this}makeMatrix44ByQuaternion(t,e,r){this.identity(),X.quaternionToMatrix(r,this),this.appendTranslation(t.x,t.y,t.z),this.appendScale(e.x,e.y,e.z)}};s(_,"blockBytes",16*4),s(_,"block",16),s(_,"allocCount",1e3),s(_,"allocOnceCount",1e3),s(_,"maxCount",50*1e4),s(_,"useCount",0),s(_,"buffer"),s(_,"wasmMatrixPtr",0),s(_,"dynamicMatrixBytes"),s(_,"dynamicGlobalMatrixRef"),s(_,"wasm"),s(_,"help_matrix_0"),s(_,"help_matrix_1"),s(_,"help_matrix_2"),s(_,"helpMatrix"),s(_,"helpMatrix2"),s(_,"_getEulerMatrix"),s(_,"_zero",new g(0,0,0)),s(_,"_one",new g(1,1,1)),s(_,"_prs",[new g,new g,new g]),s(_,"floatArray",new Float64Array(16).fill(0)),s(_,"decomposeRawData",new Float64Array(16).fill(0));let Z=_;function xl(n,t,e){for(let r=0;r<4;r++)e.rawData[r]=n.rawData[r]*t.rawData[0]+n.rawData[r+4]*t.rawData[1]+n.rawData[r+8]*t.rawData[2]+n.rawData[r+12]*t.rawData[3],e.rawData[r+4]=n.rawData[r]*t.rawData[4]+n.rawData[r+4]*t.rawData[5]+n.rawData[r+8]*t.rawData[6]+n.rawData[r+12]*t.rawData[7],e.rawData[r+8]=n.rawData[r]*t.rawData[8]+n.rawData[r+4]*t.rawData[9]+n.rawData[r+8]*t.rawData[10]+n.rawData[r+12]*t.rawData[11],e.rawData[r+12]=n.rawData[r]*t.rawData[12]+n.rawData[r+4]*t.rawData[13]+n.rawData[r+8]*t.rawData[14]+n.rawData[r+12]*t.rawData[15]}function Ci(n,t,e,r){let a=r.rawData,i=n.x*Ze,o=n.y*Ze,l=n.z*Ze,h=0,c=i*.5,u=o*.5,d=l*.5,f=Math.cos(c),A=Math.sin(c),p=Math.cos(u),B=Math.sin(u),F=Math.cos(d),U=Math.sin(d);h=f*p*F+A*B*U,i=A*p*F-f*B*U,o=f*B*F+A*p*U,l=f*p*U-A*B*F;let Q=i+i,y=o+o,b=l+l,x=i*Q,w=i*y,D=i*b,O=o*y,L=o*b,$=l*b,J=h*Q,ue=h*y,ee=h*b,se=e.x,Ce=e.y,me=e.z;a[0]=(1-(O+$))*se,a[1]=(w+ee)*se,a[2]=(D-ue)*se,a[3]=0,a[4]=(w-ee)*Ce,a[5]=(1-(x+$))*Ce,a[6]=(L+J)*Ce,a[7]=0,a[8]=(D+ue)*me,a[9]=(L-J)*me,a[10]=(1-(x+O))*me,a[11]=0,a[12]=t.x,a[13]=t.y,a[14]=t.z,a[15]=1}function bl(n,t,e){let r=n.rawData,a=e.rawData,i=r[0],o=r[4],l=r[8],h=r[12],c=r[1],u=r[5],d=r[9],f=r[13],A=r[2],p=r[6],B=r[10],F=r[14],U=r[3],Q=r[7],y=r[11],b=r[15];a[0]=i*t.rawData[0]+c*t.rawData[4]+A*t.rawData[8]+U*t.rawData[12],a[1]=i*t.rawData[1]+c*t.rawData[5]+A*t.rawData[9]+U*t.rawData[13],a[2]=i*t.rawData[2]+c*t.rawData[6]+A*t.rawData[10]+U*t.rawData[14],a[3]=i*t.rawData[3]+c*t.rawData[7]+A*t.rawData[11]+U*t.rawData[15],a[4]=o*t.rawData[0]+u*t.rawData[4]+p*t.rawData[8]+Q*t.rawData[12],a[5]=o*t.rawData[1]+u*t.rawData[5]+p*t.rawData[9]+Q*t.rawData[13],a[6]=o*t.rawData[2]+u*t.rawData[6]+p*t.rawData[10]+Q*t.rawData[14],a[7]=o*t.rawData[3]+u*t.rawData[7]+p*t.rawData[11]+Q*t.rawData[15],a[8]=l*t.rawData[0]+d*t.rawData[4]+B*t.rawData[8]+y*t.rawData[12],a[9]=l*t.rawData[1]+d*t.rawData[5]+B*t.rawData[9]+y*t.rawData[13],a[10]=l*t.rawData[2]+d*t.rawData[6]+B*t.rawData[10]+y*t.rawData[14],a[11]=l*t.rawData[3]+d*t.rawData[7]+B*t.rawData[11]+y*t.rawData[15],a[12]=h*t.rawData[0]+f*t.rawData[4]+F*t.rawData[8]+b*t.rawData[12],a[13]=h*t.rawData[1]+f*t.rawData[5]+F*t.rawData[9]+b*t.rawData[13],a[14]=h*t.rawData[2]+f*t.rawData[6]+F*t.rawData[10]+b*t.rawData[14],a[15]=h*t.rawData[3]+f*t.rawData[7]+F*t.rawData[11]+b*t.rawData[15]}function Qs(n,t,e){let r=n.rawData,a=r[0],i=r[1],o=r[2],l=r[3],h=r[4],c=r[5],u=r[6],d=r[7],f=r[8],A=r[9],p=r[10],B=r[11],F=r[12],U=r[13],Q=r[14],y=r[15],b=t.rawData,x=e.rawData,w=b[0],D=b[1],O=b[2],L=b[3];return x[0]=w*a+D*h+O*f+L*F,x[1]=w*i+D*c+O*A+L*U,x[2]=w*o+D*u+O*p+L*Q,x[3]=w*l+D*d+O*B+L*y,w=b[4],D=b[5],O=b[6],L=b[7],x[4]=w*a+D*h+O*f+L*F,x[5]=w*i+D*c+O*A+L*U,x[6]=w*o+D*u+O*p+L*Q,x[7]=w*l+D*d+O*B+L*y,w=b[8],D=b[9],O=b[10],L=b[11],x[8]=w*a+D*h+O*f+L*F,x[9]=w*i+D*c+O*A+L*U,x[10]=w*o+D*u+O*p+L*Q,x[11]=w*l+D*d+O*B+L*y,w=b[12],D=b[13],O=b[14],L=b[15],x[12]=w*a+D*h+O*f+L*F,x[13]=w*i+D*c+O*A+L*U,x[14]=w*o+D*u+O*p+L*Q,x[15]=w*l+D*d+O*B+L*y,x}var De=(n=>(n[n.None=0]="None",n[n.PointLight=1]="PointLight",n[n.DirectionLight=2]="DirectionLight",n[n.SpotLight=3]="SpotLight",n[n.SkyLight=4]="SkyLight",n))(De||{});class Pa extends xa{constructor(){super(...arguments);s(this,"index",-1);s(this,"lightType",-1);s(this,"radius",.001);s(this,"linear",8);s(this,"lightPosition",new g);s(this,"lightMatrixIndex",-1);s(this,"direction",new g);s(this,"quadratic",.032);s(this,"lightColor",new Y(1,1,1,1));s(this,"intensity",1);s(this,"innerAngle",0);s(this,"outerAngle",1);s(this,"range",100);s(this,"castShadowIndex",-1);s(this,"lightTangent",g.FORWARD);s(this,"iesIndex",-1)}}s(Pa,"lightSize",24);const vt=class vt{static init(){this._init||(this._init=!0,this.componentsUpdateList=new Map,this.componentsLateUpdateList=new Map,this.componentsBeforeUpdateList=new Map,this.componentsComputeList=new Map,this.componentsEnablePickerList=new Map,this.graphicComponent=new Map,this.waitStartComponent=new Map)}static bindUpdate(t,e,r){this.init();let a=this.componentsUpdateList.get(t);a||(a=new Map,this.componentsUpdateList.set(t,a)),a.set(e,r)}static unBindUpdate(t,e){this.init();let r=this.componentsUpdateList.get(t);r&&r.delete(e)}static bindLateUpdate(t,e,r){this.init();let a=this.componentsLateUpdateList.get(t);a||(a=new Map,this.componentsLateUpdateList.set(t,a)),a.set(e,r)}static unBindLateUpdate(t,e){this.init();let r=this.componentsLateUpdateList.get(t);r&&r.delete(e)}static bindBeforeUpdate(t,e,r){this.init();let a=this.componentsBeforeUpdateList.get(t);a||(a=new Map,this.componentsBeforeUpdateList.set(t,a)),a.set(e,r)}static unBindBeforeUpdate(t,e){this.init();let r=this.componentsBeforeUpdateList.get(t);r&&r.delete(e)}static bindCompute(t,e,r){this.init();let a=this.componentsComputeList.get(t);a||(a=new Map,this.componentsComputeList.set(t,a)),a.set(e,r)}static unBindCompute(t,e){this.init();let r=this.componentsComputeList.get(t);r&&r.delete(e)}static bindGraphic(t,e,r){this.init();let a=this.graphicComponent.get(t);a||(a=new Map,this.graphicComponent.set(t,a)),a.set(e,r)}static unBindGraphic(t,e){this.init();let r=this.graphicComponent.get(t);r&&r.delete(e)}static appendWaitStart(t){this.init();let e=this.waitStartComponent.get(t.object3D);e?e.indexOf(t)==-1&&e.push(t):this.waitStartComponent.set(t.object3D,[t])}static removeWaitStart(t,e){this.init();let r=vt.waitStartComponent.get(t);if(r){let a=r.indexOf(e);a!=-1&&r.splice(a)}}static bindEnablePick(t,e,r){this.init();let a=this.componentsEnablePickerList.get(t);a||(a=new Map,this.componentsEnablePickerList.set(t,a)),a.set(e,r)}static unBindEnablePick(t,e){this.init();let r=this.componentsEnablePickerList.get(t);r&&r.delete(e)}};s(vt,"componentsUpdateList"),s(vt,"componentsLateUpdateList"),s(vt,"componentsBeforeUpdateList"),s(vt,"componentsComputeList"),s(vt,"componentsEnablePickerList"),s(vt,"graphicComponent"),s(vt,"waitStartComponent"),s(vt,"_init",!1);let Ue=vt;class ut{constructor(){s(this,"object3D",null);s(this,"_eventDispatcher");s(this,"_enable",!0);s(this,"__isStart",!1);s(this,"isDestroyed",!1)}get eventDispatcher(){return this._eventDispatcher||(this._eventDispatcher=new ra),this._eventDispatcher}set eventDispatcher(t){console.error("The eventDispatcher should not be set externally!")}get isStart(){return this.__isStart}get transform(){return this.object3D.transform}set enable(t){var e,r;this._enable!=t&&(this._enable=t,this._enable?(e=this.onEnable)==null||e.call(this,this.transform.view3D):(r=this.onDisable)==null||r.call(this,this.transform.view3D))}get enable(){return this._enable}__init(t){this.init(t)}__start(){var t,e;this.transform&&this.transform.scene3D&&this._enable&&((t=this.onEnable)==null||t.call(this,this.transform.view3D)),this.transform&&this.transform.scene3D&&this.__isStart==!1&&((e=this.start)==null||e.call(this),this.__isStart=!0),this.onUpdate&&this._onUpdate(this.onUpdate.bind(this)),this.onLateUpdate&&this._onLateUpdate(this.onLateUpdate.bind(this)),this.onBeforeUpdate&&this._onBeforeUpdate(this.onBeforeUpdate.bind(this)),this.onCompute&&this._onCompute(this.onCompute.bind(this)),this.onGraphic&&this._onGraphic(this.onGraphic.bind(this))}__stop(){var t;this.transform&&this.transform.scene3D&&((t=this.onDisable)==null||t.call(this,this.transform.view3D)),this._onUpdate(null),this._onLateUpdate(null),this._onBeforeUpdate(null),this._onCompute(null),this._onGraphic(null)}init(t){}start(){}stop(){}cloneTo(t){}copyComponent(t){return this}_onUpdate(t){t!=null?Ue.bindUpdate(this.transform.view3D,this,t):Ue.unBindUpdate(this.transform.view3D,this)}_onLateUpdate(t){t!=null?Ue.bindLateUpdate(this.transform.view3D,this,t):Ue.unBindLateUpdate(this.transform.view3D,this)}_onBeforeUpdate(t){t!=null?Ue.bindBeforeUpdate(this.transform.view3D,this,t):Ue.unBindBeforeUpdate(this.transform.view3D,this)}_onCompute(t){t!=null?Ue.bindCompute(this.transform.view3D,this,t):Ue.unBindCompute(this.transform.view3D,this)}_onGraphic(t){t!=null?Ue.bindGraphic(this.transform.view3D,this,t):Ue.unBindGraphic(this.transform.view3D,this)}beforeDestroy(t){Ue.removeWaitStart(this.object3D,this)}destroy(t){this.isDestroyed||(this.isDestroyed=!0,this.enable=!1,this.stop(),this._onBeforeUpdate(null),this._onUpdate(null),this._onLateUpdate(null),this.onEnable=null,this.onDisable=null,this.onUpdate=null,this.onLateUpdate=null,this.onBeforeUpdate=null,this.onCompute=null,this.onGraphic=null)}}class ci{constructor(){s(this,"value",0);s(this,"inv_base",0)}static get(t,e){let r=0,a=1/e;for(;t>0;)r+=t%e*a,t/=e,a/=e;return r}getBase(t,e){let r=this.inv_base=1/e;for(;t>0;)this.value+=r*(t%e),t/=e,r*=this.inv_base}next(){let t=1-this.value-1e-7;if(this.inv_base<t)this.value+=this.inv_base;else{let e=this.inv_base,r;do r=e,e*=this.inv_base;while(e>=t);this.value+=r+e-1}}get(){return this.value}}const Zt=class Zt{constructor(t,e){s(this,"origin",new g);s(this,"length",Number.MAX_VALUE);s(this,"_vector",new g);s(this,"_dir",new g);s(this,"_v0",new g);s(this,"_v1",new g);s(this,"_v2",new g);s(this,"_E1",new g);s(this,"_E2",new g);s(this,"_P",new g);s(this,"_T",new g);s(this,"_Q",new g);this.origin.copyFrom(t||new g),this._dir.copyFrom(e||new g),this._dir.normalize()}get direction(){return this._dir}set direction(t){this._dir.copyFrom(t),this._dir.normalize()}clone(){return new Zt(this.origin,this.direction)}intersectBox(t,e){let r=this.direction,a=this.origin,i,o,l,h,c,u;const d=1/r.x,f=1/r.y,A=1/r.z,p=t.min,B=t.max;return i=((d>=0?p.x:B.x)-a.x)*d,o=((d>=0?B.x:p.x)-a.x)*d,l=((f>=0?p.y:B.y)-a.y)*f,h=((f>=0?B.y:p.y)-a.y)*f,i>h||l>o||(l>i&&(i=l),h<o&&(o=h),c=((A>=0?p.z:B.z)-a.z)*A,u=((A>=0?B.z:p.z)-a.z)*A,i>u||c>o)||(c>i&&(i=c),u<o&&(o=u),o<0)?null:(e||(e=new g),this.pointAt(i>=0?i:o,e))}pointAt(t,e){return e||(e=new g),e.copy(this.direction),e.multiplyScalar(t),e.add(this.origin,e),e}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this._dir.copy(t._dir),this.length=t.length,this}setApproxDirection(t){this._dir=t.normalize()}setOrigin(t){this.origin.copyFrom(t)}getOrigin(){return this.origin}getPoint(t){return this._dir.scaleBy(t),this.origin.add(this._dir)}sqrDistToPoint(t){let e=this._dir,r=t.subtract(this.origin),a=Fi(r,e),i=Fi(e,e),o=a/i,l=this.getPoint(o);return yl(t.subtract(l))}applyMatrix(t){this.origin=t.transformPoint(this.origin),this._dir=t.transformVector(this._dir)}pointInTriangle(t,e,r,a){let i=this._v0,o=this._v1,l=this._v2;a.subtract(e,i),r.subtract(e,o),t.subtract(e,l);let h=g.dot(i,i),c=g.dot(i,o),u=g.dot(i,l),d=g.dot(o,o),f=g.dot(o,l),A=1/(h*d-c*c),p=(d*u-c*f)*A,B=(h*f-c*u)*A;return p>=0&&B>=0&&p+B<1}intersectTriangle(t,e,r){let a=r.v1,i=r.v2,o=r.v3;i.subtract(a,this._E1),o.subtract(a,this._E2),e.crossProduct(this._E2,this._P);let l=this._E1.dotProduct(this._P);if(l>0?t.subtract(a,this._T):(a.subtract(t,this._T),l=-l),l<1e-4||(r.u=this._T.dotProduct(this._P),r.u<0||r.u>l)||(this._T.crossProduct(this._E1,this._Q),r.v=e.dotProduct(this._Q),r.v<0||r.u+r.v>l))return null;let h=new g;r.t0=r.t=this._E2.dotProduct(this._Q);let c=1/l;return r.t*=c,r.u*=c,r.v*=c,h.x=t.x+r.t*e.x,h.y=t.y+r.t*e.y,h.z=t.z+r.t*e.z,h}intersectSphere(t,e,r,a){let i=t.subtract(r),o=g.dot(e,e),l=2*g.dot(i,e),h=g.dot(i,i)-a*a,c=l*l-4*o*h,u=g.HELP_3;if(c<0)return null;{let d=(-l-Math.sqrt(c))/(o*2);return d<0?null:(u.x=t.x+d*e.x,u.y=t.y+d*e.y,u.z=t.z+d*e.z,u)}}intersectionSegment(t,e,r){const a=this.origin,i=g.HELP_0,o=g.HELP_1,l=g.HELP_2,h=g.HELP_3;e.subtract(t,i),this._dir.scaleToRef(Zt._rayl,l),a.add(l,o),t.subtract(a,h);var c=g.dot(i,i),u=g.dot(i,l),d=g.dot(l,l),f=g.dot(i,h),A=g.dot(l,h),p=c*d-u*u,B,F,U=p,Q,y,b=p;p<Zt._smallnum?(F=0,U=1,y=A,b=d):(F=u*A-d*f,y=c*A-u*f,F<0?(F=0,y=A,b=d):F>U&&(F=U,y=A+u,b=d)),y<0?(y=0,-f<0?F=0:-f>c?F=U:(F=-f,U=c)):y>b&&(y=b,-f+u<0?F=0:-f+u>c?F=U:(F=-f+u,U=c)),B=Math.abs(F)<Zt._smallnum?0:F/U,Q=Math.abs(y)<Zt._smallnum?0:y/b;const x=g.HELP_4;l.scaleToRef(Q,x);const w=g.HELP_5;i.scaleToRef(B,w),w.add(h,w);const D=g.HELP_6;w.subtract(x,D);var O=Q>0&&Q<=this._dir.length&&D.lengthSquared<r*r;if(O){let L=new g;return L.copyFrom(e.subtract(t)),L.scaleBy(B),L.add(t,L),{out:L,length:w.length}}return{out:null,length:-1}}get_vec(t,e){let r=g.HELP_1;return r.x=t.x-e.x,r.y=t.y-e.y,r.z=t.z-e.z,r}};s(Zt,"_rayl",1e9),s(Zt,"_smallnum",1e-8);let ma=Zt;class La{constructor(t=0,e=0,r=0,a=0){s(this,"x");s(this,"y");s(this,"w");s(this,"h");this.x=t,this.y=e,this.w=r,this.h=a}get width(){return this.w}set width(t){this.w=t}get height(){return this.h}set height(t){this.h=t}static pointInRect(t,e,r,a,i,o){return!(t<r||t>i||e<a||e>o)}clone(){return new La(this.x,this.y,this.w,this.h)}copyFrom(t){this.x=t.x,this.y=t.y,this.w=t.w,this.h=t.h}copyTo(t){t.copyFrom(this)}inner(t,e){return!(t<this.x||t>this.x+this.width||e<this.y||e>this.y+this.height)}equal(t){return!(this.x!=t.x||this.y!=t.y||this.width!=t.width||this.height!=t.height)}equalArea(t,e,r,a){return!(this.x!=t||this.y!=e||this.width!=r||this.height!=a)}equalInnerArea(t){var e=this.x,r=this.y,a=this.x+this.width,i=this.y+this.height,o=t.x,l=t.y,h=t.x+t.width,c=t.y+t.height;return Math.max(e,o)<=Math.min(a,h)&&Math.max(r,l)<=Math.min(i,c)}innerArea(t,e){e=e||new La;var r=this.x,a=this.y,i=this.x+this.width,o=this.y+this.height,l=t.x,h=t.y,c=t.x+t.width,u=t.y+t.height,d=Math.max(a,h),f=Math.min(o,u),A=Math.max(r,l),p=Math.min(c,i);return d>=0&&f>=0&&f-d>=0&&p-A>0?(e.x=A,e.y=d,e.width=p-A,e.height=f-d):(e.x=0,e.y=0,e.width=0,e.height=0),e}setTo(t,e,r,a){this.x=t,this.y=e,this.width=r,this.height=a}}const hr=class hr{constructor(t,e){s(this,"center");s(this,"extents");s(this,"max");s(this,"min");s(this,"size");t||(t=g.ZERO.clone()),e||(e=g.ZERO.clone()),this.setFromCenterAndSize(t,e)}makeEmpty(){return this.setFromMinMax(hr.maxVector3,hr.minVector3),this}setFromMinMax(t,e){return this.init(),e.subtract(t,this.size),t.add(e,this.center).multiplyScalar(.5),this.extents.copyFrom(this.size).multiplyScalar(.5),this.min.copyFrom(t),this.max.copyFrom(e),this}init(){return this.min||(this.min=new g),this.max||(this.max=new g),this.size||(this.size=new g),this.center||(this.center=new g),this.extents||(this.extents=new g),this}setFromCenterAndSize(t,e){return this.size=e,this.center=t,this.init(),this.extents.copy(e).multiplyScalar(.5),this.center.subtract(this.extents,this.min),this.center.add(this.extents,this.max),this}inFrustum(t,e){return e.containsBox(t.bound)}merge(t){t.min.x<this.min.x&&(this.min.x=t.min.x),t.min.y<this.min.y&&(this.min.y=t.min.y),t.min.z<this.min.z&&(this.min.z=t.min.z),t.max.x>this.max.x&&(this.max.x=t.max.x),t.max.y>this.max.y&&(this.max.y=t.max.y),t.max.z>this.max.z&&(this.max.z=t.max.z),this.size.x=t.max.x-t.min.x,this.size.y=t.max.y-t.min.y,this.size.z=t.max.z-t.min.z,this.extents.x=this.size.x*.5,this.extents.y=this.size.y*.5,this.extents.z=this.size.z*.5,this.center.x=this.extents.x+t.min.x,this.center.y=this.extents.y+t.min.y,this.center.z=this.extents.z+t.min.z}intersects(t){return this.min.x<=t.max.x&&this.max.x>=t.min.x&&this.min.y<=t.max.y&&this.max.y>=t.min.y&&this.min.z<=t.max.z&&this.max.z>=t.min.z}intersectsSphere(t){return this.min.x<=t.max.x&&this.max.x>=t.min.x&&this.min.y<=t.max.y&&this.max.y>=t.min.y&&this.min.z<=t.max.z&&this.max.z>=t.min.z}intersectsBox(t){return this.min.x<=t.max.x&&this.max.x>=t.min.x&&this.min.y<=t.max.y&&this.max.y>=t.min.y&&this.min.z<=t.max.z&&this.max.z>=t.min.z}equals(t){return this.center.equals(t.center)&&this.extents.equals(t.extents)}expandByPoint(t){t.x<this.min.x&&(this.min.x=t.x),t.x>this.max.x&&(this.max.x=t.x),t.y<this.min.y&&(this.min.y=t.y),t.y>this.max.y&&(this.max.y=t.y),t.z<this.min.z&&(this.min.z=t.z),t.z>this.max.z&&(this.max.z=t.z)}static fromPoints(t){for(var e=new hr(new g,new g),r=0;r<t.length;r++)e.expandByPoint(t[r]);return e}calculateTransform(t){}clone(){var t=new hr(this.center.clone(),this.size.clone());return t}intersectsRay(t,e){throw new Error("Method not implemented.")}containsPoint(t){return this.min.x<=t.x&&this.max.x>=t.x&&this.min.y<=t.y&&this.max.y>=t.y&&this.min.z<=t.z&&this.max.z>=t.z}containsBox(t){let e=this.min,r=this.max;return e.x<=t.min.x&&e.y<=t.min.y&&e.z<=t.min.z&&r.x>=t.max.x&&r.y>=t.max.y&&r.z>=t.max.z}updateBound(){}destroy(t){this.center=null,this.extents=null,this.min=null,this.max=null,this.size=null}};s(hr,"maxVector3",new g(1,1,1).multiplyScalar(Number.MAX_VALUE*.1)),s(hr,"minVector3",new g(1,1,1).multiplyScalar(-Number.MAX_VALUE*.1));let Pe=hr;class _l{constructor(){s(this,"planes");s(this,"corners");s(this,"boundingBox",new Pe);this.planes=[],this.corners=[];for(var t=0;t<6;t++)this.planes[t]=new g;for(var t=0;t<2*2*2;t++)this.corners[t]=new g}updateBoundBox(t){this.boundingBox.makeEmpty();let e=this.boundingBox.min,r=this.boundingBox.max,a=0;for(let i=0;i<2;++i)for(let o=0;o<2;++o)for(let l=0;l<2;++l){let h=this.corners[a];a++,h.set(2*i-1,2*o-1,l,1),t.transformVector4(h,h),h.div(h.w,h),e.x=Math.min(h.x,e.x),e.y=Math.min(h.y,e.y),e.z=Math.min(h.z,e.z),r.x=Math.max(h.x,r.x),r.y=Math.max(h.y,r.y),r.z=Math.max(h.z,r.z)}return this.boundingBox.setFromMinMax(e,r),this}setFrustumCorners(t){let e=0;for(let r=0;r<2;++r)for(let a=0;a<2;++a)for(let i=0;i<2;++i){let o=this.corners[e];o.set(2*r-1,2*a-1,i,1),t.transformVector4(o,o),o.div(o.w,o),e++}}update(t){var e=t.rawData;this.planes[0].x=e[3]-e[0],this.planes[0].y=e[7]-e[4],this.planes[0].z=e[11]-e[8],this.planes[0].w=e[15]-e[12];var r=Math.sqrt(this.planes[0].x*this.planes[0].x+this.planes[0].y*this.planes[0].y+this.planes[0].z*this.planes[0].z);this.planes[0].x/=r,this.planes[0].y/=r,this.planes[0].z/=r,this.planes[0].w/=r,this.planes[1].x=e[3]+e[0],this.planes[1].y=e[7]+e[4],this.planes[1].z=e[11]+e[8],this.planes[1].w=e[15]+e[12],r=Math.sqrt(this.planes[1].x*this.planes[1].x+this.planes[1].y*this.planes[1].y+this.planes[1].z*this.planes[1].z),this.planes[1].x/=r,this.planes[1].y/=r,this.planes[1].z/=r,this.planes[1].w/=r,this.planes[2].x=e[3]+e[1],this.planes[2].y=e[7]+e[5],this.planes[2].z=e[11]+e[9],this.planes[2].w=e[15]+e[13],r=Math.sqrt(this.planes[2].x*this.planes[2].x+this.planes[2].y*this.planes[2].y+this.planes[2].z*this.planes[2].z),this.planes[2].x/=r,this.planes[2].y/=r,this.planes[2].z/=r,this.planes[2].w/=r,this.planes[3].x=e[3]-e[1],this.planes[3].y=e[7]-e[5],this.planes[3].z=e[11]-e[9],this.planes[3].w=e[15]-e[13],r=Math.sqrt(this.planes[3].x*this.planes[3].x+this.planes[3].y*this.planes[3].y+this.planes[3].z*this.planes[3].z),this.planes[3].x/=r,this.planes[3].y/=r,this.planes[3].z/=r,this.planes[3].w/=r,this.planes[4].x=e[3]-e[2],this.planes[4].y=e[7]-e[6],this.planes[4].z=e[11]-e[10],this.planes[4].w=e[15]-e[14],r=Math.sqrt(this.planes[4].x*this.planes[4].x+this.planes[4].y*this.planes[4].y+this.planes[4].z*this.planes[4].z),this.planes[4].x/=r,this.planes[4].y/=r,this.planes[4].z/=r,this.planes[4].w/=r,this.planes[5].x=e[3]+e[2],this.planes[5].y=e[7]+e[6],this.planes[5].z=e[11]+e[10],this.planes[5].w=e[15]+e[14],r=Math.sqrt(this.planes[5].x*this.planes[5].x+this.planes[5].y*this.planes[5].y+this.planes[5].z*this.planes[5].z),this.planes[5].x/=r,this.planes[5].y/=r,this.planes[5].z/=r,this.planes[5].w/=r}containsPoint(t){for(var e=0;e<6;e++)if(this.planes[e].x*t.x+this.planes[e].y*t.y+this.planes[e].z*t.z+this.planes[e].w<=0)return!1;return!0}containsSphere(t){let e=t.bound,r=0,a,i=t.transform.worldPosition,o=e.radius,l=e.center.x+i.x,h=e.center.y+i.y,c=e.center.z+i.z;for(let u of this.planes){if(a=u.x*l+u.y*h+u.z*c+u.w,a<=-o)return 0;a>o&&r++}return r===6?2:1}containsBox(t){let e=0,r,a=Math.max(t.size.x,t.size.y,t.size.z)*2,i=t.center.x,o=t.center.y,l=t.center.z;for(let h of this.planes){if(r=h.x*i+h.y*o+h.z*l+h.w,r<=-a)return 0;r>a&&e++}return e===6?2:1}containsBox2(t){let e=0,r,a=1.74*Math.max(t.extents.x,t.extents.y,t.extents.z);for(let i of this.planes){if(r=i.x*t.center.x+i.y*t.center.y+i.z*t.center.z+i.w,r<=-a)return 0;r>a&&e++}return e===6?2:1}}var Ne=(n=>(n[n.ortho=0]="ortho",n[n.perspective=1]="perspective",n[n.shadow=2]="shadow",n))(Ne||{});class Tl{constructor(t){s(this,"corners");s(this,"index");this.index=t,this.corners=[];for(let e=0;e<4;e++)this.corners.push(new g)}}class wl{constructor(t,e,r){s(this,"bound");s(this,"twoSections");s(this,"name");s(this,"color");s(this,"shadowCamera");s(this,"index");this.bound=new Pe,this.shadowCamera=Me.createCamera3DObject(null,"csmShadowCamera_"+r),this.shadowCamera.isShadowCamera=!0,this.shadowCamera.orthoOffCenter(100,-100,100,-100,1,1e4),this.twoSections=[t,e],this.index=r,r==0?this.color=new Y(1,0,0,1):r==1?this.color=new Y(0,1,0,1):r==2?this.color=new Y(0,0,1,1):r==3&&(this.color=new Y(0,1,1,1)),this.name="child_"+r}updateBound(){this.bound.makeEmpty();let t=this.bound.min,e=this.bound.max;for(let r of this.twoSections)for(let a of r.corners)t.x=Math.min(a.x,t.x),t.y=Math.min(a.y,t.y),t.z=Math.min(a.z,t.z),e.x=Math.max(a.x,e.x),e.y=Math.max(a.y,e.y),e.z=Math.max(a.z,e.z);return this.bound.setFromMinMax(t,e),this}}class Dl{constructor(t){s(this,"sections");s(this,"children");s(this,"name");this.sections=[];let e=t+1;for(let r=0;r<e;r++)this.sections.push(new Tl(r));this.children=[];for(let r=0;r<t;r++)this.children.push(new wl(this.sections[r],this.sections[r+1],r))}update(t,e,r,a,i){let o=this.sections.length-1;for(let l=0;l<=o;++l){let h=this.sections[l],c=0,u=this.logSplit(r,a,l,this.sections.length);{let f=(u-r)/a;f=f**i.csmScatteringExp,u=(a-r)*f+r}u*=i.csmAreaScale;let d=(t.rawData[10]*u+t.rawData[14])/u;for(let f=0;f<2;++f)for(let A=0;A<2;++A){let p=h.corners[c];c++,p.set(2*f-1,2*A-1,d,1),e.transformVector4(p,p),p.div(p.w,p)}}for(let l of this.children)l.updateBound();return this}squareSplit(t,e,r,a){return(r/(a-1))**4*(e-t)+t}uniformSplit(t,e,r,a){return r/(a-1)*(e-t)+t}logSplit(t,e,r,a){return t*(e/t)**(r/(a-1))}}class Gi extends ut{constructor(){super();s(this,"fov",60);s(this,"name");s(this,"aspect",1);s(this,"near",1);s(this,"far",5e3);s(this,"left",-100);s(this,"right",100);s(this,"top",100);s(this,"bottom",-100);s(this,"frustumSize",0);s(this,"frustumDepth",0);s(this,"viewPort",new La);s(this,"frustum");s(this,"sh",new Float32Array(36));s(this,"isShadowCamera",!1);s(this,"_projectionMatrixInv",new Z);s(this,"_projectionMatrix",new Z);s(this,"_viewMatrix",new Z);s(this,"_viewMatrixInv",new Z);s(this,"_unprojection",new Z);s(this,"_pvMatrixInv",new Z);s(this,"_pvMatrix",new Z);s(this,"_halfw");s(this,"_halfh");s(this,"_ray");s(this,"_enableCSM",!1);s(this,"mainCamera");s(this,"lookTarget");s(this,"type",Ne.perspective);s(this,"csm");s(this,"cubeShadowCameras",[]);s(this,"_haltonSeq");s(this,"_jitterOffsetList");s(this,"_useJitterProjection",!1);s(this,"_jitterFrameIndex",0);s(this,"_sampleIndex",0);s(this,"_jitterX",0);s(this,"_jitterY",0);s(this,"_jitterOffsetX");s(this,"_jitterOffsetY")}get projectionMatrix(){return this._projectionMatrix}get enableCSM(){return this._enableCSM}set enableCSM(e){e&&!this.csm&&(this.csm=new Dl(zt.Cascades)),this._enableCSM=e}init(){super.init(),this._ray=new ma,this.frustum=new _l,this.lookTarget=new g(0,0,0),this.viewPort.x=0,this.viewPort.y=0,this.viewPort.w=R.presentationSize[0],this.viewPort.h=R.presentationSize[1],this.updateProjection(),R.addEventListener(pr.RESIZE,this.updateProjection,this)}updateProjection(){this.aspect=R.aspect,this.type==Ne.perspective?this.perspective(this.fov,this.aspect,this.near,this.far):this.type==Ne.ortho&&(this.frustumSize&&this.frustumDepth?this.ortho(this.frustumSize,this.frustumDepth):this.frustumSize?this.ortho2(this.frustumSize,this.near,this.far):this.orthoOffCenter(this.left,this.right,this.bottom,this.top,this.near,this.far))}getShadowBias(e){let r=2*this.getShadowWorldExtents()/e,a=this.far-this.near;return r/a-C.setting.shadow.shadowBias*.01}getShadowWorldExtents(){let e=C.setting.shadow.shadowBound;return e?e*=.5:e=Math.round(.05*this.frustum.boundingBox.extents.length),e}getCSMShadowBiasScale(e){if(e==this)return 1;let r=this.far-this.near,a=this.csm.children[0].shadowCamera;return(a.far-a.near)/r}getCSMShadowWorldExtents(e){return Math.round(this.csm.children[e].bound.extents.length)}perspective(e,r,a,i){this.fov=e,this.aspect=r,this.near=Math.max(.001,a),this.far=i,this._projectionMatrix.perspective(this.fov,this.aspect,this.near,this.far),this.type=Ne.perspective,this._useJitterProjection&&(this._jitterOffsetX=this._projectionMatrix.get(0,2),this._jitterOffsetY=this._projectionMatrix.get(1,2))}ortho(e,r){this.frustumSize=e,this.frustumDepth=r;let a=e*this.aspect,i=e,o=-a/2,l=a/2,h=i/2,c=-i/2,u=g.distance(this.object3D.localPosition,this.lookTarget),d=u-r,f=u+r;this.orthoOffCenter(o,l,c,h,d,f)}ortho2(e,r,a){this.frustumSize=e;let i=e*this.aspect,o=e,l=-i/2,h=i/2,c=o/2,u=-o/2;this.orthoOffCenter(l,h,u,c,r,a)}orthoOffCenter(e,r,a,i,o,l){this.near=o,this.far=l,this.left=e,this.right=r,this.top=i,this.bottom=a,this.type=Ne.ortho,this._projectionMatrix.orthoOffCenter(this.left,this.right,this.bottom,this.top,this.near,this.far),this._useJitterProjection&&(this._jitterOffsetX=this._projectionMatrix.get(0,2),this._jitterOffsetY=this._projectionMatrix.get(1,2))}get viewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.invert(),this._viewMatrix}get shadowViewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.appendScale(1,1,1),this._viewMatrix.invert(),this._viewMatrix}object3DToScreenRay(e,r=null){return r||(r=new g(0,0,0,1)),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5,At.transformVector(this.viewMatrix,e,r),this.project(r,r),r.x=this._halfw+r.x*this._halfw,r.y=this.viewPort.height-(this._halfh-r.y*this._halfh),r}screenRayToObject3D(e,r=null){r||(r=new g),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5;let a=e.x,i=e.y;return r.x=a/this.viewPort.width-.25,r.y=i/this.viewPort.height-.25,this.unProject(r.x,r.y,e.z,r),r}get pvMatrix(){return Qs(this._projectionMatrix,this.viewMatrix,this._pvMatrix),this._pvMatrix}get pvMatrix2(){Qs(this._projectionMatrix,this.transform.worldMatrix,this._pvMatrix);let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get pvMatrixInv(){let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get vMatrixInv(){let e=this._viewMatrixInv.copyFrom(this.viewMatrix);return e.invert(),e}get cameraToWorld(){let e=Z.helpMatrix;return e.identity(),e.copyFrom(this.projectionMatrixInv),e.multiply(this.vMatrixInv),e}get ndcToView(){let e=Z.helpMatrix;return e.identity(),e.copyFrom(this.projectionMatrixInv),e}get projectionMatrixInv(){return this._projectionMatrixInv.copyFrom(this._projectionMatrix),this._projectionMatrixInv.invert(),this._projectionMatrixInv}unProject(e,r,a,i){return i||(i=new g),i.x=e,i.y=-r,i.z=a,i.w=1,i.x*=a,i.y*=a,this._unprojection.copyFrom(this._projectionMatrix),this._unprojection.invert(),At.transformVector(this._unprojection,i,i),i.z=a,i}project(e,r){return this._projectionMatrix.perspectiveMultiplyPoint3(e,r),r.x=r.x/r.w,r.y=-r.y/r.w,r.z=e.z,r}screenPointToRay(e,r){let a=this._ray,i=Me.UnProjection(e,r,.01,this),o=Me.UnProjection(e,r,1,this);return o=o.subtract(i).normalize(),a.origin.copyFrom(i),a.direction=o,a}screenPointToWorld(e,r,a){return Me.UnProjection(e,r,a,this)}worldToScreenPoint(e,r){return Me.Projection(e,this,r)}lookAt(e,r,a=g.Y_AXIS){this.transform.lookAt(e,r,a),r&&this.lookTarget.copyFrom(r)}onUpdate(){var r;this._useJitterProjection&&this.getJitteredProjectionMatrix(),this.frustum.update(this.pvMatrix),this.frustum.updateBoundBox(this.pvMatrixInv);let e=C.setting.shadow;this.enableCSM&&((r=this.csm)==null||r.update(this._projectionMatrix,this._pvMatrixInv,this.near,this.far,e))}get jitterFrameIndex(){return this._jitterFrameIndex}get jitterX(){return this._jitterX}get jitterY(){return this._jitterY}enableJitterProjection(e){this._jitterFrameIndex=0,this._useJitterProjection=e,this._haltonSeq||(this._haltonSeq=new ci),this._jitterOffsetList=[];for(let r=0;r<32;r++){let a=this.generateRandomOffset();this._jitterOffsetList.push(a)}this._jitterOffsetList.reverse()}generateRandomOffset(){let e=new Ie(ci.get((this._sampleIndex&1023)+1,2)-.5,ci.get((this._sampleIndex&1023)+1,3)-.5);return++this._sampleIndex>=32&&(this._sampleIndex=0),e}getJitteredProjectionMatrix(){let e=C.setting.render.postProcessing.taa,r=e.temporalJitterScale,a=this._jitterFrameIndex%e.jitterSeedCount,i=this._jitterOffsetList[a].x*r,o=this._jitterOffsetList[a].y*r;this._jitterX=i/this.viewPort.width,this._jitterY=o/this.viewPort.height,(!this._jitterOffsetX||!this._jitterOffsetY)&&(this._jitterOffsetX=this._projectionMatrix.get(0,2),this._jitterOffsetY=this._projectionMatrix.get(1,2));let l=this._jitterOffsetX+this._jitterX,h=this._jitterOffsetY+this._jitterY;this._projectionMatrix.set(0,2,l),this._projectionMatrix.set(1,2,h),this._jitterFrameIndex++}getWorldDirection(e){e||(e=new g);const r=this.transform._worldMatrix.rawData;return e.set(-r[8],-r[9],-r[10]).normalize()}}const Ge=class Ge extends ut{constructor(){super();s(this,"eventPositionChange",new pt(Ge.POSITION_ONCHANGE));s(this,"eventRotationChange",new pt(Ge.ROTATION_ONCHANGE));s(this,"eventScaleChange",new pt(Ge.SCALE_ONCHANGE));s(this,"eventLocalChange",new pt(Ge.LOCAL_ONCHANGE));s(this,"onPositionChange");s(this,"onRotationChange");s(this,"onScaleChange");s(this,"_scene3d");s(this,"_parent");s(this,"_localPos");s(this,"_localRot");s(this,"_localRotQuat");s(this,"_localScale");s(this,"_localDetailPos");s(this,"_localDetailRot");s(this,"_localDetailScale");s(this,"index");s(this,"index2");s(this,"_forward",new g);s(this,"_back",new g);s(this,"_right",new g);s(this,"_left",new g);s(this,"_up",new g);s(this,"_down",new g);s(this,"_worldMatrix");s(this,"_targetPos");s(this,"static",!1);s(this,"depthOrder",0);this._worldMatrix=new Z(!0),this.index=this._worldMatrix.index,this.index2=this._worldMatrix.index*he.stateStruct,this._localPos=new g,this._localRot=new g,this._localRotQuat=new X,this._localScale=new g(1,1,1),he.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),he.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),he.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z)}get localChange(){return he.matrixStateBuffer[this.index2]!=0}set localChange(e){he.matrixStateBuffer[this.index2]=e?1:0}get targetPos(){return this._targetPos}set targetPos(e){this._targetPos=e}get parent(){return this._parent}set parent(e){var a;let r=(a=this._parent)==null?void 0:a.object3D;if(this._parent=e,this.depthOrder=e?e.depthOrder+1:0,he.setParent(this.index,e?e.worldMatrix.index:-1,this.depthOrder),this.localChange=!0,this.object3D){let i=e?e.scene3D:null;i?(this._scene3d=i,this.object3D.components.forEach(o=>{Ue.appendWaitStart(o)})):this.object3D.components.forEach(o=>{o.__stop()});for(let o of this.object3D.entityChildren)o.transform.parent=e?this:null;this.object3D.components.forEach(o=>{var l,h;(h=o.onParentChange)==null||h.call(o,r,(l=this._parent)==null?void 0:l.object3D)})}this.notifyLocalChange()}set enable(e){this.transform._scene3d&&e?super.enable=!0:super.enable=!1;for(let r of this.object3D.entityChildren)r.transform.enable=e}get enable(){return this._enable}get scene3D(){return this._scene3d}set scene3D(e){this._scene3d=e}get view3D(){return this._scene3d&&this._scene3d.view?this._scene3d.view:null}awake(){}start(){}stop(){}notifyLocalChange(){if(this.localChange=!0,this.object3D){let e=this.object3D.entityChildren,r=0,a=e.length;for(r=0;r<a;r++)e[r].transform.notifyLocalChange()}this.eventDispatcher.dispatchEvent(this.eventLocalChange)}get up(){return this.worldMatrix.transformVector(g.UP,this._up),this._up}set up(e){this._up.copyFrom(e),At.fromToRotation(g.UP,this._up,X.HELP_0),this.transform.localRotQuat=X.HELP_0}get down(){return this.worldMatrix.transformVector(g.DOWN,this._down),this._down}set down(e){var r;this._down.copyFrom(e),At.fromToRotation(g.DOWN,this._down,X.HELP_0),this.transform.localRotQuat=X.HELP_0,this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get forward(){return this.worldMatrix.transformVector(g.FORWARD,this._forward),this._forward}set forward(e){var r;this._forward.copyFrom(e),At.fromToRotation(g.FORWARD,this._forward,X.HELP_0),this.transform.localRotQuat=X.HELP_0,this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get back(){return this.worldMatrix.transformVector(g.BACK,this._back),this._back}set back(e){this._back.copyFrom(e),At.fromToRotation(g.BACK,this._back,X.HELP_0),this.transform.localRotQuat=X.HELP_0}get left(){return this.worldMatrix.transformVector(g.neg_X_AXIS,this._left),this._left}set left(e){this._left.copyFrom(e),At.fromToRotation(g.LEFT,this._left,X.HELP_0),this.transform.localRotQuat=X.HELP_0}get right(){return this.worldMatrix.transformVector(g.X_AXIS,this._right),this._right}set right(e){var r;this._right.copyFrom(e),At.fromToRotation(g.RIGHT,this._right,X.HELP_0),this.transform.localRotQuat=X.HELP_0,this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotQuat(){return this.localChange&&this.updateWorldMatrix(),this._localRotQuat}set localRotQuat(e){var r;(e.x!=this._localRotQuat.x||e.y!=this._localRotQuat.y||e.z!=this._localRotQuat.z||e.w!=this._localRotQuat.w)&&(this._localRotQuat.copyFrom(e),this._localRotQuat.getEulerAngles(this._localRot),he.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}notifyChange(){var e,r,a;this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),(r=this.onScaleChange)==null||r.call(this),(a=this.onPositionChange)==null||a.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get worldMatrix(){return this.updateWorldMatrix(),this._worldMatrix}updateWorldMatrix(e=!1){(this.localChange||e)&&(this.parent?(Ci(this._localRot,this._localPos,this._localScale,this._worldMatrix),bl(this._worldMatrix,this.parent.worldMatrix,this._worldMatrix)):Ci(this._localRot,this._localPos,this._localScale,this._worldMatrix),this.localChange=!1)}updateChildTransform(){let e=this;if(e.localChange&&e.updateWorldMatrix(),e.object3D.numChildren>0)for(const r of e.object3D.entityChildren)r.transform.updateChildTransform()}lookTarget(e,r=g.UP){this.lookAt(this.transform.worldPosition,e,r)}lookAt(e,r,a=g.UP){this._targetPos||(this._targetPos=new g),this._targetPos.copyFrom(r),this.localPosition=e,Z.helpMatrix.lookAt(e,r,a),Z.helpMatrix.invert();var i=Z.helpMatrix.decompose(Wt.QUATERNION);this.localRotQuat=X.CALCULATION_QUATERNION.copyFrom(i[1])}decomposeFromMatrix(e,r="eulerAngles"){let a=e.decompose(r),i=this.transform;return i.localRotQuat.copyFrom(a[1]),i.localRotQuat=i.localRotQuat,i.localPosition.copyFrom(a[0]),i.localPosition=i.localPosition,i.localScale.copyFrom(a[2]),i.localScale=i.localScale,this}cloneTo(e){e.transform.localPosition=this.localPosition,e.transform.localRotation=this.localRotation,e.transform.localScale=this.localScale}set x(e){var r;this._localPos.x!=e&&(this._localPos.x=e,he.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(r=this.onPositionChange)==null||r.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get x(){return this._localPos.x}set y(e){var r;this._localPos.y!=e&&(this._localPos.y=e,he.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(r=this.onPositionChange)==null||r.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get y(){return this._localPos.y}set z(e){var r;this._localPos.z!=e&&(this._localPos.z=e,he.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(r=this.onPositionChange)==null||r.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get z(){return this._localPos.z}set scaleX(e){var r;this._localScale.x!=e&&(this._localScale.x=e,he.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(r=this.onScaleChange)==null||r.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleX(){return this._localScale.x}set scaleY(e){var r;this._localScale.y!=e&&(this._localScale.y=e,he.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(r=this.onScaleChange)==null||r.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleY(){return this._localScale.y}set scaleZ(e){var r;this._localScale.z!=e&&(this._localScale.z=e,he.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(r=this.onScaleChange)==null||r.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleZ(){return this._localScale.z}set rotationX(e){var r;this._localRot.x!=e&&(this._localRot.x=e,he.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationX(){return this._localRot.x}set rotationY(e){var r;this._localRot.y!=e&&(this._localRot.y=e,he.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationY(){return this._localRot.y}set rotationZ(e){var r;this._localRot.z!=e&&(this._localRot.z=e,he.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationZ(){return this._localRot.z}get worldPosition(){return this.localChange&&this.updateWorldMatrix(),this._worldMatrix.position}set localPosition(e){this.onPositionChange&&(this._localPos.x!=e.x||this._localPos.y!=e.y||this._localPos.z!=e.z)&&this.onPositionChange(this._localPos,e),this._localPos.copyFrom(e),he.setTranslate(this.index,e.x,e.y,e.z),this.notifyLocalChange(),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange)}get localPosition(){return this._localPos}set localRotation(e){this.onRotationChange&&(this._localRot.x!=e.x||this._localRot.y!=e.y||this._localRot.z!=e.z)&&this.onRotationChange(this._localRot,e),he.setRotation(this.index,e.x,e.y,e.z),this._localRot.copyFrom(e),this.notifyLocalChange(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotation(){return this._localRot}set localScale(e){var r;he.setScale(this.index,e.x,e.y,e.z),this._localScale.copyFrom(e),this.notifyLocalChange(),(r=this.onScaleChange)==null||r.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get localScale(){return this._localScale}get localDetailScale(){return this._localDetailScale}set localDetailScale(e){this._localDetailScale=e,he.setContinueScale(this.index,e.x,e.y,e.z)}get localDetailRot(){return this._localDetailRot}set localDetailRot(e){this._localDetailRot=e,he.setContinueRotation(this.index,e.x,e.y,e.z)}get localDetailPos(){return this._localDetailPos}set localDetailPos(e){this._localDetailPos=e,he.setContinueTranslate(this.index,e.x,e.y,e.z)}beforeDestroy(e){this.parent&&this.parent.object3D&&this.parent.object3D.removeChild(this.object3D),super.beforeDestroy(e)}destroy(){super.destroy(),this.scene3D=null,this.eventPositionChange=null,this.eventRotationChange=null,this.eventScaleChange=null,this.onPositionChange=null,this.onRotationChange=null,this.onScaleChange=null,this._scene3d=null,this._parent=null,this._localPos=null,this._localRot=null,this._localRotQuat=null,this._localScale=null,this._forward=null,this._back=null,this._right=null,this._left=null,this._up=null,this._down=null,this.localChange=null,this._targetPos=null}};s(Ge,"LIMIT",1),s(Ge,"COMPONENT_NAME","UUTransform"),s(Ge,"COMPONENT_TYPE","Transform"),s(Ge,"POSITION_ONCHANGE","POSITION_ONCHANGE"),s(Ge,"ROTATION_ONCHANGE","ROTATION_ONCHANGE"),s(Ge,"SCALE_ONCHANGE","SCALE_ONCHANGE"),s(Ge,"PARENT_ONCHANGE","PARENT_ONCHANGE"),s(Ge,"CHILDREN_ONCHANGE","CHILDREN_ONCHANGE"),s(Ge,"ADD_ONCHANGE","ADD_ONCHANGE"),s(Ge,"LOCAL_ONCHANGE","LOCAL_ONCHANGE");let Jt=Ge;const cr=class cr{static genMeshBounds(t,e){let r=this.genMeshMinVector,a=this.genMeshMaxVector,i=this.genMeshVectorList8;e||(e=new Pe(g.ZERO,g.ZERO)),e.setFromMinMax(this.maxVector,this.minVector);let o=t.getComponents(Be);for(const l of o)if(l&&l.geometry){let h=l.object3D.transform.worldMatrix;r.copy(l.geometry.bounds.min),a.copy(l.geometry.bounds.max),i[0].set(r.x,r.y,r.z),i[1].set(r.x,r.y,a.z),i[2].set(r.x,a.y,r.z),i[3].set(r.x,a.y,a.z),i[4].set(a.x,r.y,r.z),i[5].set(a.x,r.y,a.z),i[6].set(a.x,a.y,r.z),i[7].set(a.x,a.y,a.z);for(const c of i)h.transformPoint(c,c),e.expandByPoint(c)}return a.copyFrom(e.max),r.copyFrom(e.min),e.setFromMinMax(r,a),e}static transformBound(t,e,r){let a=this.genMeshMinVector.copyFrom(e.min),i=this.genMeshMaxVector.copyFrom(e.max),o=this.genMeshVectorList8;r||(r=new Pe(g.ZERO,g.ZERO)),r.setFromMinMax(this.maxVector,this.minVector),o[0].set(a.x,a.y,a.z),o[1].set(a.x,a.y,i.z),o[2].set(a.x,i.y,a.z),o[3].set(a.x,i.y,i.z),o[4].set(i.x,a.y,a.z),o[5].set(i.x,a.y,i.z),o[6].set(i.x,i.y,a.z),o[7].set(i.x,i.y,i.z);for(const l of o)t.transformPoint(l,l),r.expandByPoint(l);return i.copyFrom(r.max),a.copyFrom(r.min),r.setFromMinMax(a,i),r}};s(cr,"maxVector",new g(Number.MAX_VALUE*.1,Number.MAX_VALUE*.1,Number.MAX_VALUE*.1)),s(cr,"minVector",cr.maxVector.clone().multiplyScalar(-1)),s(cr,"genMeshMaxVector",g.ZERO.clone()),s(cr,"genMeshMinVector",g.ZERO.clone()),s(cr,"genMeshVectorList8",[new g,new g,new g,new g,new g,new g,new g,new g]);let Oa=cr;class Vl extends ra{constructor(){super();s(this,"name","");s(this,"_instanceID","");s(this,"_numChildren");s(this,"transform");s(this,"renderNode");s(this,"entityChildren");s(this,"components");s(this,"waitDisposeComponents");s(this,"_bound");s(this,"_boundWorld");s(this,"_isBoundChange",!0);s(this,"_dispose",!1);this.entityChildren=[],this.components=new Map,this._instanceID=qs().toString(),this.waitDisposeComponents=[]}get instanceID(){return this._instanceID}get dispose(){return this._dispose}getObjectByName(e){if(e.indexOf("/")>=0){let r=e.split("/"),a=this;for(;r.length>0&&a;){let i=r.shift();if(a=a.getChildByName(i,!1),!a)return null}return a}else return this.getChildByName(e,!1)}get numChildren(){return this._numChildren}addChild(e){if(e==null)throw new Error("child is null!");if(e===this)throw new Error("child is self!");return this.entityChildren.indexOf(e)==-1?(e.removeFromParent(),e.transform.parent=this.transform,this.entityChildren.push(e),this._numChildren=this.entityChildren.length,this.noticeComponents("onAddChild",e),e):null}removeChild(e){if(e===null)return;if(e===this)throw new Error("add child is self!");let r=this.entityChildren.indexOf(e);r!=-1&&(this.entityChildren.splice(r,1),e.transform.parent=null,this._numChildren=this.entityChildren.length,this.noticeComponents("onRemoveChild",e))}removeAllChild(){for(;this.numChildren>0;)this.removeChild(this.entityChildren[0])}removeSelf(){return this.removeFromParent()}removeChildByIndex(e){e>=0&&e<this.entityChildren.length?this.removeChild(this.entityChildren[e]):console.error("remove child by index , index out of range")}hasChild(e){return this.entityChildren.indexOf(e)!=-1}removeFromParent(){let e=this.transform.parent;return e&&e.object3D&&e.object3D.removeChild(this),this}getChildByIndex(e){let r=null;return e<this.entityChildren.length&&(r=this.entityChildren[e]),r}getChildByName(e,r=!0){let a=null;for(const i of this.entityChildren){if(i.name==e)return a=i,a;if(r&&(a=i.getChildByName(e,r),a))return a}return a}update(){}instantiate(){return null}onTransformLocalChange(e){this._isBoundChange=!0}get bound(){return(this._isBoundChange||!this._bound)&&this.updateBound(),this._boundWorld}set bound(e){this._bound=e,this._boundWorld=this._bound.clone(),this._isBoundChange=!0}updateBound(){return this._bound||(this._bound=new Pe,this._boundWorld=this._bound.clone(),this._isBoundChange=!0),this._isBoundChange&&(Oa.transformBound(this.transform.worldMatrix,this._bound,this._boundWorld),this._isBoundChange=!1),this._boundWorld}waitUpdate(){this._dispose?(this.transform.parent&&this.transform.parent.object3D.removeChild(this),this.components.forEach((e,r)=>{e.enable=!1,e.beforeDestroy(),e.destroy()}),this.components.clear()):Ue.waitStartComponent.forEach((e,r)=>{for(;e.length>0;){const a=e.shift();a.__start(),Ue.waitStartComponent.delete(a.object3D)}})}noticeComponents(e,r){var a;for(let i of this.components.values())(a=i[e])==null||a.call(i,r)}destroy(e){this._dispose||(this.components.forEach(r=>{r.beforeDestroy(e)}),this.components.forEach(r=>{r.destroy(e)}),this.components.clear(),this.entityChildren.forEach(r=>{r.destroy(e)}),this.removeAllChild(),this.transform.parent=null,this._dispose=!0,super.destroy())}}var Nl=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let ie=class extends Vl{constructor(){super();s(this,"_isScene3D");s(this,"prefabRef");s(this,"serializeTag");this.transform=this.addComponent(Jt),this.transform.eventDispatcher.addEventListener(Jt.LOCAL_ONCHANGE,this.onTransformLocalChange,this)}get isScene3D(){return this._isScene3D}forChild(t){this.entityChildren.forEach(e=>{t(e),e.forChild(t)})}addComponent(t,e){if(!this.components.has(t)){let r=new t;return r.object3D=this,this.components.set(t,r),r.__init(e),Ue.appendWaitStart(r),r}return this.components.get(t)}getOrAddComponent(t){let e=this.components.get(t);return e||(e=this.addComponent(t)),e}removeComponent(t){if(this.components.has(t)){let e=this.components.get(t);Ue.removeWaitStart(this,e),this.components.delete(t),e.__stop(),e.beforeDestroy(),e.destroy()}}hasComponent(t){return this.components.has(t)}getComponent(t){return this.components.get(t)}getComponentFromParent(t){return this.parent?this.parent.object3D.getComponent(t)||this.parent.object3D.getComponentFromParent(t):null}getComponentsInChild(t){let e=[],r=this.components.get(t);r&&e.push(r);for(let a=0;a<this.entityChildren.length;a++){let i=this.entityChildren[a].getComponentsInChild(t);e.push(...i)}return e}getComponents(t,e,r){e||(e=[]);let a=this.getComponent(t);a&&(a.enable||r)&&e.push(a);for(let i=0,o=this.entityChildren.length;i<o;i++){let l=this.entityChildren[i];l&&l instanceof ie&&l.getComponents(t,e,r)}return e}getComponentsExt(t,e,r){e||(e=[]);let a=this.components.get(t);if(a&&(a.enable||r))e.push(a);else for(const i of this.entityChildren)i instanceof ie&&i.getComponentsExt(t,e,r);return e}getComponentsByProperty(t,e,r=!0,a,i){a||(a=[]);let o;for(const l of this.components.values())l&&(l.enable||i)&&l[t]===e&&(a.push(l),o=!0);if(!(o&&r))for(const l of this.entityChildren)l instanceof ie&&l.getComponentsByProperty(t,e,r,a,i);return a}clone(){return this.instantiate()}instantiate(){let t=new ie;return t.name=this.name,t.serializeTag=this.serializeTag,t.prefabRef=this.prefabRef,this.entityChildren.forEach((e,r)=>{let a=e.instantiate();t.addChild(a)}),this.components.forEach((e,r)=>{e.cloneTo(t)}),t}get localPosition(){return this.transform.localPosition}set localPosition(t){this.transform.localPosition=t}get localRotation(){return this.transform.localRotation}set localRotation(t){this.transform.localRotation=t}get localScale(){return this.transform.localScale}set localScale(t){this.transform.localScale=t}get localQuaternion(){return this.transform.localRotQuat}set localQuaternion(t){this.transform.localRotQuat=t}notifyChange(){this.transform.notifyChange()}get parent(){return this.transform.parent}get parentObject(){return this.transform.parent.object3D}set x(t){this.transform.x=t}get x(){return this.transform.x}set y(t){this.transform.y=t}get y(){return this.transform.y}set z(t){this.transform.z=t}get z(){return this.transform.z}set scaleX(t){this.transform.scaleX=t}get scaleX(){return this.transform.scaleX}set scaleY(t){this.transform.scaleY=t}get scaleY(){return this.transform.scaleY}set scaleZ(t){this.transform.scaleZ=t}get scaleZ(){return this.transform.scaleZ}set rotationX(t){this.transform.rotationX=t}get rotationX(){return this.transform.rotationX}set rotationY(t){this.transform.rotationY=t}get rotationY(){return this.transform.rotationY}set rotationZ(t){this.transform.rotationZ=t}get rotationZ(){return this.transform.rotationZ}fixedUpdate(){}lateUpdate(){}traverse(t){t(this);for(let e=0,r=this.entityChildren.length;e<r;e++){let a=this.entityChildren[e];a instanceof ie&&a.traverse(t)}}destroy(t){this.transform.eventDispatcher.removeEventListener(Jt.LOCAL_ONCHANGE,this.onTransformLocalChange,this),super.destroy(t)}};ie=Nl([Ml],ie);function Ml(n,t){return class extends ie{set active(e){this.transform.enable=e>0}get active(){return this.transform.enable?1:0}get materialColor(){var e,r;return(r=(e=this.getComponent(Be))==null?void 0:e.material)==null?void 0:r.shader.getDefaultColorShader().baseColor}set materialColor(e){var a;let r=(a=this.getComponent(Be))==null?void 0:a.material;r&&(r.shader.getDefaultColorShader().baseColor=e)}notifyMaterialColorChange(e,r){var a,i;(i=(a=this.getComponent(Be).materials)==null?void 0:a[e])==null||i.shader.getDefaultColorShader().uniforms[r].onChange()}}}class Me{static createCamera3DObject(t,e){return this.createCamera3D(null,t,e)}static createCamera3D(t,e,r){return t||(t=new ie),e&&e.addChild(t),r&&(t.name=r),t.getOrAddComponent(Gi)}static UnProjection(t,e,r=1,a){let i=new g(t,e,0),o=1,l=g.HELP_0,h=R.canvas.offsetLeft,c=R.canvas.offsetTop,u=R.canvas.clientWidth,d=R.canvas.clientHeight;l.x=((i.x-h)*o/u-.5)*2,l.y=-((i.y-c)*o/d-.5)*2,l.z=r;let f=new g(0,0,0),A=Z.helpMatrix2;A.copyFrom(a.projectionMatrix),A.invert();let p=Z.helpMatrix;return p.identity(),p.multiply(A),p.multiply(a.transform.worldMatrix),p.perspectiveMultiplyPoint3(l,f),f}static Projection(t,e,r){let a=r||new g(0,0,0),i=Z.helpMatrix;i.copyFrom(e.viewMatrix),i.multiply(e.projectionMatrix),i.perspectiveMultiplyPoint3(t,a);let o=R.canvas.clientWidth/2,l=R.canvas.clientHeight/2;return a.x=a.x*o+o,a.y=l-a.y*l,a}static UnProjection2(t,e,r,a,i){let o=i||new g(0,0,0),l=Z.helpMatrix;l.copyFrom(a.pvMatrixInv);let h=R.canvas.clientWidth/2,c=R.canvas.clientHeight/2;return o.x=(t-h)/h,o.y=(c-e)/c,o.z=r,l.perspectiveMultiplyPoint3(o,o),o}}const Xt=class Xt{static init(){this.directionLightList=new Map,this.pointLightList=new Map,this.shadowLights=new Map}static createBuffer(t){if(!this.shadowLights.has(t.scene)){let e=new Float32Array(16);this.shadowLights.set(t.scene,e)}}static getShadowLightList(t){if(!t.transform.view3D)return null;if(t.lightData.lightType==De.DirectionLight){let e=this.directionLightList.get(t.transform.view3D.scene);return e||(e=[],this.directionLightList.set(t.transform.view3D.scene,e)),e}else if(t.lightData.lightType==De.PointLight){let e=this.pointLightList.get(t.transform.view3D.scene);return e||(e=[],this.pointLightList.set(t.transform.view3D.scene,e)),e}else if(t.lightData.lightType==De.SpotLight){let e=this.pointLightList.get(t.transform.view3D.scene);return e||(e=[],this.pointLightList.set(t.transform.view3D.scene,e)),e}}static getShadowLightWhichScene(t,e){if(e==De.DirectionLight){let r=this.directionLightList.get(t);return r||(r=[],this.directionLightList.set(t,r)),r}else if(e==De.PointLight){let r=this.pointLightList.get(t);return r||(r=[],this.pointLightList.set(t,r)),r}}static getDirectShadowLightWhichScene(t){let e=this.directionLightList.get(t);return e||(e=[],this.directionLightList.set(t,e)),e}static getPointShadowLightWhichScene(t){let e=this.pointLightList.get(t);return e||(e=[],this.pointLightList.set(t,e)),e}static addShadowLight(t){if(!t.transform.view3D)return null;let e=t.transform.view3D.scene;if(t.lightData.lightType==De.DirectionLight){let r=this.directionLightList.get(e);if(r||(r=[],this.directionLightList.set(e,r)),!t.shadowCamera){t.shadowCamera=Me.createCamera3DObject(null,"shadowCamera"),t.shadowCamera.isShadowCamera=!0;let a=-1e3;t.shadowCamera.orthoOffCenter(a,1e3,a,1e3,1,1e4)}return r.indexOf(t)==-1&&r.push(t),r}else if(t.lightData.lightType==De.PointLight||t.lightData.lightType==De.SpotLight){let r=this.pointLightList.get(e);return r&&r.length>=8||(r||(r=[],this.pointLightList.set(e,r)),r.indexOf(t)==-1&&r.push(t)),r}}static removeShadowLight(t){if(t.lightData.castShadowIndex=-1,!t.transform.view3D)return null;if(t.lightData.lightType==De.DirectionLight){let e=this.directionLightList.get(t.transform.view3D.scene);if(e){let r=e.indexOf(t);r!=-1&&e.splice(r,1)}return t.lightData.castShadowIndex=-1,e}else if(t.lightData.lightType==De.PointLight||t.lightData.lightType==De.SpotLight){let e=this.pointLightList.get(t.transform.view3D.scene);if(e){let r=e.indexOf(t);r!=-1&&e.splice(r,1)}return t.lightData.castShadowIndex=-1,e}}static update(t){let e=this.shadowLights.get(t.scene),r=Xt.directionLightList.get(t.scene),a=Xt.pointLightList.get(t.scene),i=0,o=0,l=0,h=0;if(e.fill(0),r){let c=0;for(let u=0;u<r.length;u++){const d=r[u];e[u]=d.lightData.index,d.lightData.castShadowIndex=c++}o=r.length}if(a){l=o;let c=0;for(let u=l;u<a.length;u++){const d=a[u];e[u]=d.lightData.index,d.lightData.castShadowIndex=c++}h=l+a.length}ce.getAllCameraGroup().forEach(c=>{c.dirShadowStart=i,c.dirShadowEnd=o,c.pointShadowStart=l,c.pointShadowEnd=h,c.shadowLights=e})}};s(Xt,"maxNumDirectionShadow",8),s(Xt,"maxNumPointShadow",8),s(Xt,"directionLightList"),s(Xt,"pointLightList"),s(Xt,"shadowLights");let mt=Xt;class Wi{static getGlobalDataBindGroupLayout(){if(this._globalDataBindGroupLayout)return this._globalDataBindGroupLayout;let t=[];return t.push({binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),t.push({binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),this._globalDataBindGroupLayout=R.device.createBindGroupLayout({entries:t}),this._globalDataBindGroupLayout}}s(Wi,"_globalDataBindGroupLayout");class vs{constructor(t){s(this,"uuid");s(this,"usage");s(this,"globalBindGroup");s(this,"uniformGPUBuffer");s(this,"matrixBindGroup");s(this,"uniformByteLength");s(this,"matrixesByteLength");s(this,"shadowMatrixRaw",new Float32Array(8*16));s(this,"csmMatrixRaw",new Float32Array(zt.Cascades*16));s(this,"csmShadowBias",new Float32Array(4));s(this,"shadowLights",new Float32Array(16));s(this,"dirShadowStart",0);s(this,"dirShadowEnd",0);s(this,"pointShadowStart",0);s(this,"pointShadowEnd",0);this.uuid=Ft(),this.usage=GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.uniformGPUBuffer=new aa(8192+9*4*4),this.uniformGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBindGroup=t,this.createBindGroup()}createBindGroup(){this.uniformByteLength=this.uniformGPUBuffer.memory.shareDataBuffer.byteLength,this.matrixesByteLength=Z.block*4*Z.maxCount,this.globalBindGroup=R.device.createBindGroup({label:"global_bindGroupLayout",layout:Wi.getGlobalDataBindGroupLayout(),entries:[{binding:0,resource:{buffer:this.uniformGPUBuffer.buffer,offset:0,size:this.uniformByteLength}},{binding:1,resource:{buffer:this.matrixBindGroup.matrixBufferDst.buffer,offset:0,size:this.matrixesByteLength}}]})}setCamera(t){this.uniformGPUBuffer.setMatrix("_projectionMatrix",t.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",t.viewMatrix),this.uniformGPUBuffer.setMatrix("_cameraWorldMatrix",t.transform.worldMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",t.projectionMatrixInv),this.uniformGPUBuffer.setMatrix("viewToWorld",t.cameraToWorld);let e=mt.getDirectShadowLightWhichScene(t.transform.scene3D);this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0);for(let h=0;h<8;h++)if(h<e.length){let c=e[h].shadowCamera;this.shadowMatrixRaw.set(c.pvMatrix.rawData,h*16)}else this.shadowMatrixRaw.set(t.transform.worldMatrix.rawData,h*16);this.uniformGPUBuffer.setFloat32Array("shadowMatrix",this.shadowMatrixRaw);let r=C.setting.shadow.shadowSize;if(t.enableCSM&&e[0])for(let h=0;h<zt.Cascades;h++){let c=t.csm.children[h].shadowCamera;this.csmMatrixRaw.set(c.pvMatrix.rawData,h*16),this.csmShadowBias[h]=t.getCSMShadowBiasScale(c)}this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setFloat32Array("shadowLights",this.shadowLights);let a=C.setting.reflectionSetting,i=P.instance.getReflections(t.transform.scene3D).length;this.uniformGPUBuffer.setFloat("reflectionProbeSize",a.reflectionProbeSize),this.uniformGPUBuffer.setFloat("reflectionProbeMaxCount",a.reflectionProbeMaxCount),this.uniformGPUBuffer.setFloat("reflectionMapWidth",a.width),this.uniformGPUBuffer.setFloat("reflectionMapHeight",a.height),this.uniformGPUBuffer.setFloat("reflectionCount",i),this.uniformGPUBuffer.setFloat("test2",ve.testObj.testValue2),this.uniformGPUBuffer.setFloat("test3",ve.testObj.testValue3),this.uniformGPUBuffer.setFloat("test4",ve.testObj.testValue4),this.uniformGPUBuffer.setVector3("CameraPos",t.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",Ae.frame),this.uniformGPUBuffer.setFloat32Array("SH",t.sh),this.uniformGPUBuffer.setFloat("time",Ae.time),this.uniformGPUBuffer.setFloat("delta",Ae.delta),this.uniformGPUBuffer.setFloat("shadowBias",t.getShadowBias(r)),this.uniformGPUBuffer.setFloat("skyExposure",C.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",C.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",C.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",C.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",C.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",C.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",C.setting.render.renderState_split);let o=C.inputSystem.mouseX*R.pixelRatio,l=C.inputSystem.mouseY*R.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",o),this.uniformGPUBuffer.setFloat("mouseY",l),this.uniformGPUBuffer.setFloat("windowWidth",R.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",R.windowHeight),this.uniformGPUBuffer.setFloat("near",t.near),this.uniformGPUBuffer.setFloat("far",t.far),this.uniformGPUBuffer.setFloat("pointShadowBias",C.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",r),this.uniformGPUBuffer.setFloat("shadowSoft",C.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",t.enableCSM?1:0),this.uniformGPUBuffer.setFloat("csmMargin",C.setting.shadow.csmMargin),this.uniformGPUBuffer.setInt32("nDirShadowStart",this.dirShadowStart),this.uniformGPUBuffer.setInt32("nDirShadowEnd",this.dirShadowEnd),this.uniformGPUBuffer.setInt32("nPointShadowStart",this.pointShadowStart),this.uniformGPUBuffer.setInt32("nPointShadowEnd",this.pointShadowEnd),this.uniformGPUBuffer.setVector3("cameraForward",t.transform.forward),this.uniformGPUBuffer.setVector4Array("frustumPlanes",t.frustum.planes),this.uniformGPUBuffer.apply()}setShadowCamera(t){this.uniformGPUBuffer.setMatrix("_projectionMatrix",t.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",t.viewMatrix),this.uniformGPUBuffer.setMatrix("_pvMatrix",t.pvMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",t.projectionMatrixInv),this.uniformGPUBuffer.setMatrix("viewToWorld",t.cameraToWorld),this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0),this.uniformGPUBuffer.setFloat32Array("shadowCamera",this.shadowMatrixRaw),this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setFloat32Array("shadowLights",this.shadowLights),this.uniformGPUBuffer.setVector3("CameraPos",t.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",Ae.frame),this.uniformGPUBuffer.setFloat32Array("SH",t.sh),this.uniformGPUBuffer.setFloat("time",Ae.time),this.uniformGPUBuffer.setFloat("delta",Ae.delta),this.uniformGPUBuffer.setFloat("shadowBias",C.setting.shadow.shadowBias),this.uniformGPUBuffer.setFloat("skyExposure",C.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",C.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",C.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",C.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",C.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",C.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",C.setting.render.renderState_split);let e=C.inputSystem.mouseX*R.pixelRatio,r=C.inputSystem.mouseY*R.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",e),this.uniformGPUBuffer.setFloat("mouseY",r),this.uniformGPUBuffer.setFloat("windowWidth",R.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",R.windowHeight),this.uniformGPUBuffer.setFloat("near",t.near),this.uniformGPUBuffer.setFloat("far",t.far),this.uniformGPUBuffer.setFloat("pointShadowBias",C.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",C.setting.shadow.shadowSize),this.uniformGPUBuffer.setFloat("shadowSoft",C.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",0),this.uniformGPUBuffer.setFloat("csmMargin",C.setting.shadow.csmMargin),this.uniformGPUBuffer.setInt32("nDirShadowStart",this.dirShadowStart),this.uniformGPUBuffer.setInt32("nDirShadowEnd",this.dirShadowEnd),this.uniformGPUBuffer.setInt32("nPointShadowStart",this.pointShadowStart),this.uniformGPUBuffer.setInt32("nPointShadowEnd",this.pointShadowEnd),this.uniformGPUBuffer.apply()}setShadowLight(){}}const St=class St{constructor(t,e=0,r=null,a=0){s(this,"entities");s(this,"box");s(this,"subTrees",[]);s(this,"parent");s(this,"level");s(this,"index");s(this,"uuid");s(this,"__rayCastTempVector",new g);this.parent=r,this.box=t.clone(),this.level=a,this.index=e,this.uuid=a+"_"+e,this.entities=new Map}tryInsertEntity(t){let e=t.renderer.object3D.bound;if(this.level==0||this.box.containsBox(e)){this.subTrees.length==0&&this.level<St.maxSplitLevel&&this.splitTree();let r;if(this.subTrees.length>0){for(let a of this.subTrees)if(a.tryInsertEntity(t)){r=!0;break}}return r||t.enterNode(this),!0}return!1}splitTree(){if(this.subTrees.length==0){const t=St._v1,e=this.box.extents.clone();let r=this.level+1,a=0;for(let i=0;i<2;i++)for(let o=0;o<2;o++)for(let l=0;l<2;l++){const h=new Pe;this.box.min.add(t.set(i,o,l).multiply(e),h.min),h.min.add(e,h.max),h.setFromMinMax(h.min,h.max);let c=new St(h,a++,this,r);this.subTrees.push(c)}}}rayCasts(t,e){if(this.level==0||t.intersectBox(this.box,this.__rayCastTempVector)){this.entities.size>0&&e.push(...this.entities.values());for(let r of this.subTrees)r.rayCasts(t,e);return!0}return!1}frustumCasts(t,e){if(this.level==0||t.containsBox2(this.box)>0){if(this.entities.size>0)for(const r of this.entities.values())(this.level>St.autoSplitLevel||t.containsBox2(r.renderer.object3D.bound)>0)&&e.push(r);for(let r of this.subTrees)r.frustumCasts(t,e);return!0}return!1}getRenderNode(t,e){if(this.level==0||t.containsBox2(this.box)>0){if(this.entities.size>0)for(const r of this.entities.values())(this.level>St.autoSplitLevel||t.containsBox2(r.renderer.object3D.bound)>0)&&(r.renderer.renderOrder<3e3?e.opaqueList.push(r.renderer):r.renderer.renderOrder>=3e3&&e.transparentList.push(r.renderer));for(let r of this.subTrees)r.getRenderNode(t,e);return!0}return!1}boxCasts(t,e){if(t.intersectsBox(this.box)){this.entities.size>0&&e.push(...this.entities.values());for(let r of this.subTrees)r.boxCasts(t,e);return!0}return!1}clean(){for(let t of this.entities.values())t.leaveNode();return this.entities.clear(),this}};s(St,"_v1",new g),s(St,"_v2",new g),s(St,"maxSplitLevel",6),s(St,"autoSplitLevel",3);let Qi=St;class kl{constructor(){s(this,"_pool",[]);s(this,"_worldPosition",new g);s(this,"_viewPosition",new g);s(this,"_zSortList",[])}pop(){return this._pool.pop()||{}}recycle(){for(let t of this._zSortList)t.z=0,t.userData=null,t.obj3d=null,this._pool.push(t);this._zSortList.length=0}sort(t,e,r,a){this._zSortList=[];for(let i of e){let o=this.pop();o.userData=i,o.obj3d=r(i),o.z=this.worldToCameraDepth(o.obj3d,t),this._zSortList.push(o)}this._zSortList.sort((i,o)=>i.z-o.z>0?1:-1),a||(a=[]);for(let i of this._zSortList)a.push(i.userData);return this.recycle(),a}worldToCameraDepth(t,e){e||(e=t.transform.view3D.camera);let r=0;return e&&(this._worldPosition.copyFrom(t.transform.worldPosition),e.worldToScreenPoint(this._worldPosition,this._viewPosition),r=this._viewPosition.z),r}}let Pl=new kl;var Ga=(n=>(n[n.None=2]="None",n[n.StaticBatch=4]="StaticBatch",n[n.DynamicBatch=8]="DynamicBatch",n[n.Hiden=16]="Hiden",n))(Ga||{});class Ss{static addMask(t,e){return t|e}static removeMask(t,e){return t&~e}static hasMask(t,e){return(t&e)!=0}}class Ll{constructor(){s(this,"opaqueList",[]);s(this,"transparentList",[]);s(this,"sky")}clean(){this.opaqueList.length=0,this.transparentList.length=0}}class Ol{constructor(){s(this,"renderGroup");this.renderGroup=new Map}collect_add(t){let e="",r="";e+=t.geometry.instanceID;for(let i=0;i<t.materials.length;i++){const o=t.materials[i];r+=o.shader.getDefaultColorShader().shaderVariant}let a=e+r;this.renderGroup.has(a)||this.renderGroup.set(a,{bundleMap:new Map,key:a,renderNodes:[]}),this.renderGroup.get(a).renderNodes.indexOf(t)==-1&&this.renderGroup.get(a).renderNodes.push(t)}}class Gl{constructor(){s(this,"renderShaderUpdateList",new Map);s(this,"renderNodeList",new Map)}collect_add(t){let e=t.transform.view3D;e&&t.materials&&t.materials.forEach(r=>{let a=this.renderShaderUpdateList.get(e);a||(a=new Map,this.renderShaderUpdateList.set(e,a));let i=this.renderNodeList.get(e);i||(i=new Map,this.renderNodeList.set(e,i)),i.set(t.instanceID,t);let o=r.getAllPass();for(let l=0;l<o.length;l++){const h=o[l];let c=`${t.geometry.instanceID+h.instanceID}`,u=a.get(c);u||(u=new Map,a.set(c,u)),u.set(t.instanceID,t)}})}collect_remove(t){let e=t.transform.view3D;if(e&&t.materials){let r=this.renderShaderUpdateList.get(e);r&&t.materials.forEach(a=>{let i=a.getAllPass();for(let o=0;o<i.length;o++){const l=i[o];let h=`${t.geometry.instanceID+l.instanceID}`;r.delete(h)}})}}}const ei=class ei{constructor(){s(this,"_sceneLights");s(this,"_sceneGIProbes");s(this,"_op_RenderNodes");s(this,"_tr_RenderNodes");s(this,"_octreeRenderNodes");s(this,"_reflections");s(this,"_graphics");s(this,"_op_renderGroup");s(this,"_tr_renderGroup");s(this,"_renderShaderCollect");s(this,"state",{giLightingChange:!0});s(this,"sky");s(this,"_collectInfo");s(this,"rendererOctree");this._sceneLights=new Map,this._sceneGIProbes=new Map,this._op_RenderNodes=new Map,this._tr_RenderNodes=new Map,this._reflections=new Map,this._graphics=[],this._op_renderGroup=new Map,this._tr_renderGroup=new Map,this._collectInfo=new Ll,this._renderShaderCollect=new Gl,this._octreeRenderNodes=new Map}static get instance(){return this._instance||(this._instance=new ei),this._instance}getPashList(t,e){if(e.renderOrder<3e3)return this._op_RenderNodes.get(t);if(e.renderOrder>=3e3)return this._tr_RenderNodes.get(t)}sortRenderNode(t,e){for(let r=t.length-1;r>0;r--)if(t[r].renderOrder<e.renderOrder){t.push(e);return}t.push(e)}addRenderNode(t,e){if(!t)return;let r=e.renderOrder>=3e3;if(e.hasMask(de.Sky))this.sky=e;else if(e.hasMask(de.Reflection)){this.removeRenderNode(t,e);let a=this._reflections.get(t);a||(a=[],this._reflections.set(t,a),a.push(e)),a.includes(e)||a.push(e)}else if(e.hasMask(de.Graphic3D))this._graphics.indexOf(e)==-1&&this._graphics.push(e);else if(Ss.hasMask(e.renderLayer,Ga.None)){this.removeRenderNode(t,e);let a=r?this._tr_RenderNodes:this._op_RenderNodes;a.has(t)||a.set(t,[]),a.get(t).push(e),C.setting.occlusionQuery.octree&&e.attachSceneOctree(this.getOctree(t));let i=this.getPashList(t,e);i.indexOf(e)==-1&&this.sortRenderNode(i,e)}else{this.removeRenderNode(t,e);let a=r?this._tr_renderGroup:this._op_renderGroup;a.has(t)||a.set(t,new Ol),a.get(t).collect_add(e)}e.object3D.renderNode=e,this._renderShaderCollect.collect_add(e)}getOctree(t){let e,r=C.setting.occlusionQuery.octree;if(r&&(e=this._octreeRenderNodes.get(t),!e)){let a=new g(r.x,r.y,r.z),i=new g(r.width,r.height,r.depth),o=new Pe(a,i);e=new Qi(o),this._octreeRenderNodes.set(t,e)}return e}removeRenderNode(t,e){if(e.detachSceneOctree(),e.hasMask(de.Sky))this.sky=null;else if(e.hasMask(de.Reflection)){let r=this._reflections.get(t);if(r){let a=r.indexOf(e);a!=-1&&r.splice(a,1)}}else if(Ss.hasMask(e.renderLayer,Ga.None)){let r=this.getPashList(t,e);if(r){let a=r.indexOf(e);a!=-1&&r.splice(a,1)}}this._renderShaderCollect.collect_remove(e)}addLight(t,e){if(!this._sceneLights.has(t))this._sceneLights.set(t,[e]);else{let r=this._sceneLights.get(t);if(r.length>=C.setting.light.maxLight){console.warn("Alreay meet maxmium light number:",C.setting.light.maxLight);return}r.indexOf(e)!=-1||r.push(e)}}removeLight(t,e){if(this._sceneLights.has(t)){let r=this._sceneLights.get(t),a=r.indexOf(e);a!=-1&&r.splice(a,1)}}getLights(t){return this._sceneLights.get(t)||[]}addGIProbe(t,e){this._sceneGIProbes.has(t)?this._sceneGIProbes.get(t).push(e):this._sceneGIProbes.set(t,[e])}removeGIProbe(t,e){if(this._sceneGIProbes.has(t)){let r=this._sceneGIProbes.get(t),a=r.indexOf(e);a!=-1&&r.splice(a,1)}}getProbes(t){return this._sceneGIProbes.get(t)||[]}getReflections(t){return this._reflections.get(t)||[]}autoSortRenderNodes(t){let e=this._tr_RenderNodes.get(t);if(!e)return;let r=!1;for(const a of e)if(a.isRenderOrderChange||a.needSortOnCameraZ){r=!0;break}if(r){for(const a of e){let i=a.renderOrder;if(a.needSortOnCameraZ){let o=Pl.worldToCameraDepth(a.object3D);o=1-Math.max(0,Math.min(1,o)),i+=o}a.__renderOrder=i,a.isRenderOrderChange=!1}e.sort((a,i)=>a.__renderOrder>i.__renderOrder?1:-1)}return this}getRenderNodes(t,e){if(this.autoSortRenderNodes(t),this._collectInfo.clean(),this._collectInfo.sky=this.sky,C.setting.occlusionQuery.octree)this.rendererOctree=this.getOctree(t),this.rendererOctree.getRenderNode(e.frustum,this._collectInfo);else{let r=this._op_RenderNodes.get(t);r&&(this._collectInfo.opaqueList=r.concat());let a=this._tr_RenderNodes.get(t);a&&(this._collectInfo.transparentList=a.concat())}return this._collectInfo}getOpRenderGroup(t){return this._op_renderGroup.get(t)}getTrRenderGroup(t){return this._tr_renderGroup.get(t)}getGraphicList(){return this._graphics}getRenderShaderCollect(t){return this._renderShaderCollect.renderShaderUpdateList.get(t)}};s(ei,"_instance");let P=ei;class Wl{constructor(){s(this,"setting");s(this,"probesBufferData");s(this,"probesBuffer");s(this,"isVolumeFrameChange",!0);s(this,"randomOrientation");s(this,"startPosition",new g);s(this,"isVolumeChange",!0);s(this,"irradianceVolumeBuffer");s(this,"directionDistance",20);s(this,"randomSeedCount",3);s(this,"useRandomIndex",0);s(this,"centerDirection",new g(0,0,this.directionDistance).normalize(1));s(this,"arroundPositions",[]);s(this,"debugX",0);s(this,"debugY",0);s(this,"debugZ",0)}updateOrientation(){return this.useRandomIndex++,this.useRandomIndex>=this.arroundPositions.length&&(this.useRandomIndex=0),Z.fromToRotation(this.centerDirection,this.arroundPositions[this.useRandomIndex],this.randomOrientation),this.randomOrientation}init(t){this.setting=t,this.randomOrientation=new Z(!1),this.randomOrientation.identity(),this.irradianceVolumeBuffer=new aa(80),this.createFramesBuffer(),this.arroundPositions.push(this.centerDirection.clone());for(let e=0;e<this.randomSeedCount;e++){let r=Math.PI*2*e/this.randomSeedCount,a=new g(Math.sin(r),Math.cos(r),this.directionDistance).normalize(1);this.arroundPositions.push(a)}}setVolumeDataChange(){this.isVolumeChange=!0}updateProbes(t){let e=this.probesBufferData;for(let r of t){let a=r.index*4;e[a+3]=r.drawCallFrame}}createFramesBuffer(){if(!this.probesBufferData){let t=this.setting.probeXCount*this.setting.probeYCount*this.setting.probeZCount;this.probesBufferData=new Float32Array(t*4),this.probesBufferData.fill(-1),this.probesBuffer=new Xe(t*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}}uploadBuffer(){this.isVolumeChange&&(this.fillIrradianceData(),this.isVolumeChange=!1,this.isVolumeFrameChange=!0),this.probesBuffer.setFloat32Array("uniformFramesBuffer",this.probesBufferData)}calcPosition(t,e,r,a){let i=this.setting,o=this.setting.probeSpace;return a=a||new g,a.x=t*o-o*(i.probeXCount-1)*.5+i.offsetX,a.y=e*o-o*(i.probeYCount-1)*.5+i.offsetY,a.z=r*o-o*(i.probeZCount-1)*.5+i.offsetZ,a}fillIrradianceData(){let t=this.setting,e=this.calcPosition(0,0,0,this.startPosition);this.irradianceVolumeBuffer.setFloat("orientationIndex",this.randomOrientation.index),this.irradianceVolumeBuffer.setFloat("hysteresis",t.hysteresis),this.irradianceVolumeBuffer.setFloat("OctRTSideSize",t.octRTSideSize),this.irradianceVolumeBuffer.setFloat("OctRTMaxSize",t.octRTMaxSize),this.irradianceVolumeBuffer.setFloat("startX",e.x),this.irradianceVolumeBuffer.setFloat("startY",e.y),this.irradianceVolumeBuffer.setFloat("startZ",e.z),this.irradianceVolumeBuffer.setFloat("ProbeSpace",t.probeSpace),this.irradianceVolumeBuffer.setFloat("probeXCount",t.probeXCount),this.irradianceVolumeBuffer.setFloat("probeYCount",t.probeYCount),this.irradianceVolumeBuffer.setFloat("probeZCount",t.probeZCount),this.irradianceVolumeBuffer.setFloat("maxDistance",t.probeSpace*1.732),this.irradianceVolumeBuffer.setFloat("depthSharpness",t.depthSharpness),this.irradianceVolumeBuffer.setFloat("ProbeSourceTextureSize",t.probeSourceTextureSize),this.irradianceVolumeBuffer.setFloat("ProbeSize",t.probeSize),this.irradianceVolumeBuffer.setFloat("bounceIntensity",t.bounceIntensity),this.irradianceVolumeBuffer.setFloat("probeRoughness",t.probeRoughness),this.irradianceVolumeBuffer.setFloat("normalBias",t.normalBias),this.irradianceVolumeBuffer.setFloat("irradianceChebyshevBias",t.irradianceChebyshevBias),this.irradianceVolumeBuffer.setFloat("rayNumber",t.rayNumber),this.irradianceVolumeBuffer.setFloat("irradianceDistanceBias",t.irradianceDistanceBias),this.irradianceVolumeBuffer.setFloat("indirectIntensity",t.indirectIntensity),this.irradianceVolumeBuffer.setFloat("ddgiGamma",t.ddgiGamma),this.irradianceVolumeBuffer.setFloat("lerpHysteresis",t.lerpHysteresis),this.irradianceVolumeBuffer.setFloat("debugX",this.debugX),this.irradianceVolumeBuffer.setFloat("debugY",this.debugY),this.irradianceVolumeBuffer.setFloat("debugZ",this.debugZ),this.irradianceVolumeBuffer.apply()}}class Jl{constructor(){s(this,"storageGPUBuffer");s(this,"irradianceVolume");s(this,"_lightList",[]);this.storageGPUBuffer=new Xe(Pa.lightSize*C.setting.light.maxLight,GPUBufferUsage.COPY_SRC),this.irradianceVolume=new Wl,this.irradianceVolume.init(C.setting.gi);for(let t=0;t<C.setting.light.maxLight;t++){let e=this.storageGPUBuffer.memory.allocation_node(Pa.lightSize*4);this._lightList.push(e)}this.storageGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(t){this.storageGPUBuffer.clean();let e=P.instance.getLights(t.scene);for(let r=0;r<e.length;r++){const a=e[r].lightData;a.index=r,this.writeLightBytes(a,this._lightList[r])}this.storageGPUBuffer.apply()}writeLightBytes(t,e){e.offset=0,e.writeFloat(t.index),e.writeInt32(t.lightType),e.writeFloat(t.radius),e.writeFloat(t.linear),e.writeVector3(t.lightPosition),e.writeFloat(t.lightMatrixIndex),e.writeVector3(t.direction),e.writeFloat(t.quadratic),e.writeRGBColor(t.lightColor),e.writeFloat(t.intensity),e.writeFloat(t.innerAngle),e.writeFloat(t.outerAngle),e.writeFloat(t.range),e.writeInt32(t.castShadowIndex),e.writeVector3(t.lightTangent),e.writeFloat(t.iesIndex)}}class zl{constructor(){s(this,"storageGPUBuffer");s(this,"reflectionMap");s(this,"sourceReflectionMap");s(this,"count");this.storageGPUBuffer=new Xe(6*128)}update(t){this.storageGPUBuffer.clean();let e=P.instance.getReflections(t.scene);for(let r=0;r<e.length;r++){const a=e[r];a.gid=r,this.storageGPUBuffer.setFloat("gid",a.gid),this.storageGPUBuffer.setVector3("worldPosition",a.transform.worldPosition),this.storageGPUBuffer.setFloat("radius",a.radius),this.storageGPUBuffer.setVector3("bound",a.transform.worldPosition)}this.count=e.length,this.storageGPUBuffer.apply()}}class Zl extends kr{constructor(e,r=0,a){super();s(this,"size");this.bufferType=ir.StorageGPUBuffer,this.size=e,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|r,e,a,"MatrixGPUBuffer")}writeBufferByHeap(e,r){let a;e instanceof Float64Array?a=new Float32Array(e):a=e;let i=R.device;if(a.length>0){let o=null;for(;this.mapAsyncReady.length&&(o=this.mapAsyncReady.shift(),o.usedSize!=a.byteLength);)o.destroy(),this.mapAsyncBuffersOutstanding--,o=null;o||(o=i.createBuffer({size:a.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),o.usedSize=a.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let l=new Float32Array(a.buffer,a.byteOffset,r);new Float32Array(o.getMappedRange(0,r*4)).set(l),o.unmap();const h=i.createCommandEncoder();h.copyBufferToBuffer(o,0,this.buffer,0,r*4),i.queue.submit([h.finish()]),o.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(o))}}}class Xl{constructor(){s(this,"uuid");s(this,"index");s(this,"usage");s(this,"groupBufferSize");s(this,"matrixBufferDst");this.uuid=Ft(),this.groupBufferSize=0,this.usage=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.cacheWorldMatrix()}cacheWorldMatrix(){this.groupBufferSize=Z.maxCount*Z.blockBytes,this.matrixBufferDst=new Zl(this.groupBufferSize/4),this.matrixBufferDst.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBufferDst.buffer.label=this.groupBufferSize.toString()}writeBuffer(t){const e=Z.dynamicMatrixBytes;this.matrixBufferDst.mapAsyncWrite(e,t)}}class ce{static init(){this.modelMatrixBindGroup=new Xl,this._cameraBindGroups=new Map,this._lightEntriesMap=new Map,this._reflectionEntriesMap=new Map}static getAllCameraGroup(){return this._cameraBindGroups}static getCameraGroup(t){let e=this._cameraBindGroups.get(t);return e||(e=new vs(this.modelMatrixBindGroup),this._cameraBindGroups.set(t,e)),t.isShadowCamera?e.setShadowCamera(t):e.setCamera(t),e}static updateCameraGroup(t){let e=this._cameraBindGroups.get(t);e||(e=new vs(this.modelMatrixBindGroup),this._cameraBindGroups.set(t,e)),t.isShadowCamera?e.setShadowCamera(t):e.setCamera(t)}static getLightEntries(t){t||console.log("getLightEntries scene is null");let e=this._lightEntriesMap.get(t);return e||(e=new Jl,this._lightEntriesMap.set(t,e)),this._lightEntriesMap.get(t)}static getReflectionEntries(t){t||console.log("getLightEntries scene is null");let e=this._reflectionEntriesMap.get(t);return e||(e=new zl,this._reflectionEntriesMap.set(t,e)),this._reflectionEntriesMap.get(t)}}s(ce,"_cameraBindGroups"),s(ce,"_lightEntriesMap"),s(ce,"_reflectionEntriesMap"),s(ce,"modelMatrixBindGroup");const We=class We{static bindPipeline(t,e){if(We.lastShader!=e)We.lastShader=e;else return!1;We.lastPipeline!=e.pipeline&&(We.lastPipeline=e.pipeline,t.setPipeline(e.pipeline));for(let r=1;r<e.bindGroups.length;r++){const a=e.bindGroups[r];a&&t.setBindGroup(r,a)}return!0}static bindCamera(t,e){let r=ce.getCameraGroup(e);t.setBindGroup(0,r.globalBindGroup)}static bindGeometryBuffer(t,e){if(this.lastGeometry!=e){this.lastGeometry=e,e.indicesBuffer&&t.setIndexBuffer(e.indicesBuffer.indicesGPUBuffer.buffer,e.indicesBuffer.indicesFormat);let r=e.vertexBuffer.vertexGPUBuffer,a=e.vertexBuffer.vertexBufferLayouts;for(let i=0;i<a.length;i++){const o=a[i];t.setVertexBuffer(i,r.buffer,o.offset,o.size)}}}static cleanCache(){this.lastGeometry=null,this.lastPipeline=null,this.lastShader=null}static createPipeline(t){return ve.countStart("GPUContext","pipeline"),R.device.createRenderPipeline(t)}static beginCommandEncoder(){return ve.countStart("GPUContext","beginCommandEncoder"),this.LastCommand&&R.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=R.device.createCommandEncoder(),this.LastCommand}static endCommandEncoder(t){this.LastCommand==t&&(R.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=null,ve.countStart("GPUContext","endCommandEncoder"))}static recordBundleEncoder(t){return R.device.createRenderBundleEncoder(t)}static beginRenderPass(t,e){if(this.cleanCache(),this.renderPassCount++,this.lastRenderPassState=e,e.depthTexture){let r=e.renderPassDescriptor.depthStencilAttachment;r.view=e.depthTexture.getGPUView()}if(e.renderTargets&&e.renderTargets.length>0){for(let r=0;r<e.renderTargets.length;++r){const a=e.renderTargets[r];let i=e.renderPassDescriptor.colorAttachments[r];e.multisample>0&&e.renderTargets.length==1?(i.view=e.multiTexture.createView(),i.resolveTarget=a.getGPUView()):i.view=a.getGPUTexture().createView()}return t.beginRenderPass(e.renderPassDescriptor)}else{let r=e.renderPassDescriptor.colorAttachments[0];return r&&(e.multisample>0?(r.view=e.multiTexture.createView(),r.resolveTarget=R.context.getCurrentTexture().createView()):r.view=R.context.getCurrentTexture().createView()),t.beginRenderPass(e.renderPassDescriptor)}}static drawIndexed(t,e,r,a,i,o){t.drawIndexed(e,r,a,i,o),this.drawCount++}static draw(t,e,r,a,i){t.draw(e,r,a,i),this.drawCount++}static endPass(t){t.insertDebugMarker("end"),t.end()}static computeCommand(t,e){let r=t.beginComputePass();for(let a=0;a<e.length;a++)e[a].compute(r);r.end()}static copyTexture(t,e,r){t.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{width:r.width,height:r.height,depthOrArrayLayers:1})}};s(We,"lastGeometry"),s(We,"lastPipeline"),s(We,"lastShader"),s(We,"drawCount",0),s(We,"renderPassCount",0),s(We,"geometryCount",0),s(We,"pipelineCount",0),s(We,"matrixCount",0),s(We,"lastRenderPassState"),s(We,"LastCommand");let S=We;class Rs{constructor(){s(this,"source");s(this,"input");s(this,"output")}reset(t){this.input&&this.input.destroy(),this.output&&this.output.destroy(),this.input=this.output=null,this.source=t}apply(t){if(this.source){if(!this.input){let e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this.input=new Xe(this.source.length,e,this.source),this.input.apply()}if(!this.output){let e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC;this.output=new Xe(t*3,e),this.output.apply()}}}}class Yl{constructor(){s(this,"enable");s(this,"morphTargetsRelative");s(this,"MaxMorphTargetCount",64);s(this,"_computeConfigArray");s(this,"_computeConfigBuffer");s(this,"_morphInfluenceArray");s(this,"_morphInfluenceBuffer");s(this,"_positionAttrDataGroup");s(this,"_normalAttrDataGroup");s(this,"_isInfluenceDirty");s(this,"_morphTargetCount");s(this,"_totalVertexCount");s(this,"_computeShader");s(this,"_computeShaders");s(this,"_computeWorkGroupXY",1);s(this,"_collectMorphTargetData");s(this,"_blendTarget");this._isInfluenceDirty=!0,this.generateGPUBuffer(),this._positionAttrDataGroup=new Rs,this._normalAttrDataGroup=new Rs}initMorphTarget(t){this._collectMorphTargetData=this.collectMorphTargetList(t),this._computeShader&&this._computeShader.destroy();let e=ct.CsMain;this._computeShader=new bt(e),this._collectMorphTargetData.mergedNormal?this._computeShader.setDefine("USE_MORPHNORMALS",!0):this._computeShader.deleteDefine("USE_MORPHNORMALS"),this._computeShaders=[this._computeShader],this._isInfluenceDirty=!0,this._morphTargetCount=this._collectMorphTargetData.mtCount,this._totalVertexCount=this._collectMorphTargetData.vCount,this._morphInfluenceArray.fill(0),this._computeWorkGroupXY=this.calcWorkGroup(this._totalVertexCount),this._positionAttrDataGroup.reset(this._collectMorphTargetData.mergedPos),this._normalAttrDataGroup.reset(this._collectMorphTargetData.mergedNormal)}applyRenderShader(t){this.uploadMorphTargetBuffer(),this.uploadConfigGBuffer(),t.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),t.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&t.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)}computeMorphTarget(t){this.uploadConfigGBuffer(),this.uploadMorphTargetBuffer(),this._computeShader.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),this._computeShader.setStorageBuffer("morphTargetInfluence",this._morphInfluenceBuffer),this._computeShader.setStorageBuffer("morphTargetPositions",this._positionAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&(this._computeShader.setStorageBuffer("morphTargetNormals",this._normalAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)),this._computeShader.workerSizeX=this._computeWorkGroupXY,this._computeShader.workerSizeY=this._computeWorkGroupXY,this._computeShader.workerSizeZ=1,S.computeCommand(t,this._computeShaders)}updateInfluence(t,e){this._isInfluenceDirty=!0,this._morphInfluenceArray[t]=e}get blendShape(){return this._blendTarget}collectMorphTargetList(t){let e=this.collectAttribute("a_morphPositions_",t),r=e.length,a=e[0].data.length/3;if(this._blendTarget={},t.blendShapeData)for(let h=0;h<t.blendShapeData.shapeIndexs.length;h++){let c=t.blendShapeData.shapeIndexs[h],u=t.blendShapeData.shapeNames[h].split("."),d=u[u.length-1];this._blendTarget[d]=f=>this.updateInfluence(c,f)}let i=new Float32Array(a*r*3);{let h=0;for(let c=0;c<r;c++){let u=e[c];i.set(u.data,h),h+=u.data.length}}let o=this.collectAttribute("a_morphNormals_",t),l;if(o&&o.length>0){let h=0;l=new Float32Array(a*r*3);for(let c=0;c<r;c++){let u=o[c];l.set(u.data,h),h+=u.data.length}}return{mtCount:r,vCount:a,mergedPos:i,mergedNormal:l}}collectAttribute(t,e){let r=[];for(let a=0;a<this.MaxMorphTargetCount;a++){let i=t+a,o=e.getAttribute(i);if(o)r[a]=o;else break}return r}uploadConfigGBuffer(){if(this._isInfluenceDirty){let t=0;for(let e=0;e<this._morphTargetCount;e++)t+=this._morphInfluenceArray[e];this._morphInfluenceBuffer.setFloat32Array("data",this._morphInfluenceArray),this._morphInfluenceBuffer.apply(),this._computeConfigArray[0]=this.morphTargetsRelative?1:1-t,this._computeConfigArray[1]=this._morphTargetCount,this._computeConfigArray[2]=this._totalVertexCount,this._computeConfigArray[3]=this._computeWorkGroupXY,this._computeConfigBuffer.setFloat32Array("data",this._computeConfigArray),this._computeConfigBuffer.apply(),this._isInfluenceDirty=!1}}calcWorkGroup(t){let e=Math.ceil(Math.sqrt(t)),r=Math.ceil(Math.log2(e));return e=Math.pow(2,r),e}uploadMorphTargetBuffer(){this._positionAttrDataGroup.output||this._positionAttrDataGroup.apply(this._totalVertexCount),this._normalAttrDataGroup.output||this._normalAttrDataGroup.apply(this._totalVertexCount)}generateGPUBuffer(){this._computeConfigArray=new Float32Array(4),this._computeConfigBuffer=new aa(4),this._morphInfluenceArray=new Float32Array(this.MaxMorphTargetCount);let t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this._morphInfluenceBuffer=new Xe(this.MaxMorphTargetCount,t)}}class le{}s(le,"GLTF_NODE_INDEX_PROPERTY"),s(le,"BASE_COLOR_UNIFORM","u_baseColorFactor"),s(le,"BASE_COLOR_TEXTURE_UNIFORM","u_baseColorSampler"),s(le,"METALROUGHNESS_UNIFORM","u_metallicRoughnessValues"),s(le,"METALROUGHNESS_TEXTURE_UNIFORM","u_metallicRoughnessSampler"),s(le,"NORMAL_TEXTURE_UNIFORM","u_normalSampler"),s(le,"NORMAL_SCALE_UNIFORM","u_normalScale"),s(le,"EMISSIVE_TEXTURE_UNIFORM","u_emissiveSampler"),s(le,"EMISSIVE_FACTOR_UNIFORM","u_emissiveFactor"),s(le,"OCCLUSION_TEXTURE_UNIFORM","u_occlusionSampler"),s(le,"OCCLUSION_FACTOR_UNIFORM","u_occlusionFactor"),s(le,"MAX_MORPH_TARGETS",8),s(le,"MORPH_POSITION_PREFIX","a_morphPositions_"),s(le,"MORPH_NORMAL_PREFIX","a_morphNormals_"),s(le,"MORPH_TANGENT_PREFIX","a_morphTangents_"),s(le,"MORPH_WEIGHT_UNIFORM","u_morphWeights"),s(le,"SCENE_ROOT_SKELETON","SCENE_ROOT"),s(le,"IDENTITY_INVERSE_BIND_MATRICES","IDENTITY_IBM"),s(le,"JOINT_MATRICES_UNIFORM","u_jointMatrix"),s(le,"ALPHA_CUTOFF_UNIFORM","u_alphaCutoff");var k=(n=>(n.position="position",n.normal="normal",n.uv="uv",n.TANGENT="TANGENT",n.TEXCOORD_1="TEXCOORD_1",n.TEXCOORD_2="TEXCOORD_2",n.TEXCOORD_3="TEXCOORD_3",n.TEXCOORD_4="TEXCOORD_4",n.TEXCOORD_5="TEXCOORD_5",n.TEXCOORD_6="TEXCOORD_6",n.TEXCOORD_7="TEXCOORD_7",n.color="color",n.joints0="joints0",n.joints1="joints1",n.weights0="weights0",n.weights1="weights1",n.weight="weight",n.indices="indices",n.vIndex="vIndex",n.a_morphPositions_0="a_morphPositions_0",n.all="all",n))(k||{}),q=(n=>(n[n.NONE=0]="NONE",n[n.ABOVE=1]="ABOVE",n[n.ALPHA=2]="ALPHA",n[n.NORMAL=3]="NORMAL",n[n.ADD=4]="ADD",n[n.BELOW=5]="BELOW",n[n.ERASE=6]="ERASE",n[n.MUL=7]="MUL",n[n.SCREEN=8]="SCREEN",n[n.DIVD=9]="DIVD",n[n.SOFT_ADD=10]="SOFT_ADD",n))(q||{}),Hl=(n=>(n[n.src_a=0]="src_a",n[n.dest_a=1]="dest_a",n))(Hl||{});class Kl{static getBlend(t){let e={color:{srcFactor:"src-alpha",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}};switch(t){case 0:e.color.srcFactor="one",e.color.dstFactor="zero",e.color.operation="add";break;case 1:e.color.srcFactor="one-minus-src-alpha",e.color.dstFactor="dst-alpha",e.color.operation="add";break;case 4:e.color.srcFactor="one",e.color.dstFactor="one",e.color.operation="add",e.alpha.srcFactor="one",e.alpha.dstFactor="one",e.alpha.operation="add";break;case 2:e.color.srcFactor="src-alpha",e.color.dstFactor="one-minus-src-alpha",e.color.operation="add";break;case 5:e.color.srcFactor="one-minus-src-alpha",e.color.dstFactor="one",e.color.operation="add";break;case 6:e.color.srcFactor="zero",e.color.dstFactor="one-minus-src-alpha",e.color.operation="add";break;case 7:e.color.srcFactor="dst",e.color.dstFactor="one-minus-src-alpha",e.color.operation="add";break;case 3:e.color.srcFactor="src-alpha",e.color.dstFactor="one-minus-src-alpha",e.color.operation="add";break;case 10:e.color.srcFactor="one",e.color.dstFactor="one",e.color.operation="max",e.alpha.srcFactor="one",e.alpha.dstFactor="one",e.alpha.operation="add";break;case 8:e.color.srcFactor="one",e.color.dstFactor="one-minus-src",e.color.operation="add";break}return e}}const Yt=class Yt{static getMipmapPipeline(t){let e=R.device,r=Yt.pipelineCache[t.format];if(!r){const a=e.createShaderModule({code:Yt.mipmapShader});let i=e.createBindGroupLayout({entries:[{binding:0,visibility:t.visibility,sampler:t.samplerBindingLayout},{binding:1,visibility:t.visibility,texture:t.textureBindingLayout}]}),o=R.device.createPipelineLayout({bindGroupLayouts:[i]});r=e.createRenderPipeline({layout:o,vertex:{module:a,entryPoint:"vertexMain"},fragment:{module:a,entryPoint:"fragmentMain",targets:[{format:t.format}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}}),Yt.pipelineCache[t.format]=r}return r}static webGPUGenerateMipmap(t){let e=R.device,r=t.textureDescriptor,a=Yt.getMipmapPipeline(t),i=t.getGPUTexture().createView({baseMipLevel:0,mipLevelCount:1});const o=S.beginCommandEncoder();for(let l=1;l<r.mipLevelCount;++l){const h=t.getGPUTexture().createView({baseMipLevel:l,mipLevelCount:1}),c=o.beginRenderPass({colorAttachments:[{view:h,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]});let u=e.createBindGroupLayout({entries:[{binding:0,visibility:t.visibility,sampler:t.samplerBindingLayout},{binding:1,visibility:t.visibility,texture:t.textureBindingLayout}]});const d=e.createBindGroup({layout:u,entries:[{binding:0,resource:t.gpuSampler},{binding:1,resource:i}]});c.setPipeline(a),c.setBindGroup(0,d),c.draw(4),c.end(),i=h}S.endCommandEncoder(o)}static getMipmapCount(t,e){let r=Math.max(t,e);return 1+Math.log2(r)|0}};s(Yt,"mipmapShader",`
        var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
        vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),
        vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));

        struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) texCoord : vec2<f32>
        };

        @vertex
        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
        return output;
        }

        @binding(0) @group(0) var imgSampler : sampler;
        @binding(1) @group(0) var img : texture_2d<f32>;

        @fragment
        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
        var outColor: vec4<f32> = textureSampleLevel(img, imgSampler, texCoord , 0.0 );
        return outColor;
        }
      `),s(Yt,"pipelineCache",{}),s(Yt,"pipeline");let jr=Yt;class rt{constructor(t=32,e=32,r=1){s(this,"name");s(this,"url");s(this,"gpuTexture");s(this,"pid");s(this,"view");s(this,"gpuSampler");s(this,"gpuSampler_comparison");s(this,"format");s(this,"usage");s(this,"width",4);s(this,"height",4);s(this,"depthOrArrayLayers",1);s(this,"numberLayer",1);s(this,"viewDescriptor");s(this,"textureDescriptor");s(this,"visibility",GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT);s(this,"textureBindingLayout",{viewDimension:"2d",multisampled:!1});s(this,"samplerBindingLayout",{type:"filtering"});s(this,"sampler_comparisonBindingLayout",{type:"comparison"});s(this,"flipY");s(this,"isVideoTexture");s(this,"isHDRTexture");s(this,"_useMipmap",!1);s(this,"_sourceImageData");s(this,"_addressModeU");s(this,"_addressModeV");s(this,"_addressModeW");s(this,"_magFilter");s(this,"_minFilter");s(this,"_mipmapFilter");s(this,"_lodMinClamp");s(this,"_lodMaxClamp");s(this,"_compare");s(this,"_maxAnisotropy");s(this,"mipmapCount",1);s(this,"_textureChange",!1);s(this,"_stateChangeRef",new Map);this.width=t,this.height=e,this.numberLayer=r,this.minFilter=Tr.linear,this.magFilter=Tr.linear,this.mipmapFilter=Tr.linear,this.addressModeU=Bt.repeat,this.addressModeV=Bt.repeat}init(){let t=this;return t.internalCreateBindingLayoutDesc&&t.internalCreateBindingLayoutDesc(),t.internalCreateTexture&&t.internalCreateTexture(),t.internalCreateView&&t.internalCreateView(),t.internalCreateSampler&&t.internalCreateSampler(),this}createTextureDescriptor(t,e,r,a,i=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING,o=1,l=0){this.width=t,this.height=e,this.format=a,this.usage=i,this.textureDescriptor={size:[t,e,o],mipLevelCount:r,format:a,usage:i,label:`${this.name+this.width+this.height+this.format}`},l>0&&(this.textureDescriptor.sampleCount=l),o>1?this.viewDescriptor={format:a,dimension:"2d-array"}:this.viewDescriptor={format:a,dimension:this.textureBindingLayout.viewDimension,mipLevelCount:r,baseMipLevel:0}}generate(t){let e=32,r=32;"width"in t&&(e=t.width,r=t.height),(e<32||r<32)&&console.log(t.name+"Size must be greater than 32!"),this.width=e,this.height=r,this.createTexture(t)}createTexture(t){this._sourceImageData=t,this.updateTextureDescription(),this.updateGPUTexture();let e=R.device;this.gpuTexture instanceof GPUTexture&&e.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),this.useMipmap&&jr.webGPUGenerateMipmap(this)}get useMipmap(){return this._useMipmap}set useMipmap(t){if(t){if(this.samplerBindingLayout.type="filtering",this._useMipmap==!1&&this._sourceImageData){this._useMipmap=!0,this.updateTextureDescription(),this.updateGPUTexture();let e=R.device;this.gpuTexture instanceof GPUTexture&&e.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),jr.webGPUGenerateMipmap(this)}}else if(this.samplerBindingLayout.type="non-filtering",this._useMipmap==!0&&this._sourceImageData){this._useMipmap=!1,this.updateTextureDescription(),this.updateGPUTexture();let e=R.device;this.gpuTexture instanceof GPUTexture&&e.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height])}this._textureChange=!0,this._useMipmap=t,this.noticeChange()}get sourceImageData(){return this._sourceImageData}getMipmapCount(){let t=this.width,e=this.height,r=Math.max(t,e);return 1+Math.log2(r)|0}updateTextureDescription(){this.mipmapCount=Math.floor(this.useMipmap?this.getMipmapCount():1),this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format)}updateGPUTexture(){this.gpuTexture&&this.gpuTexture instanceof GPUTexture&&this.gpuTexture.destroy(),this.gpuTexture=null,this.view=null,this.gpuTexture=this.getGPUTexture()}getGPUTexture(){return this.gpuTexture||(this.gpuTexture=R.device.createTexture(this.textureDescriptor)),this.gpuTexture}getGPUView(t=0){return this.view||(this.gpuTexture=this.getGPUTexture(),this.gpuTexture instanceof GPUTexture&&(this.view=this.gpuTexture.createView(this.viewDescriptor),this.view.label=this.name)),this.view}bindStateChange(t,e){this._stateChangeRef.set(e,t)}unBindStateChange(t){this._stateChangeRef.delete(t)}noticeChange(){this.gpuSampler=R.device.createSampler(this),this._stateChangeRef.forEach((t,e)=>{t()})}destroy(t){t&&this.gpuTexture instanceof GPUTexture&&(this.gpuSampler=null,this.gpuSampler_comparison=null,this.textureBindingLayout=null,this.textureDescriptor=null,this.gpuTexture.destroy(),this.gpuTexture=null),this._stateChangeRef.clear()}get addressModeU(){return this._addressModeU}set addressModeU(t){this._addressModeU!=t&&(this._addressModeU=t,this.noticeChange())}get addressModeV(){return this._addressModeV}set addressModeV(t){this._addressModeV!=t&&(this._addressModeV=t,this.noticeChange())}get addressModeW(){return this._addressModeW}set addressModeW(t){this._addressModeW!=t&&(this._addressModeW=t,this.noticeChange())}get magFilter(){return this._magFilter}set magFilter(t){this._magFilter!=t&&(this._magFilter=t,this.noticeChange())}get minFilter(){return this._minFilter}set minFilter(t){this._minFilter!=t&&(this._minFilter=t,this.noticeChange())}get mipmapFilter(){return this._mipmapFilter}set mipmapFilter(t){this._mipmapFilter!=t&&(this._mipmapFilter=t,this.noticeChange())}get lodMinClamp(){return this._lodMinClamp}set lodMinClamp(t){this._lodMinClamp!=t&&(this._lodMinClamp=t,this.noticeChange())}get lodMaxClamp(){return this._lodMaxClamp}set lodMaxClamp(t){this._lodMaxClamp!=t&&(this._lodMaxClamp=t,this.noticeChange())}get compare(){return this._compare}set compare(t){this._compare!=t&&(this._compare=t,this.noticeChange())}get maxAnisotropy(){return this._maxAnisotropy}set maxAnisotropy(t){this._maxAnisotropy!=t&&(this._maxAnisotropy=t,this.noticeChange())}static delayDestroyTexture(t){this._texs.includes(t)||this._texs.push(t)}static destroyTexture(){if(this._texs.length>0)for(;this._texs.length>0;)this._texs.shift().destroy()}}s(rt,"_texs",[]);class jl extends rt{constructor(e,r,a){super(e,r,a);s(this,"_bitmapTextures");this.format=H.rgba8unorm,this.mipmapCount=1,this._bitmapTextures=[],this.init()}setTextures(e){this._bitmapTextures.length=0;for(let r=0;r<e.length;r++){const a=e[r];this.addTexture(a)}}addTexture(e){(e.width!=this.width||e.height!=this.height)&&console.error("bitmap texture must match bitmapTextureArray size!"),e.pid=this._bitmapTextures.length,this._bitmapTextures.push(e),this.updateTexture()}removeTexture(e){let r=this._bitmapTextures.indexOf(e);if(r!=-1){this._bitmapTextures.splice(r,1);for(let a=0;a<this._bitmapTextures.length;a++){const i=this._bitmapTextures[a];i.pid=a}}}updateTexture(){let e=S.beginCommandEncoder();for(let r=0;r<this._bitmapTextures.length;r++){let a=this._bitmapTextures[r];e.copyTextureToTexture({texture:a.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:r}},{width:this.width,height:this.height,depthOrArrayLayers:1})}S.endCommandEncoder(e)}internalCreateBindingLayoutDesc(){this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.minFilter=Tr.linear,this.magFilter=Tr.linear}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=R.device.createSampler(this)}}const Rt=class Rt{constructor(){s(this,"_iesTexture");s(this,"index",0)}generateIES(t){}set IESTexture(t){this._iesTexture=t,t.addressModeU=Bt.repeat,t.addressModeV=Bt.repeat,t.addressModeW=Bt.repeat,Rt.ies_list.indexOf(this)==-1&&(this.index=Rt.ies_list.length,Rt.ies_list.push(this),Rt.iesTexture||Rt.create(t.width,t.height),Rt.iesTexture.addTexture(t))}get IESTexture(){return this._iesTexture}static create(t,e){let r=48;this.iesTexture=new jl(t,e,r)}};s(Rt,"use",!1),s(Rt,"iesTexture"),s(Rt,"ies_list",[]);let Ua=Rt;class Ea{constructor(t=0,e="\0"){s(this,"Type",0);s(this,"Line",0);s(this,"Colume",0);s(this,"Literal","");this.Type=t,this.Literal=e}isTypeEqual(t){return this.Type==t}isLiteralEqual(t){return this.Literal==t}isBuiltinType(){return this.Type>33&&this.Type<101}isDataType(){return this.Type==1||this.isBuiltinType()}isOperation(){return this.Type>102&&this.Type<127}isAssignOperation(){return this.Type>128&&this.Type<133}get nOperationPriorityLevel(){switch(this.Type){case 26:return 1;case 27:return 1;case 125:return 2;case 110:return 3;case 114:return 3;case 105:return 4;case 106:return 4;case 103:return 5;case 104:return 5;case 115:return 6;case 116:return 6;case 119:return 7;case 120:return 7;case 122:return 7;case 123:return 7;case 121:return 8;case 124:return 8;case 111:return 9;case 113:return 10;case 112:return 11;case 107:return 12;case 109:return 13;case 108:return 14;case 24:return 15;case 126:return 16;case 129:return 16;case 130:return 16;case 131:return 16;case 132:return 16}return 99}}var m=(n=>(n[n.EOF=0]="EOF",n[n.IDENT=1]="IDENT",n[n.VOID=2]="VOID",n[n.CONST=3]="CONST",n[n.LAYOUT=4]="LAYOUT",n[n.PRECISION=5]="PRECISION",n[n.ATTRIBUTE=6]="ATTRIBUTE",n[n.UNIFORM=7]="UNIFORM",n[n.VARYING=8]="VARYING",n[n.INVARIANT=9]="INVARIANT",n[n.IN=10]="IN",n[n.OUT=11]="OUT",n[n.INOUT=12]="INOUT",n[n.IF=13]="IF",n[n.ELSE=14]="ELSE",n[n.FOR=15]="FOR",n[n.WHILE=16]="WHILE",n[n.DO=17]="DO",n[n.BREAK=18]="BREAK",n[n.RETURN=19]="RETURN",n[n.CONTINUE=20]="CONTINUE",n[n.STRUCT=21]="STRUCT",n[n.COMMA=22]="COMMA",n[n.COLON=23]="COLON",n[n.QUEMARK=24]="QUEMARK",n[n.SEMICOLON=25]="SEMICOLON",n[n.LEFTSAMLL=26]="LEFTSAMLL",n[n.RIGHTSAMLL=27]="RIGHTSAMLL",n[n.LEFTMEDI=28]="LEFTMEDI",n[n.RIGHTMEDI=29]="RIGHTMEDI",n[n.LEFTBIG=30]="LEFTBIG",n[n.RIGHTBIG=31]="RIGHTBIG",n[n.LITERAL=32]="LITERAL",n[n.BeginBuiltinType=33]="BeginBuiltinType",n[n.INT=34]="INT",n[n.INT_ARRAY=35]="INT_ARRAY",n[n.UINT=36]="UINT",n[n.UINT_ARRAY=37]="UINT_ARRAY",n[n.BOOL=38]="BOOL",n[n.BOOL_ARRAY=39]="BOOL_ARRAY",n[n.FLOAT=40]="FLOAT",n[n.FLOAT_ARRAY=41]="FLOAT_ARRAY",n[n.DOUBLE=42]="DOUBLE",n[n.DOUBLE_ARRAY=43]="DOUBLE_ARRAY",n[n.VEC2=44]="VEC2",n[n.VEC2_ARRAY=45]="VEC2_ARRAY",n[n.VEC3=46]="VEC3",n[n.VEC3_ARRAY=47]="VEC3_ARRAY",n[n.VEC4=48]="VEC4",n[n.VEC4_ARRAY=49]="VEC4_ARRAY",n[n.BVEC2=50]="BVEC2",n[n.BVEC2_ARRAY=51]="BVEC2_ARRAY",n[n.BVEC3=52]="BVEC3",n[n.BVEC3_ARRAY=53]="BVEC3_ARRAY",n[n.BVEC4=54]="BVEC4",n[n.BVEC4_ARRAY=55]="BVEC4_ARRAY",n[n.IVEC2=56]="IVEC2",n[n.IVEC2_ARRAY=57]="IVEC2_ARRAY",n[n.IVEC3=58]="IVEC3",n[n.IVEC3_ARRAY=59]="IVEC3_ARRAY",n[n.IVEC4=60]="IVEC4",n[n.IVEC4_ARRAY=61]="IVEC4_ARRAY",n[n.UVEC2=62]="UVEC2",n[n.UVEC2_ARRAY=63]="UVEC2_ARRAY",n[n.UVEC3=64]="UVEC3",n[n.UVEC3_ARRAY=65]="UVEC3_ARRAY",n[n.UVEC4=66]="UVEC4",n[n.UVEC4_ARRAY=67]="UVEC4_ARRAY",n[n.MAT2x2=68]="MAT2x2",n[n.MAT2x2_ARRAY=69]="MAT2x2_ARRAY",n[n.MAT2x3=70]="MAT2x3",n[n.MAT2x3_ARRAY=71]="MAT2x3_ARRAY",n[n.MAT2x4=72]="MAT2x4",n[n.MAT2x4_ARRAY=73]="MAT2x4_ARRAY",n[n.MAT3x2=74]="MAT3x2",n[n.MAT3x2_ARRAY=75]="MAT3x2_ARRAY",n[n.MAT3x3=76]="MAT3x3",n[n.MAT3x3_ARRAY=77]="MAT3x3_ARRAY",n[n.MAT3x4=78]="MAT3x4",n[n.MAT3x4_ARRAY=79]="MAT3x4_ARRAY",n[n.MAT4x2=80]="MAT4x2",n[n.MAT4x2_ARRAY=81]="MAT4x2_ARRAY",n[n.MAT4x3=82]="MAT4x3",n[n.MAT4x3_ARRAY=83]="MAT4x3_ARRAY",n[n.MAT4x4=84]="MAT4x4",n[n.MAT4x4_ARRAY=85]="MAT4x4_ARRAY",n[n.SAMPLER=86]="SAMPLER",n[n.SAMPLER_1D=87]="SAMPLER_1D",n[n.SAMPLER_2D=88]="SAMPLER_2D",n[n.SAMPLER_3D=89]="SAMPLER_3D",n[n.SAMPLER_CUBE=90]="SAMPLER_CUBE",n[n.SAMPLER_SHADOW=91]="SAMPLER_SHADOW",n[n.SAMPLER_1D_SHADOW=92]="SAMPLER_1D_SHADOW",n[n.SAMPLER_2D_SHADOW=93]="SAMPLER_2D_SHADOW",n[n.TEXTURE_1D=94]="TEXTURE_1D",n[n.TEXTURE_1D_ARRAY=95]="TEXTURE_1D_ARRAY",n[n.TEXTURE_2D=96]="TEXTURE_2D",n[n.TEXTURE_2D_ARRAY=97]="TEXTURE_2D_ARRAY",n[n.TEXTURE_3D=98]="TEXTURE_3D",n[n.TEXTURE_CUBE=99]="TEXTURE_CUBE",n[n.TEXTURE_CUBE_ARRAY=100]="TEXTURE_CUBE_ARRAY",n[n.EndBuiltinType=101]="EndBuiltinType",n[n.BeginOperation=102]="BeginOperation",n[n.ADD=103]="ADD",n[n.SUB=104]="SUB",n[n.MUL=105]="MUL",n[n.DIV=106]="DIV",n[n.AND=107]="AND",n[n.OR=108]="OR",n[n.XOR=109]="XOR",n[n.NOT=110]="NOT",n[n.BITAND=111]="BITAND",n[n.BITOR=112]="BITOR",n[n.BITXOR=113]="BITXOR",n[n.BITNOT=114]="BITNOT",n[n.BITSHIFT_L=115]="BITSHIFT_L",n[n.BITSHIFT_R=116]="BITSHIFT_R",n[n.INC=117]="INC",n[n.DEC=118]="DEC",n[n.GREATER=119]="GREATER",n[n.GREATEREQUAL=120]="GREATEREQUAL",n[n.EQUAL=121]="EQUAL",n[n.LESS=122]="LESS",n[n.LESSEQUAL=123]="LESSEQUAL",n[n.NOTEQUAL=124]="NOTEQUAL",n[n.DOT=125]="DOT",n[n.ASSIGN=126]="ASSIGN",n[n.EndOperation=127]="EndOperation",n[n.BeginAssignOperation=128]="BeginAssignOperation",n[n.ADDASSIGN=129]="ADDASSIGN",n[n.SUBASSIGN=130]="SUBASSIGN",n[n.MULASSIGN=131]="MULASSIGN",n[n.DIVASSIGN=132]="DIVASSIGN",n[n.EndAssignOperation=133]="EndAssignOperation",n))(m||{});class ua{constructor(t){s(this,"_char");s(this,"_line");s(this,"_column");s(this,"_source");s(this,"_currPosition");s(this,"_nextPosition");this.reset(t)}reset(t){this._char="",this._line=0,this._column=0,this._source=t,this._currPosition=0,this._nextPosition=0}get source(){return this._source}getChar(){return this._char}get currPosition(){return this._currPosition}peekChar(){return this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition]}readChar(){this._char=this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition],this._char!==`
`?this._column++:(this._line++,this._column=0),this._currPosition=this._nextPosition,this._nextPosition++}readCharAndSkipWhitespace(){this.readChar(),this.skipWhitespace()}readIdentifier(){for(var t=this._currPosition;this.isIdentifier(this._char);)this.readChar();return this._source.substring(t,this._currPosition)}isIdentifier(t){var e=t.charCodeAt(0);return 97<=e&&e<=122||65<=e&&e<=90||48<=e&&e<=57||e==95}skipWhitespace(){for(;this.IsWhitespace(this._char);)this.readChar()}IsWhitespace(t){return t===" "||t==="	"||t==="\r"||t===`
`}skipComment(){for(;this._char!==`
`&&this._char!=="\0";)this.readChar();this.skipWhitespace()}skipMultilineComment(){if(!(this._char!=="/"&&this.peekChar()!=="*")){this.readChar(),this.readChar();for(let t=1;t>0&&this._char!=="\0";)if(this.readChar(),this._char==="/"&&this.peekChar()==="*"){t++,this.readChar();continue}else if(this._char==="*"&&this.peekChar()==="/"){t--,this.readChar();continue}this.readChar(),this.readChar(),this.skipWhitespace()}}isDigit(t){var e=t.charCodeAt(0);return 48<=e&&e<=57}readNumber(){for(var t=this._currPosition;this.isDigit(this._char);)this.readChar();if(this._char===".")for(this.readChar();this.isDigit(this._char);)this.readChar();return this._source.substring(t,this._currPosition)}readValue(){return this.isDigit(this._char)?this.readNumber():this.readIdentifier()}readLine(){var t=this._currPosition,e=this._source.indexOf(`
`,this._currPosition);return e==-1&&(e=this._source.length),this._line++,this._column=0,this._currPosition=e,this._nextPosition=e+1,this._source.substring(t,e+1)}}class ql extends ua{constructor(e){super(e.source);s(this,"_tokenPosition",0);s(this,"_tokens",[]);this.parse()}skipToken(e){this._tokenPosition+=e}peekToken(e){return this._tokenPosition+e>=this._tokens.length?new Ea(m.EOF,"\0"):this._tokens[this._tokenPosition+e]}GetNextToken(){if(this._tokenPosition>=this._tokens.length)return new Ea(m.EOF,"\0");let e=this._tokens[this._tokenPosition];return this._tokenPosition++,e}get currTokenPosition(){return this._tokenPosition}parse(){this.readChar(),this._tokens=new Array;var e;do e=this.nextToken(),this._tokens.push(e);while(e.Type!=m.EOF)}nextToken(){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/")return this.skipComment(),this.nextToken();if(this.peekChar()==="*")return this.skipMultilineComment(),this.nextToken()}var e=new Ea;switch(e.Line=this._line,e.Colume=this._column,this._char){case"\0":e.Type=m.EOF,e.Literal="EOF";break;case".":e.Type=m.DOT,e.Literal=".";break;case",":e.Type=m.COMMA,e.Literal=",";break;case":":e.Type=m.COLON,e.Literal=":";break;case"?":e.Type=m.QUEMARK,e.Literal="?";break;case";":e.Type=m.SEMICOLON,e.Literal=";";break;case"(":e.Type=m.LEFTSAMLL,e.Literal="(";break;case")":e.Type=m.RIGHTSAMLL,e.Literal=")";break;case"[":e.Type=m.LEFTMEDI,e.Literal="[";break;case"]":e.Type=m.RIGHTMEDI,e.Literal="]";break;case"{":e.Type=m.LEFTBIG,e.Literal="{";break;case"}":e.Type=m.RIGHTBIG,e.Literal="}";break;case"+":if(this.peekChar()==="+"){this.readChar(),e.Type=m.INC,e.Literal="++";break}else if(this.peekChar()==="="){this.readChar(),e.Type=m.ADDASSIGN,e.Literal="+=";break}e.Type=m.ADD,e.Literal="+";break;case"-":if(this.peekChar()==="-"){this.readChar(),e.Type=m.DEC,e.Literal="--";break}else if(this.peekChar()==="="){this.readChar(),e.Type=m.SUBASSIGN,e.Literal="-=";break}e.Type=m.SUB,e.Literal="-";break;case"*":if(this.peekChar()==="="){this.readChar(),e.Type=m.MULASSIGN,e.Literal="*=";break}e.Type=m.MUL,e.Literal="*";break;case"/":if(this.peekChar()==="="){this.readChar(),e.Type=m.DIVASSIGN,e.Literal="/=";break}e.Type=m.DIV,e.Literal="/";break;case"&":if(this.peekChar()==="&"){this.readChar(),e.Type=m.AND,e.Literal="&&";break}e.Type=m.BITAND,e.Literal="&";break;case"|":if(this.peekChar()==="|"){this.readChar(),e.Type=m.OR,e.Literal="||";break}e.Type=m.BITOR,e.Literal="&";break;case"^":e.Type=m.BITXOR,e.Literal="^";break;case"!":if(this.peekChar()==="="){this.readChar(),e.Type=m.NOTEQUAL,e.Literal="!=";break}e.Type=m.NOT,e.Literal="!";break;case">":if(this.peekChar()==="="){this.readChar(),e.Type=m.GREATEREQUAL,e.Literal=">=";break}else if(this.peekChar()===">"){this.readChar(),e.Type=m.BITSHIFT_R,e.Literal=">>";break}e.Type=m.GREATER,e.Literal=">";break;case"=":if(this.peekChar()==="="){this.readChar(),e.Type=m.EQUAL,e.Literal="==";break}e.Type=m.ASSIGN,e.Literal="=";break;case"<":if(this.peekChar()==="="){this.readChar(),e.Type=m.LESSEQUAL,e.Literal="<=";break}else if(this.peekChar()==="<"){this.readChar(),e.Type=m.BITSHIFT_L,e.Literal="<<";break}e.Type=m.LESS,e.Literal="<";break;default:return this.isDigit(this._char)?this.readDecimal():(e.Literal=this.readIdentifier(),e.Type=this.lookupIdentifier(e.Literal),this.getChar()=="["&&this.peekChar()=="]"&&e.isBuiltinType()&&(e.Type++,e.Literal+="[]",this.readChar(),this.readChar()),e)}return this.readChar(),e}readDecimal(){var e=new Ea;e.Line=this._line,e.Colume=this._column,e.Type=m.LITERAL;var r=this.readNumber();return this._char==="e"?(e.Literal=r+this._char,this.readChar(),e.Literal+=this._char,this.readChar(),e.Literal+=this.readNumber(),e.Type=m.LITERAL,e):this._char==="u"?(this.readChar(),e.Type=m.LITERAL,e.Literal=r+"u",e):this._char==="f"?(this.readChar(),e.Type=m.LITERAL,e.Literal=r+"f",e):(e.Type=m.LITERAL,e.Literal=r,e)}lookupIdentifier(e){switch(e){case"void":return m.VOID;case"int":return m.INT;case"uint":return m.UINT;case"bool":return m.BOOL;case"true":return m.BOOL;case"false":return m.BOOL;case"float":return m.FLOAT;case"vec2":return m.VEC2;case"vec3":return m.VEC3;case"vec4":return m.VEC4;case"bvec2":return m.BVEC2;case"bvec3":return m.BVEC3;case"bvec4":return m.BVEC4;case"ivec2":return m.IVEC2;case"ivec3":return m.IVEC3;case"ivec4":return m.IVEC4;case"uvec2":return m.UVEC2;case"uvec3":return m.UVEC3;case"uvec4":return m.UVEC4;case"mat2":return m.MAT2x2;case"mat2x2":return m.MAT2x2;case"mat2x3":return m.MAT2x3;case"mat2x4":return m.MAT2x4;case"mat3":return m.MAT3x3;case"mat3x2":return m.MAT3x2;case"mat3x3":return m.MAT3x3;case"mat3x4":return m.MAT3x4;case"mat4":return m.MAT4x4;case"mat4x2":return m.MAT4x2;case"mat4x3":return m.MAT4x3;case"mat4x4":return m.MAT4x4;case"sampler":return m.SAMPLER;case"sampler1D":return m.SAMPLER_1D;case"sampler2D":return m.SAMPLER_2D;case"sampler3D":return m.SAMPLER_3D;case"samplerCube":return m.SAMPLER_CUBE;case"samplerShadow":return m.SAMPLER_SHADOW;case"sampler1DShadow":return m.SAMPLER_1D_SHADOW;case"sampler2DShadow":return m.SAMPLER_2D_SHADOW;case"texture1D":return m.TEXTURE_1D;case"texture2D":return m.TEXTURE_2D;case"texture3D":return m.TEXTURE_3D;case"textureCube":return m.TEXTURE_CUBE;case"texture1DArray":return m.TEXTURE_1D_ARRAY;case"texture2DArray":return m.TEXTURE_2D_ARRAY;case"textureCubeArray":return m.TEXTURE_CUBE_ARRAY;case"const":return m.CONST;case"layout":return m.LAYOUT;case"precision":return m.PRECISION;case"attribute":return m.ATTRIBUTE;case"uniform":return m.UNIFORM;case"varying":return m.VARYING;case"invariant":return m.INVARIANT;case"in":return m.IN;case"out":return m.OUT;case"inout":return m.INOUT;case"if":return m.IF;case"else":return m.ELSE;case"for":return m.FOR;case"while":return m.WHILE;case"do":return m.DO;case"break":return m.BREAK;case"return":return m.RETURN;case"continue":return m.CONTINUE;case"struct":return m.STRUCT}return m.IDENT}}class $l{constructor(){s(this,"name","");s(this,"value","");s(this,"args",[])}}class eh extends ua{constructor(e){super(e);s(this,"_result");s(this,"_skipLine");s(this,"_definitionTables");this._result="",this._skipLine=!1,this._definitionTables=new Map,this.parse()}parse(){for(this.readChar();this._char!=="\0";){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/"){this.skipComment();continue}if(this.peekChar()==="*"){this.skipMultilineComment();continue}}if(this._char==="#"){this.readCharAndSkipWhitespace();var e=this.readIdentifier();switch(e){case"version":this.readLine().trim();break;case"define":this.readCharAndSkipWhitespace();var r=this.readIdentifier();if(this.getChar()==="("){let h=new $l;if(this.readCharAndSkipWhitespace(),this.getChar()!==")")do{var a=this.readIdentifier();if(h.args.push(a),this.skipWhitespace(),this.getChar()===","){this.readCharAndSkipWhitespace();continue}}while(this.getChar()!==")");this.readCharAndSkipWhitespace(),h.name=r,h.value=this.readLine().trim(),this._definitionTables.set(r,h),this.readCharAndSkipWhitespace()}else{let h=this.readLine().trim();h[0]=="="&&(h=h.substring(1)),this._definitionTables.set(r,h)}break;case"if":let l=this.readLine().trim();if(l=="0"||l=="false"){this._skipLine=!0;break}if(this._definitionTables.has(l)&&(l=this._definitionTables.get(l),l=="0"||l=="false")){this._skipLine=!0;break}break;case"ifdef":this.readCharAndSkipWhitespace();var i=this.readIdentifier();this._skipLine=!this._definitionTables.has(i);break;case"else":this._skipLine=!this._skipLine;break;case"endif":this._skipLine=!1;break;default:throw"Unknown preprocessing command:"+e}}else{var o=this.readLine();if(!this._skipLine){for(let l of this._definitionTables.keys()){let h=o.indexOf(l);if(h!=-1){let c=this._definitionTables.get(l);if(typeof c=="string")o=o.replace(l,c);else{let u=c,d=new ua(o.substring(h+l.length));if(d.readCharAndSkipWhitespace(),d.getChar()==="("){d.readCharAndSkipWhitespace();for(let B=1;d.getChar()!=="\0"&&B>0;){switch(d.getChar()){case"(":B++;break;case")":B--;break}d.readCharAndSkipWhitespace()}}let f=h,A=f+l.length+d.currPosition,p=o.substring(f,A).trim();if(u.args.length>0){let B=[],F=p.substring(p.indexOf("(")+1,p.lastIndexOf(")")).trim();F.length>0&&(B=this.parseArgs(F));let U=u.value.substring(u.value.indexOf("("));for(let Q=0;Q<u.args.length;Q++)U=U.replace(u.args[Q],B[Q]);U=u.value.substring(0,u.value.indexOf("("))+U,o=o.replace(p,U)}else o=o.replace(p,u.value)}}}this._result+=o}this.readChar()}}}get source(){return this._result}parseArgs(e){let r=[],a=0,i=new ua(e),o=i.currPosition;if(i.readCharAndSkipWhitespace(),i.getChar()!=="\0")for(i.readCharAndSkipWhitespace();i.getChar()!=="\0";){switch(i.getChar()){case"(":a++;break;case")":a--;break;case",":if(a==0){let l=e.substring(o,i.currPosition);r.push(l),o=i.currPosition+1}break}i.readCharAndSkipWhitespace()}if(o<i.currPosition){let l=e.substring(o,i.currPosition);r.push(l)}return r}}class th{constructor(t){s(this,"result");s(this,"ASTRoot");s(this,"_syntax");this.result="",this._syntax=t,this.ASTRoot=t.ASTRoot}generateWGSL(){let t=new sn;var e=new sh;let r=[],a=[],i=[];for(let u of this.ASTRoot.nodes)if(u instanceof si)if(u.scope=="in")if(u.nodes[0]instanceof Se){t.layoutsIn.push(u);let d=new ys;d.name=u.nodes[0].name,d.type=u.nodes[0].type,d.locationID=Number.parseInt(u.qualifier.get("location")),e.inputAttribute.push(d)}else if(u.qualifier.has("local_size_x"))t.workGroupSize=u;else throw"not impl";else if(u.scope=="out")if(t.layoutsOut.push(u),u.nodes[0]instanceof Se){let d=new ys;d.name=u.nodes[0].name,d.type=u.nodes[0].type,d.locationID=Number.parseInt(u.qualifier.get("location")),e.outputAttribute.push(d)}else throw"not impl";else if(u.scope=="uniform")if(a.push(u),u.nodes[0]instanceof Se){let d=new Es;d.name=u.nodes[0].name,d.type=u.nodes[0].type,d.setID=Number.parseInt(u.qualifier.get("set")),d.bindingID=Number.parseInt(u.qualifier.get("binding")),e.uniformInfo.push(d)}else if(u.nodes[0]instanceof Ar){let d=new Es;d.name="unif"+e.uniformInfo.length.toString(),d.type=u.nodes[0].name,d.setID=Number.parseInt(u.qualifier.get("set")),d.bindingID=Number.parseInt(u.qualifier.get("binding")),e.uniformInfo.push(d)}else throw"not impl";else u.scope=="buffer"&&r.push(u);else i.push(u);t.stage="fragment";let o=0,l=new ua(""),h=this._syntax.lexer.source,c=new Map;for(;(o=h.indexOf("gl_",o))!=-1;){l.reset(h.substring(o,o+32)),l.readChar();let u=l.readIdentifier();if(o+=u.length,!c.has(u))switch(c.set(u,u),u){case"gl_InstanceID":t.stage="vertex",t.builtinIn.push("@builtin(instance_index) gl_InstanceID: u32");break;case"gl_Position":t.stage="vertex",t.builtinOut.push("@builtin(position) gl_Position: vec4<f32>"),t.addIdentifier("gl_Position","stout.gl_Position");break;case"gl_VertexIndex":t.stage="vertex",t.builtinIn.push("@builtin(vertex_index) gl_VertexIndex: u32");break;case"gl_FrontFacing":t.stage="fragment",t.builtinIn.push("@builtin(front_facing) gl_FrontFacing: bool");break;case"gl_FragDepth":t.stage="fragment",t.builtinOut.push("@builtin(frag_depth) gl_FragDepth: f32"),t.addIdentifier("gl_FragDepth","stout.gl_FragDepth");break;case"gl_WorkGroupID":t.stage="compute",t.builtinIn.push("@builtin(workgroup_id) gl_WorkGroupID: vec3<u32>");break;case"gl_NumWorkGroups":t.stage="compute",t.builtinIn.push("@builtin(num_workgroups) gl_NumWorkGroups: vec3<u32>");break;case"gl_LocalInvocationID":t.stage="compute",t.builtinIn.push("@builtin(local_invocation_id) gl_LocalInvocationID: vec3<u32>");break;case"gl_LocalInvocationIndex":t.stage="compute",t.builtinIn.push("@builtin(local_invocation_index) gl_LocalInvocationIndex: u32");break;case"gl_GlobalInvocationID":t.stage="compute",t.builtinIn.push("@builtin(global_invocation_id) gl_GlobalInvocationID: vec3<u32>");break;default:throw"Unprocessed built-in variables: "+u}}for(let u of a)u.nodes[0]instanceof Ar&&(e.sourceCode+=u.nodes[0].formatToWGSL(t,0),e.sourceCode+=`\r
`);for(let u of a)e.sourceCode+=u.formatToWGSL(t,0);e.sourceCode+=`\r
`;for(let u of r)u.nodes[0]instanceof Ar&&(e.sourceCode+=u.nodes[0].formatToWGSL(t,0),e.sourceCode+=`\r
`);for(let u of r)e.sourceCode+=u.formatToWGSL(t,0);e.sourceCode+=`\r
`;for(let u of i)e.sourceCode+=u.formatToWGSL(t,0),u instanceof Se&&(e.sourceCode+=`;\r
`);return e}}class sn{constructor(t){s(this,"_stage","fragment");s(this,"_builtinIn",[]);s(this,"_builtinOut",[]);s(this,"_layoutsIn",[]);s(this,"_layoutsOut",[]);s(this,"_layoutUniformCount",0);s(this,"_workGroupSize");s(this,"_parentContext");s(this,"_identifierEnv",new Map);this._parentContext=t}get stage(){return this.parentContext!=null?this.parentContext.stage:this._stage}set stage(t){this.parentContext!=null&&(this.parentContext.stage=t),this._stage=t}get builtinIn(){return this.parentContext!=null?this.parentContext.builtinIn:this._builtinIn}get builtinOut(){return this.parentContext!=null?this.parentContext.builtinOut:this._builtinOut}get layoutsIn(){return this.parentContext!=null?this.parentContext.layoutsIn:this._layoutsIn}get layoutsOut(){return this.parentContext!=null?this.parentContext.layoutsOut:this._layoutsOut}get layoutUniformCount(){return this.parentContext!=null?this.parentContext.layoutUniformCount:this._layoutUniformCount}set layoutUniformCount(t){if(this.parentContext!=null){this.parentContext.layoutUniformCount=t;return}this._layoutUniformCount=t}get workGroupSize(){return this.parentContext!=null?this.parentContext.workGroupSize:this._workGroupSize}set workGroupSize(t){this.parentContext!=null&&(this.parentContext.workGroupSize=t),this._workGroupSize=t}get parentContext(){return this._parentContext}findIdentifier(t){return this._identifierEnv.has(t)?this._identifierEnv.get(t):this._parentContext!=null?this._parentContext.findIdentifier(t):t}addIdentifier(t,e){this._identifierEnv.set(t,e)}hasIdentifier(t){return this._identifierEnv.has(t)}}class Fe{constructor(){s(this,"nodes",[])}addNode(t){this.nodes.push(t)}formatToWGSL(t,e){return""}}class Ar extends Fe{constructor(e){super();s(this,"name","");s(this,"fields",[]);this.name=e}static parse(e){if(e.peekToken(0).Type==m.IDENT&&e.peekToken(1).Type==m.LEFTBIG){let r=new Ar(e.peekToken(0).Literal);for(e.skipToken(2);e.peekToken(0).Type!=m.RIGHTBIG;){let a=Se.parse(e);r.fields.push(a)}return e.peekToken(0).Type==m.RIGHTBIG&&e.skipToken(1),e.peekToken(0).Type==m.SEMICOLON&&e.skipToken(1),r}throw"Error parsing structure: Unexpected character"}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r);a+=i+"struct "+this.name+` {\r
`;for(let o of this.fields)o.arraySize.nodes.length<=0?a+=i+"  "+o.name+": "+Ut(o.type)+`,\r
`:o.arraySize.nodes[0]instanceof Ur?a+=i+"  "+o.name+": array<"+Ut(o.type)+", "+o.arraySize.nodes[0].value+`>,\r
`:a+=i+"  "+o.name+": array<"+Ut(o.type)+", "+o.arraySize.nodes[0].formatToWGSL(e,0)+`>,\r
`;return a+=i+`};\r
`,a}}class Ji extends Fe{constructor(e,r,a,i){super();s(this,"name");s(this,"args");s(this,"body");s(this,"returnType");this.name=e,this.args=r,this.body=a,this.returnType=i}static parse(e){if((e.peekToken(0).isBuiltinType()||e.peekToken(0).Type==m.VOID)&&e.peekToken(1).Type==m.IDENT&&e.peekToken(2).Type==m.LEFTSAMLL){let r=e.peekToken(0).Literal,a=e.peekToken(1).Literal;e.skipToken(2);let i=new Array;if(e.peekToken(0).Type!=m.LEFTSAMLL)throw"Error parsing function parameter list: Unexpected character";for(e.skipToken(1);e.peekToken(0).Type!=m.EOF;){if(e.peekToken(0).Type==m.RIGHTSAMLL){e.skipToken(1);break}(e.peekToken(0).Type==m.INOUT||e.peekToken(0).Type==m.IN||e.peekToken(0).Type==m.OUT)&&e.skipToken(1);let l=Se.parse(e);i.push(l),e.peekToken(0).Type==m.COMMA&&e.skipToken(1)}let o=Lt.parse(e);return new Ji(a,i,o,r)}throw"Error parsing function: Unexpected character"}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r),o,l=e.layoutsOut.length>0||e.builtinOut.length>0;switch(e.stage){case"compute":o="ComputeOutput";break;case"vertex":o="VertexOutput";break;case"fragment":o="FragmentOutput";break;default:o="StructOutput";break}if(this.name=="main"&&l){a+="struct "+o+` {\r
`;for(let d of e.layoutsOut)if(d.nodes[0]instanceof Se){let f=d.nodes[0];d.qualifier.size==1&&d.qualifier.has("location")&&(a+="  @location("+d.qualifier.get("location")+") "),a+=f.name+": "+Ut(f.type)+`,\r
`,e.addIdentifier(f.name,"stout."+f.name)}let u=e.builtinOut;for(let d of u)a+="  "+d+`,\r
`;a+=`};\r
\r
`}let h="";if(this.name=="main"&&(e.workGroupSize!=null?h+="@"+e.stage+" "+e.workGroupSize.formatToWGSL(e,0)+` \r
`:h+="@"+e.stage+`\r
`),e=new sn(e),h+=i+"fn "+this.name+"(",this.name!="main"){for(let u=0;u<this.args.length;u++){let d=this.args[u];u>0&&(h+=", "),h+=d.name+": "+Ut(d.type),e.addIdentifier(d.name,d.name)}h+=") -> "+Ut(this.returnType)}else{let u=e.layoutsIn;for(let f=0;f<u.length;f++){let A=u[f];if(f>0?h+=`,\r
    `:h+=`\r
    `,A.nodes[0]instanceof Se){let p=A.nodes[0];A.qualifier.size==1&&A.qualifier.has("location")&&(h+="@location("+A.qualifier.get("location")+") "),h+=p.name+": "+Ut(p.type),e.addIdentifier(p.name,p.name)}}u.length>0&&(h+=`,\r
    `);let d=e.builtinIn;for(let f of d)h+=f+`,\r
    `;l?h+=") -> "+o:h+=") "}let c="";this.name=="main"&&l&&(c+="    var stout: "+o+` ;\r
`);for(let u of this.body.nodes)c+=u.formatToWGSL(e,r+1),!(u instanceof ia)&&!(u instanceof ea)&&!(u instanceof $r)&&(c+=`;\r
`);return this.name=="main"&&l&&(c+=`    return stout;\r
`),a+=h+` {\r
`,a+=c,a+=i+`}\r
`,a+=`\r
`,a}}class zi extends Fe{constructor(){super();s(this,"args",[])}static parse(e){if(e.peekToken(0).Type==m.LEFTSAMLL){e.skipToken(1);let r=new zi;for(;e.peekToken(0).Type!=m.EOF;){if(e.peekToken(0).Type==m.RIGHTSAMLL){e.skipToken(1);break}let a=re.parse(e);r.args.push(a),e.peekToken(0).Type==m.COMMA&&e.skipToken(1)}return r}throw"Error parsing function argument table: Unexpected character"}}class qr extends Fe{constructor(e,r){super();s(this,"name");s(this,"args");this.name=e,this.args=r}static parse(e){if(e.peekToken(0).isDataType()&&e.peekToken(1).Type==m.LEFTSAMLL){let r=e.peekToken(0).Literal;e.skipToken(1);let a=zi.parse(e);return new qr(r,a)}throw"Error parsing function argument table: Unexpected character"}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r);if(this.name=="texture"&&this.args.args[0].nodes[0]instanceof qr){let o=this.args.args[0].nodes[0];if(o.name=="sampler2D"){a+=i+"textureSample(";for(let l=0;l<o.args.args.length;l++){let h=o.args.args[l];l>0&&(a+=", "),a+=h.formatToWGSL(e,0)}for(let l=1;l<this.args.args.length;l++){let h=this.args.args[l];l>0&&(a+=", "),a+=h.formatToWGSL(e,0)}return a+=")",a}}a+=i+Ut(this.name)+"(";for(let o=0;o<this.args.args.length;o++){let l=this.args.args[o];o>0&&(a+=", "),a+=l.formatToWGSL(e,0)}return a+=")",a}}class Se extends Fe{constructor(e,r,a=new re){super();s(this,"type");s(this,"name");s(this,"arraySize");s(this,"hasIn");s(this,"hasOut");s(this,"hasConst");this.type=e,this.name=r,this.hasIn=!1,this.hasOut=!1,this.hasConst=!1,this.arraySize=a}static parse(e){let r=new Se("",""),a=e.peekToken(0);if(a.Type==m.CONST)e.skipToken(1),r.hasConst=!0;else if(a.Type==m.IN)e.skipToken(1),r.hasIn=!0;else if(a.Type==m.OUT)e.skipToken(1),r.hasOut=!0;else if(a.Type==m.INOUT)e.skipToken(1),r.hasIn=!0,r.hasOut=!0;else if(!a.isDataType())throw"Error parsing declaration expression: Unexpected character("+a.Literal+")";if(a=e.peekToken(0),a.isDataType()&&e.peekToken(1).Type==m.LEFTMEDI){if(r.type=a.Literal,e.skipToken(2),r.arraySize=re.parse(e),e.peekToken(0).Type==m.RIGHTMEDI&&e.skipToken(1),e.peekToken(0).Type!=m.IDENT)throw"Unexpected";r.name=e.peekToken(0).Literal,e.skipToken(1)}else if(a.isDataType()&&e.peekToken(1).Type==m.IDENT&&e.peekToken(2).Type==m.LEFTMEDI)r.type=e.peekToken(0).Literal,r.name=e.peekToken(1).Literal,e.skipToken(3),e.peekToken(0).Type==m.RIGHTMEDI?e.skipToken(1):(r.arraySize=re.parse(e),e.peekToken(0).Type==m.RIGHTMEDI&&e.skipToken(1));else if(a.isDataType()&&e.peekToken(1).Type==m.IDENT)r.type=e.peekToken(0).Literal,r.name=e.peekToken(1).Literal,e.skipToken(2);else throw"Error parsing declaration expression: Unexpected character("+a.Literal+")";if(a=e.peekToken(0),a.Type==m.SEMICOLON)return e.skipToken(1),r;if(a.Type==m.RIGHTSAMLL)return r;if(a.Type==m.ASSIGN){let i=e.peekToken(0);e.skipToken(1);let o=new mr(r.name),l=re.parse(e);return e.peekToken(0).Type==m.SEMICOLON&&e.skipToken(1),r.addNode(new wr(i,o,l)),r}else if(a.Type==m.COMMA){for(;e.peekToken(0).Type==m.COMMA&&e.peekToken(1).Type==m.IDENT;){let i=new Se(r.type,e.peekToken(1).Literal);r.addNode(i),e.skipToken(2),e.peekToken(0).Type==m.ASSIGN&&(e.skipToken(-1),i.addNode(re.parse(e)))}return r}throw"Error parsing declaration expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r);if(this.hasConst?a+=i+"let ":a+=i+"var ",e.addIdentifier(this.name,this.name),this.arraySize.nodes.length<=0?a+=this.name+": "+Ut(this.type):this.arraySize.nodes[0]instanceof Ur?a+=this.name+": array<"+Ut(this.type)+", "+this.arraySize.nodes[0].value+">":a+=this.name+": array<"+Ut(this.type)+", "+this.arraySize.nodes[0].formatToWGSL(e,0)+">",this.nodes.length>0&&this.nodes[0]instanceof wr)a+=" = "+this.nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof re&&this.nodes[0].nodes[0]instanceof wr)a+=" = "+this.nodes[0].nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof Se){a+=`;\r
`;for(let o of this.nodes)a+=o.formatToWGSL(e,r)+`;\r
`}else a+=`;\r
`;return a}}class $r extends Fe{constructor(e,r,a,i){super();s(this,"expression1");s(this,"condition");s(this,"expression2");s(this,"loopBody");this.expression1=e,this.condition=r,this.expression2=a,this.loopBody=i}static parse(e){if(e.peekToken(0).Type==m.FOR&&e.peekToken(1).Type==m.LEFTSAMLL){e.skipToken(2);let r;e.peekToken(0).Type==m.SEMICOLON?(e.skipToken(1),r=new re):e.peekToken(0).isDataType()&&e.peekToken(1).Type==m.IDENT&&e.peekToken(2).Type==m.ASSIGN?(r=new Se(e.peekToken(0).Literal,e.peekToken(1).Literal),e.skipToken(1),r.addNode(re.parse(e)),e.peekToken(0).Type==m.SEMICOLON&&e.skipToken(1)):(r=re.parse(e),e.peekToken(0).Type==m.SEMICOLON&&e.skipToken(1));let a;e.peekToken(0).Type==m.SEMICOLON?(e.skipToken(1),a=new re):(a=re.parse(e),e.peekToken(0).Type==m.SEMICOLON&&e.skipToken(1));let i;e.peekToken(0).Type==m.SEMICOLON?(e.skipToken(1),i=new re):(i=re.parse(e),e.peekToken(0).Type==m.SEMICOLON&&e.skipToken(1)),e.peekToken(0).Type==m.RIGHTSAMLL&&e.skipToken(1);let o;return e.peekToken(0).Type==m.LEFTBIG?o=Lt.parse(e):o=new Lt,new $r(r,a,i,o)}throw"Error parsing for loop: Unexpected character"}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r);a+=i+"for (",a+=this.expression1.formatToWGSL(e,0)+"; ",a+=this.condition.formatToWGSL(e,0)+"; ",a+=this.expression2.formatToWGSL(e,0)+")",a+=` { \r
`;for(let o of this.loopBody.nodes)a+=o.formatToWGSL(e,r+1),!(o instanceof ia)&&!(o instanceof ea)&&!(o instanceof $r)&&(a+=`;\r
`);return a+=i+`} \r
`,a}}class ea extends Fe{constructor(e,r){super();s(this,"conditionExpr");s(this,"loopBody");this.conditionExpr=e,this.loopBody=r}static parse(e){if(e.peekToken(0).Type==m.WHILE){e.skipToken(1),e.peekToken(0).Type==m.LEFTSAMLL&&e.skipToken(1);let r=re.parse(e);e.peekToken(0).Type==m.RIGHTSAMLL&&e.skipToken(1);let a=Lt.parse(e);return new ea(r,a)}throw"Error parsing while loop: Unexpected character"}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r);a+=i+`loop {\r
`,a+=i+"    if ("+this.conditionExpr.formatToWGSL(e,0)+`) { break; }\r
\r
`;for(let o of this.loopBody.nodes)a+=o.formatToWGSL(e,r+1),!(o instanceof ia)&&!(o instanceof ea)&&!(o instanceof $r)&&(a+=`;\r
`);return a+=i+`}\r
`,a}}class ia extends Fe{constructor(e,r,a){super();s(this,"conditionExpr");s(this,"trueBranch");s(this,"falseBranch");this.conditionExpr=e,this.trueBranch=r,this.falseBranch=a}static parse(e){if(e.peekToken(0).Type==m.IF){e.skipToken(1),e.peekToken(0).Type==m.LEFTSAMLL&&e.skipToken(1);let r=re.parse(e),a,i=new Lt;if(e.peekToken(0).Type==m.RIGHTSAMLL&&e.skipToken(1),e.peekToken(0).Type==m.LEFTBIG?a=Lt.parse(e):(a=new Lt,e.peekToken(0).Type==m.RETURN?a.addNode(ii.parse(e)):a.addNode(re.parse(e))),e.peekToken(0).Type==m.ELSE)if(e.skipToken(1),e.peekToken(0).Type==m.LEFTBIG)i=Lt.parse(e);else throw"not impl";return new ia(r,a,i)}throw"Error parsing IF branch statement: Unexpected character"}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r);a+=i+"if ("+this.conditionExpr.formatToWGSL(e,0)+`) {\r
`;for(let o of this.trueBranch.nodes)a+=o.formatToWGSL(e,r+1)+`;\r
`;if(this.falseBranch.nodes.length>0){a+=i+`} else {\r
`;for(let o of this.falseBranch.nodes)a+=o.formatToWGSL(e,r+1)+`;\r
`}return a+=i+`}\r
`,a}}class re extends Fe{constructor(){super()}static parse(t){let e=new Array,r=new Array,a=0;for(;t.peekToken(0).Type!=m.EOF;){let i=t.peekToken(0);if(i.Type==m.SEMICOLON||i.Type==m.RIGHTMEDI||i.Type==m.COMMA||i.Type==m.COLON||i.Type==m.RIGHTBIG)break;if(i.isOperation()){if(i.isOperation()){if(i.Type==m.INC||i.Type==m.DEC){let o=i;t.skipToken(1);let l=re.parse(t);r.push(new oa(o,void 0,l));continue}else if(e.length>0){if(e[e.length-1].nOperationPriorityLevel<=i.nOperationPriorityLevel)re.unionOperation(e,r);else if(e.length>0&&e[e.length-1].Literal=="-"){let o=e.pop(),l=r.pop();r.push(new oa(o,void 0,l))}}e.push(i),t.skipToken(1)}}else if(i.Type==m.LITERAL){r.push(new Ur(i.Literal)),t.skipToken(1);continue}else if(i.Type==m.LEFTSAMLL){a++,e.push(i),t.skipToken(1);continue}else if(i.Type==m.RIGHTSAMLL){if(a<=0)break;for(a--;re.unionOperation(e,r););if(e[e.length-1].Type==m.LEFTSAMLL){e.pop();let o=new rh;o.addNode(r.pop()),r.push(o)}t.skipToken(1);continue}else if(i.Type==m.IDENT){if(t.peekToken(1).Type==m.INC||t.peekToken(1).Type==m.DEC){let o=t.peekToken(1),l=new mr(i.Literal);r.push(new oa(o,l,void 0)),t.skipToken(2);continue}else if(t.peekToken(1).Type==m.LEFTSAMLL){r.push(qr.parse(t));continue}else if(t.peekToken(1).Type==m.DOT){r.push(Ja.parse(t));continue}else if(t.peekToken(1).Type==m.LEFTMEDI){r.push(ta.parse(t));continue}r.push(new mr(i.Literal)),t.skipToken(1);continue}else{if(i.isBuiltinType()&&t.peekToken(1).Type==m.LEFTSAMLL){r.push(qr.parse(t));continue}if(i.isAssignOperation()){let o=i;t.skipToken(1);let l=r.pop(),h=re.parse(t);r.push(new wr(o,l,h));continue}if(i.Type==m.LEFTBIG&&(t.peekToken(1).Type==m.LITERAL||t.peekToken(1).Type==m.SUB&&t.peekToken(2).Type==m.LITERAL)){r.push(Wa.parse(t));continue}if(i.Type==m.QUEMARK){e.length>0&&e[e.length-1].nOperationPriorityLevel<=i.nOperationPriorityLevel&&re.unionOperation(e,r),t.skipToken(1);let o=r.pop(),l=re.parse(t);t.peekToken(0).Type==m.COLON&&t.skipToken(1);let h=re.parse(t);if(r.push(new ah(o,l,h)),t.peekToken(-1).Type==m.SEMICOLON)break;continue}if(i.Type==m.LEFTMEDI){t.skipToken(1);let o=re.parse(t);t.peekToken(0).Type==m.RIGHTMEDI&&t.skipToken(1);let l=r.pop();r.push(new ta(l,o));continue}throw"An unexpected character"}}for(;e.length>0&&re.unionOperation(e,r););if(e.length<=0&&r.length==1){let i=new re;return i.addNode(r.pop()),i}throw"Error parsing expression: Unexpected character("+t.peekToken(0).Literal+")"}formatToWGSL(t,e){return this.nodes[0].formatToWGSL(t,e)}static unionOperation(t,e){if(t.length<0||e.length<2){if(t.length>0&&t[t.length-1].Literal=="-"){let r=t.pop(),a=e.pop();return e.push(new oa(r,void 0,a)),!0}return!1}if(t[t.length-1].isOperation()){let r=e.pop(),a=t.pop(),i=e.pop();return a.Type==m.DOT?e.push(new Ja(i,r)):e.push(new wr(a,i,r)),!0}return!1}}class rh extends Fe{constructor(){super()}formatToWGSL(t,e){return(e<=0?"":"    ".repeat(e))+"("+this.nodes[0].formatToWGSL(t,0)+")"}}class mr extends Fe{constructor(e){super();s(this,"name");this.name=e}formatToWGSL(e,r){return(r<=0?"":"    ".repeat(r))+e.findIdentifier(this.name)}}class Ur extends Fe{constructor(e){super();s(this,"value");this.value=e}static parse(e){let r=e.peekToken(0);if(r.Type==m.SUB&&e.peekToken(1).Type==m.LITERAL){let a=new Ur("-"+e.peekToken(1).Literal);return e.skipToken(2),a}else if(r.Type==m.LITERAL){let a=new Ur(r.Literal);return e.skipToken(1),a}throw"Error parsing literal constants: Unexpected characters("+r.Literal+")"}formatToWGSL(e,r){return(r<=0?"":"    ".repeat(r))+this.value}}class Wa extends Ur{constructor(e){super("");s(this,"arrayValue");this.arrayValue=e}static parse(e){if(e.peekToken(0).Type==m.LEFTBIG&&e.peekToken(1).Type==m.LITERAL||e.peekToken(0).Type==m.LEFTBIG&&e.peekToken(1).Type==m.SUB&&e.peekToken(2).Type==m.LITERAL){e.skipToken(1);let r=[];for(;e.peekToken(0).Type!=m.RIGHTBIG;){if(e.peekToken(0).Type==m.LEFTSAMLL){r.push(Wa.parse(e));continue}if(r.push(Ur.parse(e)),e.peekToken(0).Type==m.COMMA){e.skipToken(1);continue}else if(e.peekToken(0).Type==m.RIGHTBIG){e.skipToken(1);break}else throw"Error parsing array constants: Unexpected characters"}return new Wa(r)}throw"Error parsing array constants: Unexpected characters"}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r);this.arrayValue[0].value.includes(".")?a+=i+"array<f32, "+this.arrayValue.length.toString()+">(":a+=i+"array<i32, "+this.arrayValue.length.toString()+">(";for(let o=0;o<this.arrayValue.length;o++)o>0&&(a+=", "),a+=this.arrayValue[o].formatToWGSL(e,0);return a+=")",a}}class Zi extends Fe{constructor(){super()}static parse(t){if(t.peekToken(0).Type==m.CONTINUE&&t.peekToken(1).Type==m.SEMICOLON)return t.skipToken(2),new Zi;throw"Error parsing continue: Unexpected character"}formatToWGSL(t,e){let r="",a=e<=0?"":"    ".repeat(e);return r+=a+"continue",r}}class ii extends Fe{constructor(e){super();s(this,"value");this.value=e}static parse(e){if(e.peekToken(0).Type==m.RETURN){e.skipToken(1);let r=re.parse(e);return e.peekToken(0).Type==m.SEMICOLON&&e.skipToken(1),new ii(r)}throw"Error parsing return expression: Unexpected character"}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r);return a+=i+"return "+this.value.formatToWGSL(e,0),a}}class oa extends Fe{constructor(e,r,a){super();s(this,"op");s(this,"leftValue");s(this,"rightValue");this.op=e,this.leftValue=r,this.rightValue=a}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r);if(this.op.Literal=="++"||this.op.Literal=="--")if(this.leftValue!=null){let o=this.leftValue.formatToWGSL(e,0);a+=i+o+" = "+o+" "+this.op.Literal[0]+" 1"}else{let o=this.rightValue.formatToWGSL(e,0);a+=i+o+" = "+o+" "+this.op.Literal[0]+" 1"}else this.leftValue!=null?a+=i+this.leftValue.formatToWGSL(e,0)+this.op.Literal:a+=i+this.op.Literal+this.rightValue.formatToWGSL(e,0);return a}}class wr extends Fe{constructor(e,r,a){super();s(this,"op");s(this,"leftValue");s(this,"rightValue");this.op=e,this.leftValue=r,this.rightValue=a}formatToWGSL(e,r){let a="",i=r<=0?"":"    ".repeat(r);return a+=i+this.leftValue.formatToWGSL(e,0)+" "+this.op.Literal+" "+this.rightValue.formatToWGSL(e,0),a}}class ah extends Fe{constructor(e,r,a){super();s(this,"condition");s(this,"expression1");s(this,"expression2");this.condition=e,this.expression1=r,this.expression2=a}static parse(e){throw"Error parsing ternary operation expression: Unexpected character"}formatToWGSL(e,r){return""}}class Ja extends Fe{constructor(e,r){super();s(this,"leftValue");s(this,"rightValue");this.leftValue=e,this.rightValue=r}static parse(e){if(e.peekToken(0).Type==m.IDENT&&e.peekToken(1).Type==m.DOT&&e.peekToken(2).Type==m.IDENT){let r=new mr(e.peekToken(0).Literal),a=new mr(e.peekToken(2).Literal);return e.skipToken(3),new Ja(r,a)}throw"Error parsing selection expression: Unexpected character"}formatToWGSL(e,r){return(r<=0?"":"    ".repeat(r))+this.leftValue.formatToWGSL(e,0)+"."+this.rightValue.formatToWGSL(e,0)}}class ta extends Fe{constructor(e,r){super();s(this,"leftValue");s(this,"indexValue");this.leftValue=e,this.indexValue=r}static parse(e){if(e.peekToken(0).Type==m.IDENT&&e.peekToken(1).Type==m.LEFTMEDI){let r=new mr(e.peekToken(0).Literal);e.skipToken(2);let a=re.parse(e);e.peekToken(0).Type==m.RIGHTMEDI&&e.skipToken(1);let i=new ta(r,a);for(;e.peekToken(0).Type==m.LEFTMEDI;)e.skipToken(1),a=re.parse(e),e.peekToken(0).Type==m.RIGHTMEDI&&e.skipToken(1),i=new ta(i,a);return i}throw"Error parsing index expression: Unexpected character"}formatToWGSL(e,r){return(r<=0?"":"    ".repeat(r))+this.leftValue.formatToWGSL(e,0)+"["+this.indexValue.formatToWGSL(e,0)+"]"}}class Lt extends Fe{constructor(){super()}static parse(t){if(t.peekToken(0).Type==m.LEFTBIG){t.skipToken(1);let e=new Lt;for(let r=1;r>0&&t.peekToken(0).Type!=m.EOF;){let a=t.peekToken(0);if(a.Type==m.LEFTBIG){r++,t.skipToken(1);continue}if(a.Type==m.RIGHTBIG){r--,t.skipToken(1);continue}if(a.Type==m.SEMICOLON){t.skipToken(1);continue}if(a.isDataType()&&t.peekToken(1).Type==m.IDENT){e.addNode(Se.parse(t));continue}if(a.Type==m.CONST&&t.peekToken(1).isDataType()&&t.peekToken(2).Type==m.IDENT){e.addNode(Se.parse(t));continue}else if(a.Type==m.IDENT&&t.peekToken(1).Type==m.ASSIGN){e.addNode(re.parse(t)),t.peekToken(0).Type==m.SEMICOLON&&t.skipToken(1);continue}else if(a.Type==m.IDENT&&t.peekToken(1).Type==m.LEFTMEDI){let i=ta.parse(t);if(t.peekToken(0).Type==m.ASSIGN){let o=t.peekToken(0);t.skipToken(1);let l=re.parse(t);t.peekToken(0).Type==m.RIGHTMEDI&&t.skipToken(1),e.addNode(new wr(o,i,l));continue}e.addNode(i);continue}else if(a.Type==m.IDENT&&t.peekToken(1).Type==m.DOT){let i=re.parse(t);e.addNode(i);continue}else if(a.Type==m.IDENT&&t.peekToken(1).isAssignOperation()){let i=t.peekToken(1),o=new mr(a.Literal);t.skipToken(2);let l=re.parse(t);t.peekToken(0).Type==m.SEMICOLON&&t.skipToken(1),e.addNode(new wr(i,o,l));continue}else if(a.Type==m.IDENT&&(t.peekToken(1).Type==m.INC||t.peekToken(1).Type==m.DEC)&&t.peekToken(2).Type==m.SEMICOLON){let i=t.peekToken(1);e.addNode(new oa(i,new mr(a.Literal),void 0)),t.skipToken(3);continue}else if(a.Type==m.RETURN){e.addNode(ii.parse(t));continue}else if(a.Type==m.CONTINUE){e.addNode(Zi.parse(t));continue}else if(a.Type==m.WHILE){e.addNode(ea.parse(t));continue}else if(a.Type==m.FOR){e.addNode($r.parse(t));continue}else if(a.Type==m.IF){e.addNode(ia.parse(t));continue}else if(a.Type==m.IDENT&&t.peekToken(1).Type==m.LEFTSAMLL){e.addNode(qr.parse(t)),t.peekToken(0).Type==m.SEMICOLON&&t.skipToken(0);continue}throw"Error parsing block: Unexpected symbol("+a.Literal+")"}return e}throw"Error parsing block: Unexpected symbol"}}class Xi extends Fe{constructor(e,r){super();s(this,"type");s(this,"qualifier");this.type=r,this.qualifier=e}static parse(e){if(e.peekToken(0).Type==m.PRECISION&&e.peekToken(1).Type==m.IDENT&&e.peekToken(2).isBuiltinType()){let r=new Xi(e.peekToken(1).Literal,e.peekToken(2).Literal);return e.skipToken(3),e.peekToken(0).Type==m.SEMICOLON&&e.skipToken(1),r}throw"Error parsing precision qualifier: Unexpected character"}formatToWGSL(e,r){return""}}class si extends Fe{constructor(){super();s(this,"scope","");s(this,"qualifier",new Map)}addQualifier(e,r=""){this.qualifier.set(e,r)}static parse(e){if(e.peekToken(0).Type==m.LAYOUT&&e.peekToken(1).Type==m.LEFTSAMLL){let r=new si;e.skipToken(2);do if(e.peekToken(0).Type==m.IDENT){if(e.peekToken(1).Type==m.ASSIGN&&e.peekToken(2).Type==m.LITERAL){let a=e.peekToken(0).Literal,i=e.peekToken(2).Literal;if(r.addQualifier(a,i),e.skipToken(3),e.peekToken(0).Type==m.COMMA){e.skipToken(1);continue}let o=e.peekToken(0);o.Line=0}else if(e.peekToken(1).Type==m.RIGHTSAMLL){let a=e.peekToken(0).Literal;r.addQualifier(a,""),e.skipToken(1);break}else if(e.peekToken(1).Type==m.COMMA){let a=e.peekToken(0).Literal;r.addQualifier(a,""),e.skipToken(2);continue}}while(e.peekToken(0).Type!=m.RIGHTSAMLL);if(e.peekToken(0).Type==m.RIGHTSAMLL&&e.skipToken(1),r.scope=e.peekToken(0).Literal,e.skipToken(1),e.peekToken(0).Type==m.SEMICOLON)return e.skipToken(1),r;if(e.peekToken(0).isBuiltinType()&&e.peekToken(1).Type==m.IDENT&&e.peekToken(2).Type==m.SEMICOLON){let a=new Se(e.peekToken(0).Literal,e.peekToken(1).Literal);return r.addNode(a),e.skipToken(3),r}else if(e.peekToken(0).Type==m.IDENT&&e.peekToken(1).Type==m.LEFTBIG){let a=Ar.parse(e);return r.addNode(a),e.peekToken(0).Type==m.IDENT&&e.peekToken(1).Type==m.SEMICOLON&&(a.addNode(new Se(a.name,e.peekToken(0).Literal)),e.skipToken(2)),r}else throw"Error parsing layout qualifier type: Unexpected symbol("+e.peekToken(0).Literal+")"}throw"Error parsing layout qualifier: Unexpected symbol"}formatToWGSL(e,r){let a="";if(this.qualifier.size==1&&this.qualifier.has("location"))a+="@location("+this.qualifier.get("location")+") ";else if(this.qualifier.size==2&&this.qualifier.has("set")&&this.qualifier.has("binding"))a+="@group("+this.qualifier.get("set")+") @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size>=1&&this.qualifier.has("binding"))a+="@group(0) @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size==1&&this.qualifier.has("push_constant"))a+="@push_constant ";else if(this.qualifier.size>=1&&this.qualifier.has("local_size_x"))a+="@workgroup_size(",a+=this.qualifier.get("local_size_x")+", ",a+=this.qualifier.has("local_size_y")?this.qualifier.get("local_size_y")+", ":"1, ",a+=this.qualifier.has("local_size_z")?this.qualifier.get("local_size_z")+"":"1",a+=")";else if(this.nodes.length<=0)return"";let i=this.nodes[0];if(i instanceof Se){switch(i.type){case"sampler":case"texture2D":a+="var ";break;default:this.scope=="buffer"?e.stage=="compute"?a+="var<storage, read_write> ":a+="var<storage, read> ":a+="var<"+this.scope+"> ";break}e.addIdentifier(i.name,i.name),a+=i.name+": "+Ut(i.type)+`;\r
`}else if(i instanceof Ar){if(this.scope=="buffer"?e.stage=="compute"?a+="var<storage, read_write> ":a+="var<storage, read> ":a+="var<"+this.scope+"> ",i.nodes.length<=0){let o="unif"+e.layoutUniformCount.toString();for(;e.hasIdentifier(o);)e.layoutUniformCount++,o="unif"+e.layoutUniformCount.toString();for(let l of i.fields)e.addIdentifier(l.name,o+"."+l.name);a+=o+": "+i.name+`;\r
`,e.layoutUniformCount++}else{let o=i.nodes[0];a+=o.name+": "+o.type+`;\r
`}return a}return a}}function Ut(n){switch(n){case"int":return"i32";case"int[]":return"array<i32>";case"uint":return"u32";case"uint[]":return"array<u32>";case"float":return"f32";case"float[]":return"array<f32>";case"vec2":return"vec2<f32>";case"vec3":return"vec3<f32>";case"vec4":return"vec4<f32>";case"vec2[]":return"array<vec2<f32>>";case"vec3[]":return"array<vec3<f32>>";case"vec4[]":return"array<vec4<f32>>";case"ivec2":return"vec2<i32>";case"ivec3":return"vec3<i32>";case"ivec4":return"vec4<i32>";case"ivec2[]":return"array<vec2<i32>>";case"ivec3[]":return"array<vec3<i32>>";case"ivec4[]":return"array<vec4<i32>>";case"mat2":return"mat2x2<f32>";case"mat2x2":return"mat2x2<f32>";case"mat2x3":return"mat2x3<f32>";case"mat2x4":return"mat2x4<f32>";case"mat2[]":return"array<mat2x2<f32>>";case"mat2x2[]":return"array<mat2x2<f32>>";case"mat2x3[]":return"array<mat2x3<f32>>";case"mat2x4[]":return"array<mat2x4<f32>>";case"mat3":return"mat3x3<f32>";case"mat3x2":return"mat3x2<f32>";case"mat3x3":return"mat3x3<f32>";case"mat3x4":return"mat3x4<f32>";case"mat3[]":return"array<mat3x3<f32>>";case"mat3x2[]":return"array<mat3x2<f32>>";case"mat3x3[]":return"array<mat3x3<f32>>";case"mat3x4[]":return"array<mat3x4<f32>>";case"mat4":return"mat4x4<f32>";case"mat4x2":return"mat4x2<f32>";case"mat4x3":return"mat4x3<f32>";case"mat4x4":return"mat4x4<f32>";case"mat4[]":return"array<mat4x4<f32>>";case"mat4x2[]":return"array<mat4x2<f32>>";case"mat4x3[]":return"array<mat4x3<f32>>";case"mat4x4[]":return"array<mat4x4<f32>>";case"texture2D":return"texture_2d<f32>"}return n}class ih{constructor(t){s(this,"_lexer");s(this,"_rootNode");this._lexer=t,this._rootNode=new Fe,this.parse()}get lexer(){return this._lexer}parse(){for(;this.peekToken(0).Type!==m.EOF;){if(this.peekToken(0).Type==m.SEMICOLON){this.skipToken(1);continue}let t=this.parseStatement();t!==null&&this._rootNode.addNode(t)}}parseStatement(){let t=this.peekToken();if(t.Type==m.LAYOUT&&this.peekToken(1).Type==m.LEFTSAMLL)return si.parse(this._lexer);if(t.Type==m.STRUCT)return this.skipToken(1),Ar.parse(this._lexer);if((t.isBuiltinType()||t.Type==m.VOID)&&this.peekToken(1).Type==m.IDENT&&this.peekToken(2).Type==m.LEFTSAMLL)return Ji.parse(this._lexer);if(t.Type==m.CONST&&this.peekToken(1).isDataType())return Se.parse(this._lexer);if(t.isDataType()&&this.peekToken(1).Type==m.IDENT)return Se.parse(this._lexer);if(t.Type==m.OUT&&this.peekToken(1).isDataType()&&this.peekToken(2).Type==m.IDENT)return Se.parse(this._lexer);if(t.Type==m.PRECISION)return Xi.parse(this._lexer);throw"Error parsing statement: Unexpected character"}skipToken(t){this._lexer.skipToken(t)}peekToken(t=0){return this._lexer.peekToken(t)}getNextToken(){return this._lexer.GetNextToken()}get ASTRoot(){return this._rootNode}}class vi{static convertGLSL(t){var e=new eh(t),r=new ql(e),a=new ih(r),i=new th(a);return i.generateWGSL()}}s(vi,"VertexShader","VertexShader"),s(vi,"FragmentShader","FragmentShader");class Es{constructor(){s(this,"setID",0);s(this,"bindingID",0);s(this,"name","");s(this,"type","")}}class ys{constructor(){s(this,"name","");s(this,"type","");s(this,"locationID",0);s(this,"builtinName","")}isBuiltinAttribute(){return this.builtinName!=""}}class sh{constructor(){s(this,"uniformInfo",[]);s(this,"inputAttribute",[]);s(this,"outputAttribute",[]);s(this,"sourceCode","")}}var Dt=(n=>(n[n.vertex=0]="vertex",n[n.fragment=1]="fragment",n[n.computer=2]="computer",n))(Dt||{});class nh{constructor(){s(this,"blendMode",q.NONE);s(this,"depthCompare",tr.less_equal);s(this,"depthWriteEnabled",!0);s(this,"frontFace","ccw");s(this,"cullMode",nt.back);s(this,"topology",vo.triangle_list);s(this,"depthBias",10);s(this,"useLight",!1);s(this,"useProbe",!1);s(this,"acceptGI",!1);s(this,"acceptShadow",!1);s(this,"castShadow",!1);s(this,"castReflection",!0);s(this,"receiveEnv",!1);s(this,"renderLayer",1e3);s(this,"renderOrder",2e3);s(this,"unclippedDepth",!1);s(this,"transparent",!1);s(this,"multisample",0);s(this,"label");s(this,"useZ",!0);s(this,"splitTexture",!1);s(this,"alphaCutoff");s(this,"useFragDepth",!1);s(this,"writeMasks",[])}setFromMapValues(t){t.has("blendMode")&&(this.blendMode=this.convertBlendMode(t.get("blendMode"))),t.has("depthCompare")&&(this.depthCompare=t.get("depthCompare")),t.has("depthWriteEnabled")&&(this.depthWriteEnabled=t.get("depthWriteEnabled")),t.has("frontFace")&&(this.frontFace=t.get("frontFace")),t.has("cullMode")&&(this.cullMode=t.get("cullMode")),t.has("topology")&&(this.topology=t.get("topology")),t.has("depthBias")&&(this.depthBias=t.get("depthBias")),t.has("useLight")&&(this.useLight=t.get("useLight")),t.has("useProbe")&&(this.useProbe=t.get("useProbe")),t.has("acceptGI")&&(this.acceptGI=t.get("acceptGI")),t.has("acceptShadow")&&(this.acceptShadow=t.get("acceptShadow")),t.has("castShadow")&&(this.castShadow=t.get("castShadow")),t.has("receiveEnv")&&(this.receiveEnv=t.get("receiveEnv")),t.has("renderLayer")&&(this.renderLayer=t.get("renderLayer")),t.has("renderOrder")&&(this.renderOrder=t.get("renderOrder")),t.has("unclippedDepth")&&(this.unclippedDepth=t.get("unclippedDepth")),t.has("multisample")&&(this.multisample=t.get("multisample")),t.has("label")&&(this.label=t.get("label")),t.has("useZ")&&(this.useZ=t.get("useZ"))}convertBlendMode(t){switch(t){case"ABOVE":return q.ABOVE;case"ALPHA":return q.ALPHA;case"NORMAL":return q.NORMAL;case"ADD":return q.ADD;case"BELOW":return q.BELOW;case"ERASE":return q.ERASE;case"MUL":return q.MUL;case"SCREEN":return q.SCREEN;case"DIVD":return q.DIVD;case"SOFT_ADD":return q.SOFT_ADD}return q.NONE}}class oh extends kr{constructor(){super();s(this,"uniformNodes",[]);s(this,"_onChange",!0);this.bufferType=ir.MaterialDataUniformGPUBuffer}initDataUniform(e){this.uniformNodes=e;let r=0;for(const a in e){const i=e[a];i||console.error(a,"is empty"),r+=i.size*4}r=Math.floor(r/256+1)*256,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,r/4,null,"MaterialDataUniformGPUBuffer");for(const a in e){const i=e[a];i||console.error(a,"is empty");let o=this.memory.allocation_node(i.size*4);i.memoryInfo=o,i.bindOnChange=()=>this.onChange()}}onChange(){this._onChange=!0}apply(){if(this.uniformNodes.length!=0&&this._onChange){for(const e in this.uniformNodes)this.uniformNodes[e].update();super.apply(),this._onChange=!1}}}class Nt{static init(){this.renderShaderModulePool=new Map,this.renderShader=new Map}}s(Nt,"renderShaderModulePool"),s(Nt,"renderShader");const ti=class ti{constructor(){s(this,"reference")}static getInstance(){return this._ins||(this._ins=new ti),this._ins}attached(t,e){this.reference||(this.reference=new Map);let r=this.reference.get(t);r||(r=new Map),r.set(e,t),this.reference.set(t,r)}detached(t,e){let r=this.reference.get(t);r&&r.delete(e)}hasReference(t){let e=this.reference.get(t);return e?e.size>0:!1}getReferenceCount(t){let e=this.reference.get(t);return e?e.size:0}getReference(t){return this.reference.get(t)||null}};s(ti,"_ins");let ae=ti;class Si{static getSharePipeline(t){return this.pipelineMap.get(t)||null}static setSharePipeline(t,e){this.pipelineMap.set(t,e)}}s(Si,"pipelineMap",new Map);class _e extends en{constructor(e,r){super();s(this,"passType",W.COLOR);s(this,"useRz",!1);s(this,"vsName");s(this,"fsName");s(this,"shaderState");s(this,"textures");s(this,"pipeline");s(this,"bindGroupLayouts");s(this,"envMap");s(this,"prefilterMap");s(this,"reflectionMap");s(this,"_sourceVS");s(this,"_sourceFS");s(this,"_destVS");s(this,"_destFS");s(this,"_vsShaderModule");s(this,"_fsShaderModule");s(this,"_textureGroup",-1);s(this,"_textureChange",!1);s(this,"_groupsShaderReflectionVarInfos");s(this,"outBufferMask");s(this,"_cacheEntries");this.vsName=e.toLowerCase(),this.fsName=r.toLowerCase(),this.vsName in N||console.error("Shader Not Register, Please Register Shader!",this.vsName),this.fsName in N||console.error("Shader Not Register, Please Register Shader!",this.fsName),N[this.vsName]&&(this._sourceVS=N[this.vsName]),N[this.fsName]&&(this._sourceFS=N[this.fsName]),this.textures={},this.bindGroups=[],this.shaderState=new nh,this.materialDataUniformBuffer=new oh,this.materialDataUniformBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this._bufferDic.set("global",this.materialDataUniformBuffer),this._bufferDic.set("materialUniform",this.materialDataUniformBuffer)}get renderOrder(){return this.shaderState.renderOrder}set renderOrder(e){this.shaderState.renderOrder!=e&&(this._valueChange=!0),this.shaderState.renderOrder=e}get doubleSide(){return this.shaderState.cullMode==nt.none}set doubleSide(e){let r=e?nt.none:this.cullMode;this.shaderState.cullMode!=r&&(this._valueChange=!0),this.shaderState.cullMode=r}get depthWriteEnabled(){return this.shaderState.depthWriteEnabled}set depthWriteEnabled(e){this.shaderState.depthWriteEnabled!=e&&(this._valueChange=!0),this.shaderState.depthWriteEnabled=e}get cullMode(){return this.shaderState.cullMode}set cullMode(e){this.shaderState.cullMode!=e&&(this._valueChange=!0),this.shaderState.cullMode=e}get frontFace(){return this.shaderState.frontFace}set frontFace(e){this.shaderState.frontFace!=e&&(this._valueChange=!0),this.shaderState.frontFace=e}get depthBias(){return this.shaderState.depthBias}set depthBias(e){this.shaderState.depthBias!=e&&(this._valueChange=!0),this.shaderState.depthBias=e}get topology(){return this.shaderState.topology}set topology(e){this.shaderState.topology!=e&&(this._valueChange=!0),this.shaderState.topology=e}get blendMode(){return this.shaderState.blendMode}set blendMode(e){this.shaderState.blendMode!=e&&(this._valueChange=!0,e!=q.NORMAL&&e!=q.NONE&&(this.renderOrder=3e3)),this.shaderState.blendMode=e}get depthCompare(){return this.shaderState.depthCompare}set depthCompare(e){this.shaderState.depthCompare!=e&&(this._valueChange=!0),this.shaderState.depthCompare=e}setShaderEntry(e="",r=""){this.vsEntryPoint=e,this.fsEntryPoint=r}setUniform(e,r){super.setUniform(e,r),this.materialDataUniformBuffer.onChange()}setTexture(e,r){r&&this.textures[e]!=r&&(this.textures[e]&&this.textures[e].unBindStateChange(this),this._textureChange=!0,this.textures[e]=r,e=="envMap"?this.envMap=r:e=="prefilterMap"?this.prefilterMap=r:e=="reflectionMap"&&(this.reflectionMap=r),r.bindStateChange(()=>{this._textureChange=!0},this))}get baseColor(){return this.getUniform("baseColor")}set baseColor(e){this.setUniform("baseColor",e)}getTexture(e){return this.textures[e]}genRenderPipeline(e,r){let a=this.createGroupLayouts();this.createPipeline(e,r,a)}reBuild(e,r){this.compileShader(Dt.vertex,this._destVS,r),this.compileShader(Dt.fragment,this._destFS,r),this.genRenderPipeline(e,r)}apply(e,r,a){this.materialDataUniformBuffer.apply(),this._textureChange&&this._textureGroup!=-1&&(this._textureChange=!1,this.genGroups(this._textureGroup,this.shaderReflection.groups,!0)),this._valueChange&&(this._shaderChange&&(this.preCompile(e),this._shaderChange=!1),this.shaderVariant=ht.genRenderShaderVariant(this),this.reBuild(e,r),this._valueChange=!1,a&&a())}preCompile(e){this.preDefine(e),this.preCompileShader(Dt.vertex,this._sourceVS.concat()),this.preCompileShader(Dt.fragment,this._sourceFS.concat()),this.genReflection()}applyPostDefine(e,r){return r.renderTargetTextures.length>1?(this.defineValue.USE_WORLDPOS=!0,this.defineValue.USEGBUFFER=!0):(this.defineValue.USE_WORLDPOS=!1,this.defineValue.USEGBUFFER=!1),C.setting.render.useCompressGBuffer?this.defineValue.USE_COMPRESSGBUFFER=!0:this.defineValue.USE_COMPRESSGBUFFER=!1,Rr.parse(e,this.defineValue)}setBindGroup(e,r){this.bindGroups[e]=r}checkBuffer(e,r){}preCompileShader(e,r,a){let i=r;if(i.indexOf("version ")!=-1){var o=vi.convertGLSL(i);i=o.sourceCode}for(const l in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,l)){const h=this.constValues[l];i=i.replaceAll(`&${l}`,h.toString())}switch(e){case Dt.vertex:this._destVS=i;break;case Dt.fragment:this._destFS=i;break}}compileShader(e,r,a){let i=r;i=this.applyPostDefine(i,a);let o=r;for(let h in this.defineValue)o+=`${h}=${this.defineValue[h]},`;let l=Nt.renderShaderModulePool.get(o);switch(l||(i=this.applyPostDefine(i,a),l=R.device.createShaderModule({label:e==Dt.vertex?this.vsName:this.fsName,code:i}),l.getCompilationInfo().then(h=>{h.messages.length>0&&(console.log(i),console.log(h))}),Nt.renderShaderModulePool.set(o,l)),e){case Dt.vertex:this._vsShaderModule=l,this._destVS=i;break;case Dt.fragment:this._fsShaderModule=l,this._destFS=i;break}}getGroupLayout(e,r){let a=[];for(let i=0;i<r.length;i++){const o=r[i];if(o)if(o.varType=="uniform"){this._bufferDic.has(o.varName)||console.error(`not set ${o.varName} buffer`);let l=this._bufferDic.get(o.varName).visibility,h={binding:o.binding,visibility:l,buffer:{type:"uniform"}};a.push(h)}else if(o.varType=="storage-read"){this._bufferDic.has(o.varName)||console.error(`not set ${o.varName} buffer`);let l=this._bufferDic.get(o.varName).visibility,h={binding:o.binding,visibility:l,buffer:{type:"read-only-storage"}};a.push(h)}else if(o.varType=="var")switch(o.dataType){case"sampler":{let l=o.varName.replace("Sampler",""),h=this.textures[l]?this.textures[l]:C.res.redTexture,c={binding:o.binding,visibility:h.visibility,sampler:h.samplerBindingLayout};a.push(c),this._textureGroup=e}break;case"sampler_comparison":{let l=o.varName.replace("Sampler",""),h=this.textures[l]?this.textures[l]:C.res.redTexture,c={binding:o.binding,visibility:h.visibility,sampler:h.sampler_comparisonBindingLayout};a.push(c),this._textureGroup=e}break;case"texture_2d<f32>":case"texture_2d_array<f32>":case"texture_cube<f32>":case"texture_depth_2d":case"texture_depth_2d_array":case"texture_depth_cube":case"texture_depth_cube_array":{let l=this.textures[o.varName]?this.textures[o.varName]:C.res.redTexture,h={binding:o.binding,visibility:l.visibility,texture:l.textureBindingLayout};a.push(h),this._textureGroup=e,ae.getInstance().attached(l,this)}break;case"texture_external":{let l=this.textures[o.varName]?this.textures[o.varName]:C.res.redTexture,h={binding:o.binding,visibility:l.visibility,externalTexture:{}};a.push(h),this._textureGroup=e,ae.getInstance().attached(l,this)}break;default:{let l=this.textures[o.varName]?this.textures[o.varName]:C.res.redTexture,h={binding:o.binding,visibility:l.visibility,texture:l.textureBindingLayout};a.push(h),this._textureGroup=e,ae.getInstance().attached(l,this)}break}else{debugger;console.error("bind group can't empty")}}return a}genGroups(e,r,a=!1){if(!this.bindGroups[e]||a){const i=r[e];let o=[];for(let h=0;h<i.length;h++){const c=i[h];if(c){if(c.varType=="uniform"){let u=this._bufferDic.get(c.varName);if(u){if(u.bufferType==ir.MaterialDataUniformGPUBuffer){let f=[];for(let A=0;A<c.dataFields.length;A++){const p=c.dataFields[A];this.uniforms[p.name]||console.error(`shader-${this.vsName}:${this.fsName} ${p.name}is empty`),f.push(this.uniforms[p.name])}this.materialDataUniformBuffer.initDataUniform(f)}let d={binding:c.binding,resource:{buffer:u.buffer,offset:0,size:u.memory.shareDataBuffer.byteLength}};o.push(d),this.checkBuffer(c.varName,u)}else console.error(`shader${this.vsName}-${this.fsName}`,`buffer ${c.varName} is missing!`)}else if(c.varType=="storage-read"){let u=this._bufferDic.get(c.varName);if(u){let d={binding:c.binding,resource:{buffer:u.buffer,offset:0,size:u.memory.shareDataBuffer.byteLength}};o.push(d),this.checkBuffer(c.varName,u)}else console.error(`buffer ${c.varName} is missing!`)}else if(c.varType=="var")if(c.dataType=="sampler"){let u=c.varName.replace("Sampler",""),d=this.textures[u];if(d||(d=C.res.blackTexture,this.setTexture(u,d)),d){let f={binding:c.binding,resource:d.gpuSampler};o.push(f)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${c.varName} is missing! `)}else if(c.dataType=="sampler_comparison"){let u=c.varName.replace("Sampler",""),d=this.textures[u];if(d){let f={binding:c.binding,resource:d.gpuSampler_comparison};o.push(f)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${c.varName} is missing! `)}else{let u=this.textures[c.varName];if(u||(u=C.res.whiteTexture,this.setTexture(c.varName,u)),u){let d={binding:c.binding,resource:u.getGPUView()};o.push(d)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${c.varName} is missing! `)}}}let l=R.device.createBindGroup({layout:this.bindGroupLayouts[e],entries:o});this.bindGroups[e]=l}}createPipeline(e,r,a){let i=e,o=this.shaderState,l=[];for(const u of r.renderTargetTextures)l.push({format:u.format});for(let u=0;u<l.length;u++){const d=l[u];o.writeMasks&&o.writeMasks.length>0&&(d.writeMask=o.writeMasks[u])}if(r.outColor!=-1){let u=l[r.outColor];o.blendMode!=q.NONE?u.blend=Kl.getBlend(o.blendMode):delete u.blend}let h={label:this.vsName+"|"+this.fsName,layout:a,primitive:{topology:o.topology,cullMode:o.cullMode,frontFace:o.frontFace},vertex:void 0};this.vsEntryPoint!=""&&(h.vertex={module:this._vsShaderModule,entryPoint:this.vsEntryPoint,buffers:i.vertexBuffer.vertexBufferLayouts}),this.fsEntryPoint!=""&&(h.fragment={module:this._fsShaderModule,entryPoint:this.fsEntryPoint,targets:l}),o.multisample>0&&(h.multisample={count:o.multisample}),(r.zPreTexture||r.depthTexture)&&(o.blendMode!=q.NONE,C.setting.render.zPrePass&&r.zPreTexture&&o.useZ?h.depthStencil={depthWriteEnabled:!1,depthCompare:tr.less,format:r.zPreTexture.format}:h.depthStencil={depthWriteEnabled:o.depthWriteEnabled,depthCompare:o.depthCompare,format:r.depthTexture.format});let c=Si.getSharePipeline(this.shaderVariant);c?this.pipeline=c:(this.pipeline=S.createPipeline(h),Si.setSharePipeline(this.shaderVariant,this.pipeline))}createGroupLayouts(){this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroupLayouts=[Wi.getGlobalDataBindGroupLayout()];for(let a=1;a<e.groups.length;a++){let i=e.groups[a];if(i){let o=this.getGroupLayout(a,i);this._groupsShaderReflectionVarInfos[a]=i;let l=R.device.createBindGroupLayout({entries:o,label:`vs${this.vsName} fs${this.fsName} ${i.length}`});this.bindGroupLayouts[a]=l}else console.error("can't set empty group!",a)}let r=R.device.createPipelineLayout({bindGroupLayouts:this.bindGroupLayouts});return this._groupsShaderReflectionVarInfos[0],this._groupsShaderReflectionVarInfos[1]&&this.genGroups(1,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[2]&&this.genGroups(2,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[3]&&this.genGroups(3,this._groupsShaderReflectionVarInfos),r}preDefine(e){let r=e.hasAttribute(k.TEXCOORD_1),a=e.hasAttribute(k.joints0),i=e.hasAttribute(k.a_morphPositions_0),o=e.hasAttribute(k.TANGENT),l=e.hasAttribute(k.color),h=this.shaderState.acceptGI,c=this.shaderState.useLight;r&&(this.defineValue.USE_SECONDUV=!0),a&&i?this.defineValue.USE_METAHUMAN=!0:(this.defineValue.USE_SKELETON=a,this.defineValue.USE_MORPHTARGETS=i),"USE_TANGENT"in this.defineValue||(this.defineValue.USE_TANGENT=o),this.defineValue.USE_GI=h,this.defineValue.USE_SHADOWMAPING=this.shaderState.acceptShadow,this.defineValue.USE_LIGHT=c,this.defineValue.USE_VERTXCOLOR=l,C.setting.pick.mode=="pixel"&&(this.defineValue.USE_WORLDPOS=!0),C.setting.gi.enable?this.defineValue.USEGI=!0:this.defineValue.USEGI=!1,C.setting.render.debug&&(this.defineValue.USE_DEBUG=!0,this.defineValue.DEBUG_CLUSTER=!0),this.shaderState.useLight?this.defineValue.USE_LIGHT=!0:this.defineValue.USE_LIGHT=!1,C.setting.render.useLogDepth?(this.defineValue.USE_LOGDEPTH=!0,this.shaderState.useFragDepth=!0):this.defineValue.USE_LOGDEPTH=!1,this.shaderState.useFragDepth?this.defineValue.USE_OUTDEPTH=!0:this.defineValue.USE_OUTDEPTH=!1,this.defineValue.USE_PCF_SHADOW=C.setting.shadow.type=="PCF",this.defineValue.USE_HARD_SHADOW=C.setting.shadow.type=="HARD",this.defineValue.USE_SOFT_SHADOW=C.setting.shadow.type=="SOFT",this.defineValue.USE_CSM=zt.Cascades>1,this.defineValue.USE_IES_PROFILE=Ua.use}genReflection(){this.shaderVariant=ht.genRenderShaderVariant(this);let e=ht.poolGetReflection(this.shaderVariant);if(e)this.shaderReflection=e;else{let r=Rr.parse(this._destVS,this.defineValue);r=Rr.parse(r,this.defineValue),ht.getShaderReflection2(r,this);let a=Rr.parse(this._destFS,this.defineValue);a=Rr.parse(a,this.defineValue),ht.getShaderReflection2(a,this),ht.final(this)}this.shaderState.splitTexture=this.shaderReflection.useSplit}destroy(e){for(const r in this.textures)if(Object.prototype.hasOwnProperty.call(this.textures,r)){const a=this.textures[r];ae.getInstance().detached(a,this),e&&!ae.getInstance().hasReference(a)?a.destroy(e):a.destroy(!1)}this.bindGroups.length=0,this.shaderState=null,this.textures=null,this.pipeline=null,this.bindGroupLayouts=null,this._sourceVS=null,this._sourceFS=null,this._destVS=null,this._destFS=null,this._vsShaderModule=null,this._fsShaderModule=null,this.materialDataUniformBuffer.destroy(),this.materialDataUniformBuffer=null}static destroyShader(e){Nt.renderShader.has(e)&&(Nt.renderShader.get(e).destroy(),Nt.renderShader.delete(e))}static getShader(e){return Nt.renderShader.get(e)}static createShader(e,r){let a=new _e(e,r);return Nt.renderShader.set(a.instanceID,a),a.instanceID}}class lh extends _e{constructor(){super("sky_vs_frag_wgsl","SkyGBuffer_fs"),this.passType=W.GI,this.setUniformVector3("eyesPos",new g),this.setUniformFloat("exposure",1),this.setUniformFloat("roughness",0);let t=this.shaderState;t.frontFace="ccw",t.cullMode=nt.front,t.depthWriteEnabled=!1,t.depthCompare=tr.less_equal}}class hh extends _e{constructor(){super("gbuffer_vs","gbuffer_fs");s(this,"transparency");this.setShaderEntry("VertMain","FragMain"),this.passType=W.GI,this.setUniformColor("baseColor",new Y),this.setUniformColor("emissiveColor",new Y),this.setUniformFloat("emissiveIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("alphaCutoff",1),this.blendMode=q.NONE,this.setTexture("normalMap",C.res.normalTexture)}}class ch extends _e{constructor(){super("shadowCastMap_vert","directionShadowCastMap_frag"),this.passType=W.SHADOW,this.setShaderEntry("main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",g.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class uh extends _e{constructor(){super("castPointShadowMap_vert","shadowCastMap_frag"),this.passType=W.POINT_SHADOW,this.setShaderEntry("main","main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",g.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class dh extends _e{constructor(){super("ZPass_shader_vs","ZPass_shader_vs"),this.passType=W.DEPTH,this.setShaderEntry("main"),this.useRz=!1;let t=this.shaderState;t.receiveEnv=!1}}class ya{static createGIPass(t,e){if(Mt.hasMask(t.rendererMask,de.Sky)){if(!e.passShader.get(W.GI)){let r=e.getSubShaders(W.COLOR)[0],a=new lh;a.setTexture("baseMap",r.getTexture("baseMap")),a.cullMode=r.cullMode,a.frontFace=r.frontFace,e.addRenderPass(a,0),a.preCompile(t.geometry)}}else this.castGBufferPass(t,e)}static castGBufferPass(t,e){let r=e.getDefaultShaders();for(let a=0;a<r.length;a++){const i=r[a];let o=e.getSubShaders(W.GI);if(!o||o.length==0||o.length<a){let l=new hh;l.setTexture("baseMap",i.getTexture("baseMap")),l.setTexture("normalMap",i.getTexture("normalMap")),l.setTexture("emissiveMap",i.getTexture("emissiveMap")),l.setUniform("baseColor",i.getUniform("baseColor")),l.setUniform("envIntensity",i.getUniform("envIntensity")),l.setUniform("emissiveColor",i.getUniform("emissiveColor")),l.setUniform("emissiveIntensity",i.getUniform("emissiveIntensity")),l.setUniform("alphaCutoff",i.getUniform("alphaCutoff")),l.cullMode=i.cullMode,l.frontFace=i.frontFace,l.preCompile(t.geometry),e.addRenderPass(l)}}}static createShadowPass(t,e){let r=Mt.hasMask(t.rendererMask,de.SkinnedMesh),a=t.geometry.hasAttribute(k.TANGENT),i=t.geometry.hasAttribute(le.MORPH_POSITION_PREFIX+"0"),o=t.geometry.hasAttribute(le.MORPH_NORMAL_PREFIX+"0"),l=e.getSubShaders(W.COLOR);for(let h=0;h<l.length;h++){const c=l[h];let u=e.getSubShaders(W.SHADOW);if(!u||u.length<h+1){let f=new ch;f.setTexture("baseMap",c.getTexture("baseMap")),f.setUniform("alphaCutoff",c.getUniform("alphaCutoff")),a&&f.setDefine("USE_TANGENT",a),r&&f.setDefine("USE_SKELETON",r),i&&f.setDefine("USE_MORPHTARGETS",i),o&&f.setDefine("USE_MORPHNORMALS",o),f.preCompile(t.geometry),e.addRenderPass(f)}let d=e.getSubShaders(W.POINT_SHADOW);if(!d||d.length<h+1){let f=new uh;f.setTexture("baseMap",c.getTexture("baseMap")),f.setUniform("alphaCutoff",c.getUniform("alphaCutoff")),f.setDefine("USE_ALPHACUT",1);for(let A=0;A<1;A++)a&&f.setDefine("USE_TANGENT",a),r&&f.setDefine("USE_SKELETON",r),i&&f.setDefine("USE_MORPHTARGETS",i),o&&f.setDefine("USE_MORPHNORMALS",o),f.shaderState.cullMode="front",f.preCompile(t.geometry);e.addRenderPass(f)}}}static createDepthPass(t,e){let r=e.getSubShaders(W.COLOR),a=t.geometry.hasAttribute("TANGENT"),i=t.geometry.hasAttribute(le.MORPH_POSITION_PREFIX+"0"),o=t.geometry.hasAttribute(le.MORPH_NORMAL_PREFIX+"0"),l=Mt.hasMask(t.rendererMask,de.SkinnedMesh);for(let h=0;h<r.length;h++){const c=r[h];let u=e.getSubShaders(W.DEPTH);if(!u&&c.shaderState.useZ&&(!u||u.length<h)){let d=new dh;d.setTexture("baseMap",c.getTexture("baseMap")),a||d.setDefine("USE_TANGENT",a),l&&d.setDefine("USE_SKELETON",l),i&&d.setDefine("USE_MORPHTARGETS",i),o&&d.setDefine("USE_MORPHNORMALS",o),d.cullMode=c.cullMode,d.frontFace=c.frontFace,d.preCompile(t.geometry),e.addRenderPass(d)}}}static createReflectionPass(t,e){let r=e.getDefaultShaders();for(let l=0;l<r.length;l++){const h=r[l];let c=e.getSubShaders(W.REFLECTION);if(!c||c.length==0||c.length<l){let u=new _e(h.vsName,h.fsName);u.vsEntryPoint=h.vsEntryPoint,u.fsEntryPoint=h.fsEntryPoint,u.passType=W.REFLECTION;for(const d in h.shaderState){var a=h.shaderState[d];u.shaderState[d]=a}for(const d in h.textures){var i=h.getTexture(d);u.setTexture(d,i)}for(const d in h.uniforms){var o=h.getUniform(d);u.setUniform(d,o)}for(const d in h.defineValue){var o=h.defineValue[d];u.setDefine(d,o)}u.setDefine("USE_CASTREFLECTION",!0),u.preCompile(t.geometry),e.addRenderPass(u)}}}}class fh{constructor(t){s(this,"renderer");s(this,"owner");s(this,"uuid");this.renderer=t,this.uuid=t.object3D.instanceID}leaveNode(){this.owner&&(this.owner.entities.delete(this.uuid),this.owner=null)}enterNode(t){this.owner&&this.leaveNode(),this.owner=t,t.entities.set(this.uuid,this)}update(t){var e;return(e=this.owner)!=null&&e.tryInsertEntity(this)||(this.leaveNode(),t.tryInsertEntity(this)),this.owner}}var Ah=Object.defineProperty,gh=Object.getOwnPropertyDescriptor,ui=(n,t,e,r)=>{for(var a=gh(t,e),i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(t,e,a)||a);return a&&Ah(t,e,a),a};class da extends ut{constructor(){super(...arguments);s(this,"instanceCount",0);s(this,"lodLevel",0);s(this,"alwaysRender",!1);s(this,"instanceID");s(this,"drawType",0);s(this,"_geometry");s(this,"_materials",[]);s(this,"_castShadow",!0);s(this,"_castReflection",!0);s(this,"_castGI",!1);s(this,"_rendererMask",de.Default);s(this,"_inRenderer",!1);s(this,"_readyPipeline",!1);s(this,"_combineShaderRefection");s(this,"_ignoreEnvMap");s(this,"_ignorePrefilterMap");s(this,"__renderOrder",0);s(this,"_renderOrder",0);s(this,"_passInit",new Map);s(this,"isRenderOrderChange");s(this,"needSortOnCameraZ");s(this,"isRecievePostEffectUI");s(this,"_octreeBinder");s(this,"_renderLayer",Ga.None);s(this,"_computes")}init(e){this.renderOrder=0,this.rendererMask=de.Default,this.instanceID=qs().toString(),this._computes=[]}attachSceneOctree(e){this._octreeBinder={octree:e,entity:new fh(this)},this.transform.eventDispatcher.addEventListener(Jt.LOCAL_ONCHANGE,this.updateOctreeEntity,this)}detachSceneOctree(){var e;this._octreeBinder&&((e=this._octreeBinder.entity)==null||e.leaveNode(),this.transform.eventDispatcher.removeEventListener(Jt.LOCAL_ONCHANGE,this.updateOctreeEntity,this),this._octreeBinder=null)}updateOctreeEntity(e){var r,a;(a=(r=this._octreeBinder)==null?void 0:r.entity)==null||a.update(this._octreeBinder.octree)}copyComponent(e){return super.copyComponent(e),this.geometry=e._geometry,this.materials=e._materials.slice(),this.drawType=e.drawType,this.alwaysRender=e.alwaysRender,this.needSortOnCameraZ=e.needSortOnCameraZ,this.isRenderOrderChange=e.isRenderOrderChange,this.castShadow=e.castShadow,this.castGI=e.castGI,this.rendererMask=e.rendererMask,this.isRecievePostEffectUI=e.isRecievePostEffectUI,this}get renderLayer(){return this._renderLayer}set renderLayer(e){this._renderLayer=e}get geometry(){return this._geometry}set geometry(e){this._geometry!=e&&(this._readyPipeline=!1,this._geometry&&ae.getInstance().detached(this._geometry,this),e&&ae.getInstance().attached(e,this)),this._geometry=e}addMask(e){this._rendererMask=Mt.addMask(this.rendererMask,e)}removeMask(e){this._rendererMask=Mt.removeMask(this.rendererMask,e)}hasMask(e){return Mt.hasMask(this.rendererMask,e)}get rendererMask(){return this._rendererMask}set rendererMask(e){this._rendererMask=e}get renderOrder(){return this._renderOrder}set renderOrder(e){e!=this._renderOrder&&(this.isRenderOrderChange=!0,this.__renderOrder=e),this._renderOrder=e}get materials(){return this._materials}set materials(e){this._readyPipeline=!1;for(let a=0;a<this._materials.length;a++){let i=this._materials[a];ae.getInstance().detached(i,this),i.shader&&i.shader.computes&&this.removeComputes(i.shader.computes)}for(let a=0;a<e.length;a++){let i=e[a];ae.getInstance().attached(i,this),i.shader&&i.shader.computes&&this.addComputes(i.shader.computes)}this._materials=e;let r=0;for(let a=0;a<e.length;a++){const i=e[a].getPass(W.COLOR)[0];i.shaderState.transparent&&(r=r>i.renderOrder?r:i.renderOrder)}this.renderOrder=r,this._readyPipeline||this.initPipeline()}addComputes(e){this._computes.push(...e)}removeComputes(e){for(const r of e){let a=this._computes.indexOf(r);a!=-1&&this._computes.splice(a,1)}}addRendererMask(e){this._rendererMask=Mt.addMask(this._rendererMask,e)}removeRendererMask(e){this._rendererMask=Mt.removeMask(this._rendererMask,e)}onEnable(){this._readyPipeline||this.initPipeline(),P.instance.addRenderNode(this.transform.scene3D,this),this.updateOctreeEntity()}onDisable(){var e;this._enable=!1,P.instance.removeRenderNode(this.transform.scene3D,this),(e=super.onDisable)==null||e.call(this)}selfCloneMaterials(e){let r=[];for(let a=0,i=this.materials.length;a<i;a++){const o=this.materials[a].clone();r.push(o)}return this.materials=r,this._readyPipeline=!1,this.initPipeline(),this}initPipeline(){if(this._geometry&&this._materials.length>0){for(let r=0;r<this._materials.length;r++){let a=this._materials[r].getPass(W.COLOR);for(let i=0;i<a.length;i++){const o=a[i];o.shaderReflection||o.preCompile(this._geometry),this._geometry.generate(o.shaderReflection)}this.object3D.bound=this._geometry.bounds.clone()}this._readyPipeline=!0;let e=0;for(let r=0;r<this.materials.length;r++){const a=this.materials[r].getPass(W.COLOR)[0];a.renderOrder>=3e3?e=e>a.renderOrder?e:a.renderOrder:e=Math.max(e-3e3,0),this.castNeedPass()}this.renderOrder=e,this.enable&&this.transform&&this.transform.scene3D&&P.instance.addRenderNode(this.transform.scene3D,this)}}castNeedPass(){if(this.castGI)for(let e=0;e<this.materials.length;e++){const r=this.materials[e];ya.createGIPass(this,r.shader)}for(let e=0;e<this.materials.length;e++){const r=this.materials[e];r.castShadow&&ya.createShadowPass(this,r.shader)}if(this.castReflection)for(let e=0;e<this.materials.length;e++){const r=this.materials[e];r.castReflection&&ya.createReflectionPass(this,r.shader)}if(!Mt.hasMask(this.rendererMask,de.IgnoreDepthPass)&&C.setting.render.zPrePass)for(let e=0;e<this.materials.length;e++){const r=this.materials[e];ya.createDepthPass(this,r.shader)}else for(let e=0;e<this.materials.length;e++)this.materials[e].shader.removeShaderByIndex(W.DEPTH,0)}get castShadow(){return this._castShadow}set castShadow(e){this._castShadow=e}get castGI(){return this._castGI}set castGI(e){this._castGI=e}get castReflection(){return this._castReflection}set castReflection(e){this._castReflection=e}renderPass(e,r,a){if(!this._geometry)return;let i=this,o=i.transform._worldMatrix;const l=Math.max(i.materials.length,i._geometry.subGeometries.length);for(let h=0;h<l;h++){const c=h>=i.materials.length?i.materials[0]:i.materials[h];if(!c||!c.enable)continue;let u=c.getPass(r);if(!(!u||u.length==0)){S.bindGeometryBuffer(a.encoder,i._geometry),ve.viewCount_vertex(e,W[r],i._geometry.vertexCount);for(let d=0;d<u.length;d++){if(!u||u.length==0)continue;const f=u[d];if(f.pipeline){f.shaderState.splitTexture&&(a.endRenderPass(),xt.WriteSplitColorTexture(i.instanceID),a.beginOpaqueRenderPass(),S.bindCamera(a.encoder,e.camera),S.bindGeometryBuffer(a.encoder,i._geometry)),S.bindPipeline(a.encoder,f)&&ve.viewCount_pipeline(e,W[r]);let A=(h>=i._geometry.subGeometries.length?i._geometry.subGeometries[0]:i._geometry.subGeometries[h]).lodLevels[i.lodLevel];i.instanceCount>0?(ve.viewCount_instance(e,W[r],i.instanceCount),ve.viewCount_indices(e,W[r],A.indexCount),ve.viewCount_tri(e,W[r],A.indexCount/3*i.instanceCount),S.drawIndexed(a.encoder,A.indexCount,i.instanceCount,A.indexStart,0,0)):(ve.viewCount_indices(e,W[r],A.indexCount),ve.viewCount_tri(e,W[r],A.indexCount/3),S.drawIndexed(a.encoder,A.indexCount,1,A.indexStart,0,o.index)),ve.viewCount_draw(e,W[r])}}}}}renderPass2(e,r,a,i,o,l=!1){if(!this.enable||!this._geometry)return;let h=this,c=h.object3D.transform._worldMatrix;for(let u=0;u<this.materials.length;u++){const d=this.materials[u];if(!d.castShadow&&r==W.SHADOW)continue;let f=d.getPass(r);if(!f||f.length==0)return;if(this.drawType==2)for(let A of f)A.pipeline&&(S.bindPipeline(o,A),S.draw(o,6,1,0,c.index));else{S.bindGeometryBuffer(o,h._geometry);for(let A of f)if(A.pipeline){S.bindPipeline(o,A);let p=h._geometry.subGeometries[u].lodLevels[h.lodLevel];S.drawIndexed(o,p.indexCount,1,p.indexStart,0,c.index)}}}}recordRenderPass2(e,r,a,i,o,l=!1){if(!this.enable)return;let h=this;for(let c=0;c<this.materials.length;c++){let u=this.materials[c].getPass(r);if(!u||u.length==0)return;let d=h.object3D.transform._worldMatrix;for(let f=0;f<u.length;f++){const A=u[f];S.bindPipeline(o,A);let p=h._geometry.subGeometries[c].lodLevels[h.lodLevel];S.drawIndexed(o,p.indexCount,1,p.indexStart,0,d.index)}}}noticeShaderChange(){this.enable&&(this.onEnable(),this._passInit.forEach((e,r)=>{this._passInit.set(r,!1)}))}preInit(e){return this._passInit.get(e)}nodeUpdate(e,r,a,i){let o=this,l=e.scene.envMap;for(let h=0;h<o.materials.length;h++){let c=o.materials[h].getPass(r);if(c)for(let u=0;u<c.length;u++){const d=c[u];if(d.shaderState.splitTexture){let Q=xt.CreateSplitTexture(o.instanceID);d.setTexture("splitTexture_Map",Q)}!o._ignoreEnvMap&&d.envMap!=l&&d.setTexture("envMap",l),d.prefilterMap||d.setTexture("prefilterMap",l);let f=ce.getReflectionEntries(e.scene);if(!d.reflectionMap&&f&&f.reflectionMap&&(d.setTexture("reflectionMap",f.reflectionMap),d.setStorageBuffer("reflectionBuffer",f.storageGPUBuffer)),d.pipeline){d.apply(o._geometry,a,()=>o.noticeShaderChange());continue}let A=C.res.getTexture("BRDFLUT");d.setTexture("brdflutMap",A);let p=C.getRenderJob(e).shadowMapPassRenderer;p&&p.depth2DArrayTexture&&d.setTexture("shadowMap",C.getRenderJob(e).shadowMapPassRenderer.depth2DArrayTexture);let B=C.getRenderJob(e).pointLightShadowRenderer;B&&B.cubeArrayTexture&&d.setTexture("pointShadowMap",B.cubeArrayTexture);let F=Ua.iesTexture;F&&d.setTexture("iesTextureArrayMap",F),a.irradianceBuffer&&a.irradianceBuffer.length>0&&(d.setTexture("irradianceMap",a.irradianceBuffer[0]),d.setTexture("irradianceDepthMap",a.irradianceBuffer[1]));let U=ce.getLightEntries(e.scene);U&&(d.setStorageBuffer("lightBuffer",U.storageGPUBuffer),U.irradianceVolume&&d.setUniformBuffer("irradianceData",U.irradianceVolume.irradianceVolumeBuffer)),i&&(d.setStorageBuffer("clustersUniform",i.clustersUniformBuffer),d.setStorageBuffer("lightAssignBuffer",i.lightAssignBuffer),d.setStorageBuffer("assignTable",i.assignTableBuffer),d.setStorageBuffer("clusterBuffer",i.clusterBuffer)),d.apply(o._geometry,a),this._passInit.set(r,!0)}}}beforeDestroy(e){ae.getInstance().detached(this._geometry,this),ae.getInstance().hasReference(this._geometry)||this._geometry.destroy(e);for(let r=0;r<this._materials.length;r++){const a=this._materials[r];ae.getInstance().detached(a,this),ae.getInstance().hasReference(a)||a.destroy(e)}super.beforeDestroy(e)}destroy(e){super.destroy(e),this._geometry=void 0,this._materials.length=0,this._combineShaderRefection=void 0}}ui([ca],da.prototype,"materials"),ui([ca],da.prototype,"castShadow"),ui([ca],da.prototype,"castGI");var ph=Object.defineProperty,mh=Object.getOwnPropertyDescriptor,di=(n,t,e,r)=>{for(var a=r>1?void 0:r?mh(t,e):t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=(r?o(t,e,a):o(a))||a);return r&&a&&ph(t,e,a),a};let Be=class extends da{constructor(){super();s(this,"receiveShadow");s(this,"morphData")}onEnable(){super.onEnable()}onDisable(){super.onDisable()}cloneTo(t){t.addComponent(Be).copyComponent(this)}copyComponent(t){return super.copyComponent(t),this.receiveShadow=t.receiveShadow,this}get geometry(){return this._geometry}set geometry(t){var e;if(super.geometry=t,t){let r=t.morphTargetDictionary!=null;r&&(this.morphData||(this.morphData=new Yl),this.morphData.morphTargetsRelative=t.morphTargetsRelative,this.morphData.initMorphTarget(t)),this.morphData&&(this.morphData.enable=r),(e=this.morphData)!=null&&e.enable?this.addRendererMask(de.MorphTarget):this.removeRendererMask(de.MorphTarget),this.object3D.bound=this._geometry.bounds.clone()}else this.morphData&&(this.morphData.enable=!1),this.removeRendererMask(de.MorphTarget);this._readyPipeline||(this.initPipeline(),this._computes&&(this.onCompute=$s(this.onCompute,()=>{for(let r=0;r<this._computes.length;r++)this._computes[r].onUpdate()})))}get material(){return this._materials[0]}set material(t){this.materials=[t]}setMorphInfluence(t,e){if(this.morphData&&this.morphData.enable){let r=this._geometry.morphTargetDictionary[t];r>=0&&this.morphData.updateInfluence(r,e)}}setMorphInfluenceIndex(t,e){this.morphData&&this.morphData.enable&&t>=0&&this.morphData.updateInfluence(t,e)}onCompute(t,e){this.morphData&&this.morphData.enable&&this.morphData.computeMorphTarget(e)}nodeUpdate(t,e,r,a){if(this.morphData&&this.morphData.enable)for(let i=0;i<this.materials.length;i++){let o=this.materials[i].getPass(e);if(o)for(let l=0;l<o.length;l++)this.morphData.applyRenderShader(o[l])}super.nodeUpdate(t,e,r,a)}destroy(t){super.destroy(t)}};di([ca],Be.prototype,"geometry",1),di([ca],Be.prototype,"material",1),Be=di([Tt(Be,"MeshRenderer")],Be);class ze{}s(ze,"compressGBufferTex_NAME","compressGBufferTex_NAME"),s(ze,"colorBufferTex_NAME","colorBufferTex"),s(ze,"positionBufferTex_NAME","positionBufferTex"),s(ze,"normalBufferTex_NAME","normalBufferTex"),s(ze,"materialBufferTex_NAME","materialBufferTex"),s(ze,"zBufferTexture_NAME","zBufferTexture"),s(ze,"zPreDepthTexture_NAME","zPreDepthTexture"),s(ze,"outTex_NAME","outTex");class Uh{constructor(){s(this,"label","");s(this,"customSize",!1);s(this,"zPreTexture",null);s(this,"depthTexture",null);s(this,"renderTargetTextures");s(this,"outColor",-1);s(this,"renderTargets");s(this,"rtTextureDescriptors");s(this,"irradianceBuffer");s(this,"multisample",0);s(this,"multiTexture");s(this,"depthViewIndex",0);s(this,"depthCleanValue",0);s(this,"isOutTarget",!0);s(this,"camera3D");s(this,"rtFrame");s(this,"renderPassDescriptor");s(this,"renderBundleEncoderDescriptor");s(this,"depthLoadOp")}getLastRenderTexture(){return this.renderTargets&&this.renderTargets.length>0?this.renderTargets[0]:C.res.redTexture}}class tt extends rt{constructor(e,r,a=H.rgba8unorm,i=!1,o,l=1,h=0,c=!0,u=!0){super(e,r,l);s(this,"resolveTarget");s(this,"sampleCount");s(this,"autoResize");s(this,"clear");this.name=Ft(),this.autoResize=u,this.useMipmap=i,this.sampleCount=h,this.format=a,this.numberLayer=l,this.clear=c,o!=null?this.usage=o:this.usage=o|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.resize(e,r),this.autoResize&&R.addEventListener(pr.RESIZE,d=>{let{width:f,height:A}=d.data;this.resize(f,A),this._textureChange=!0},this)}resize(e,r){let a=R.device;this.gpuTexture&&(rt.delayDestroyTexture(this.gpuTexture),this.gpuTexture=null,this.view=null),this.width=e,this.height=r,this.createTextureDescriptor(e,r,1,this.format,this.usage,this.numberLayer,this.sampleCount),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this.format==H.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=a.createSampler({})):this.format==H.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=R.device.createSampler({}),this.gpuSampler_comparison=R.device.createSampler({compare:"less",label:"sampler_comparison"})):this.format==H.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=R.device.createSampler({}),this.gpuSampler_comparison=R.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.sampleCount>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.addressModeU=Bt.clamp_to_edge,this.addressModeV=Bt.clamp_to_edge,this.gpuSampler=a.createSampler(this)),this._textureChange=!0}create(e,r,a=!0){let i=R.device;const o=e*4;let l=new Float32Array(e*r*4);const h=i.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});i.queue.writeBuffer(h,0,l);const c=S.beginCommandEncoder();c.copyBufferToTexture({buffer:h,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:r,depthOrArrayLayers:1}),S.endCommandEncoder(c)}clone(){let e=new tt(this.width,this.height,this.format,this.useMipmap,this.usage,this.numberLayer,this.sampleCount,this.clear,this.autoResize);return e.name="clone_"+e.name,e}readTextureToImage(){let e=R.device,r=R.windowWidth,a=R.windowHeight,i=new Float32Array(r*a*4);const o=e.createBuffer({size:i.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return S.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:o},[r,a]),o.getMappedRange(0,i.byteLength)}}class Ot{constructor(){s(this,"storeOp","store");s(this,"loadOp","clear");s(this,"clearValue",[0,0,0,0])}}class sr{constructor(t,e,r,a,i=!0){s(this,"label");s(this,"customSize",!1);s(this,"renderTargets");s(this,"rtDescriptors");s(this,"zPreTexture");s(this,"depthTexture");s(this,"depthViewIndex",0);s(this,"depthCleanValue",1);s(this,"depthLoadOp","clear");s(this,"isOutTarget",!0);this.renderTargets=t,this.rtDescriptors=e,this.depthTexture=r,this.zPreTexture=a,this.isOutTarget=i}clone2Frame(t){t.renderTargets.push(...this.renderTargets.concat());for(let e=0;e<this.rtDescriptors.length;e++){const r=this.rtDescriptors[e];let a=new Ot;a.loadOp=r.loadOp,a.storeOp=r.storeOp,a.clearValue=r.clearValue,t.rtDescriptors.push(a)}t.depthTexture=this.depthTexture,t.zPreTexture=this.zPreTexture,t.customSize=this.customSize}clone(){let t=new sr([],[]);return this.clone2Frame(t),t}}const lt=class lt extends sr{constructor(){super([],[]);s(this,"_colorBufferTex");s(this,"_compressGBufferTex")}createGBuffer(e,r,a,i=!0,o=!0,l){let h=this.renderTargets,c=this.rtDescriptors;if(o){let d=new Ot;d.loadOp="clear",this._colorBufferTex=xt.createRTTexture(e+ze.colorBufferTex_NAME,r,a,H.rgba16float,!0),h.push(this._colorBufferTex),c.push(d)}this._compressGBufferTex=new tt(r,a,H.rgba32float,!1,void 0,1,0,!0,!0),h.push(this._compressGBufferTex),l?this.depthTexture=l:(this.depthTexture=new tt(r,a,H.depth24plus,!1,void 0,1,0,!0,!0),this.depthTexture.name=e+"_depthTexture");let u;u=new Ot,c.push(u)}getPositionMap(){return this.renderTargets[1]}getNormalMap(){return this.renderTargets[2]}getColorTexture(){return this._colorBufferTex}getCompressGBufferTexture(){return this._compressGBufferTex}static getGBufferFrame(e,r=0,a=0,i=!0,o){let l;if(lt.gBufferMap.has(e))l=lt.gBufferMap.get(e);else{l=new lt;let h=R.presentationSize;l.createGBuffer(e,r==0?h[0]:r,a==0?h[1]:a,r!=0&&a!=0,i,o),lt.gBufferMap.set(e,l)}return l}static getGUIBufferFrame(){let e=this.getGBufferFrame(this.colorPass_GBuffer);return lt.getGBufferFrame(lt.gui_GBuffer,0,0,!0,e.depthTexture)}clone(){let e=new lt;return this.clone2Frame(e),e}};s(lt,"colorPass_GBuffer","ColorPassGBuffer"),s(lt,"reflections_GBuffer","reflections_GBuffer"),s(lt,"gui_GBuffer","gui_GBuffer"),s(lt,"gBufferMap",new Map);let Le=lt;const Ht=class Ht{static createRendererPassState(t,e=null){let r=Ht.rendererPassState.get(t);if(r||(r=new Uh,r.label=t.label,r.customSize=t.customSize,r.rtFrame=t,r.zPreTexture=t.zPreTexture,r.depthTexture=t.depthTexture,r.depthViewIndex=t.depthViewIndex,r.isOutTarget=t.isOutTarget,r.depthCleanValue=t.depthCleanValue,r.depthLoadOp=t.depthLoadOp,Ht.rendererPassState.set(t,r)),t&&t.renderTargets.length>0){r.renderTargets=t.renderTargets,r.rtTextureDescriptors=t.rtDescriptors,r.renderPassDescriptor=Ht.getRenderPassDescriptor(r),r.renderPassDescriptor.depthStencilAttachment&&(r.renderPassDescriptor.depthStencilAttachment.depthLoadOp=t.depthLoadOp),e=="load"&&(t!=null&&t.renderTargets[0])&&t.renderTargets[0].name.startsWith(Le.gui_GBuffer)&&(r.renderPassDescriptor.colorAttachments[0].loadOp="load"),r.depthLoadOp=t.depthLoadOp,r.renderBundleEncoderDescriptor=Ht.getRenderBundleDescriptor(r),r.renderTargetTextures=[];for(let a=0;a<t.renderTargets.length;a++){const i=t.renderTargets[a];r.renderTargetTextures[a]={format:i.format},i.name.indexOf(ze.colorBufferTex_NAME)!=-1&&(r.outColor=a)}}else r.renderPassDescriptor=Ht.getRenderPassDescriptor(r,e),r.renderBundleEncoderDescriptor=Ht.getRenderBundleDescriptor(r),r.renderTargetTextures=[{format:R.presentationFormat}],r.outColor=0;return r}static getRenderPassDescriptor(t,e=null){if(t.renderPassDescriptor)return t.renderPassDescriptor;R.device,R.presentationSize;let r=[];if(t.renderTargets&&t.renderTargets.length>0){t.renderTargets[0].width,t.renderTargets[0].height;for(let i=0;i<t.renderTargets.length;i++){const o=t.renderTargets[i],l=t.rtTextureDescriptors[i];r.push({view:o.getGPUView(),resolveTarget:void 0,loadOp:l.loadOp,clearValue:l.clearValue,storeOp:l.storeOp})}}else if(!t.customSize){let i=R.canvasConfig&&R.canvasConfig.alpha?[1,1,1,0]:[0,0,0,1];t.isOutTarget==!0&&r.push({view:void 0,resolveTarget:void 0,loadOp:R.canvasConfig&&R.canvasConfig.alpha||e!=null?"load":"clear",clearValue:i,storeOp:"store"})}let a=null;return t.depthTexture||t.zPreTexture?(t.zPreTexture&&(t.depthTexture=t.zPreTexture),a={label:`${t.label} renderPassDescriptor zPreTexture${t.zPreTexture?"load":"clear"}`,colorAttachments:r,depthStencilAttachment:{view:t.depthTexture.getGPUView(),depthLoadOp:t.zPreTexture?"load":t.depthLoadOp,depthClearValue:t.zPreTexture?1:t.depthCleanValue,depthStoreOp:"store"}}):a={colorAttachments:r,label:"renderPassDescriptor not writeDepth"},t.renderPassDescriptor=a,a}static getRenderBundleDescriptor(t){if(t.renderBundleEncoderDescriptor)return t.renderBundleEncoderDescriptor;R.presentationSize;let e=[];if(t.renderTargets&&t.renderTargets.length>0){t.renderTargets[0].width,t.renderTargets[0].height;for(let a=0;a<t.renderTargets.length;a++){const i=t.renderTargets[a];e.push(i.format)}}let r=null;return t.depthTexture?r={colorFormats:e,depthStencilFormat:t.depthTexture.format}:r={colorFormats:e},t.renderBundleEncoderDescriptor=r,t.renderBundleEncoderDescriptor}};s(Ht,"rendererPassState",new Map);let rr=Ht;class fi extends kr{constructor(e){super();s(this,"node");this.bufferType=ir.VertexGPUBuffer,this.createVertexBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,e)}createVertexBuffer(e,r){let a=R.device;this.byteSize=r*Float32Array.BYTES_PER_ELEMENT,this.usage=e,this.buffer&&this.destroy(),this.buffer=a.createBuffer({label:"VertexGPUBuffer",size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory=new Ma,this.memoryNodes=new Map,this.memory.allocation(this.byteSize),this.node=this.memory.allocation_node(this.byteSize)}}var qe=(n=>(n[n.split=0]="split",n[n.compose=1]="compose",n[n.compose_bin=2]="compose_bin",n))(qe||{});class Bh{constructor(){s(this,"vertexCount",0);s(this,"vertexGPUBuffer");s(this,"geometryType",qe.compose);s(this,"_vertexBufferLayouts");s(this,"_attributeSlotLayouts");s(this,"_attributeLocation");this._vertexBufferLayouts=[],this._attributeLocation={},this._attributeSlotLayouts=[]}get vertexBufferLayouts(){return this._vertexBufferLayouts}createVertexBuffer(t,e){switch(this.geometryType){case qe.split:this.createSplitVertexBuffer(t,e);break;case qe.compose:this.createComposeVertexBuffer(t,e);break;case qe.compose_bin:this.createComposBinVertexBuffer(t,e);break}}createSplitVertexBuffer(t,e){let r=0;for(let a=0;a<e.attributes.length;a++){const i=e.attributes[a];if(i.name=="index")continue;this._attributeLocation[i.name]=i.location;let o={name:i.name,format:i.format,offset:0,shaderLocation:i.location,stride:_r[i.format]};this._attributeSlotLayouts[i.location]=[o];let l=t.get(i.name);l||(l={attribute:i.name,data:new Float32Array(i.size*this.vertexCount)},t.set(i.name,l));let h=l.data.length/o.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h,this._vertexBufferLayouts[i.location]={name:i.name,arrayStride:i.size*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[i.location],offset:r*4,size:this.vertexCount*i.size*4},r+=this.vertexCount*i.size}this.vertexGPUBuffer=new fi(r)}createComposeVertexBuffer(t,e){this._attributeSlotLayouts[0]=[];let r=0;for(let a=0;a<e.attributes.length;a++){const i=e.attributes[a];if(i.name=="index"||i.type=="builtin")continue;this._attributeLocation[i.name]=i.location;let o={name:i.name,format:i.format,offset:r*4,shaderLocation:i.location,stride:_r[i.format]};this._attributeSlotLayouts[0][i.location]=o;let l=t.get(i.name);if(l||(l={attribute:i.name,data:new Float32Array(i.size*this.vertexCount)},t.set(i.name,l)),l.data){let h=l.data.length/o.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h}r+=i.size}this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new fi(this.vertexCount*r)}createComposBinVertexBuffer(t,e){this._attributeSlotLayouts[0]=[];let r=0;for(let i=0;i<e.attributes.length;i++){const o=e.attributes[i];if(o.name=="index"||o.type=="builtin")continue;this._attributeLocation[o.name]=o.location;let l={name:o.name,format:o.format,offset:r*4,shaderLocation:o.location,stride:_r[o.format]};this._attributeSlotLayouts[0][o.location]=l;let h=t.get(o.name);if(h||(h={attribute:o.name,data:new Float32Array(o.size*this.vertexCount)},t.set(o.name,h)),h.data){let c=h.data.length/l.stride;this.vertexCount!=0&&this.vertexCount!=c&&console.error(" vertex count not match attribute count"),this.vertexCount=c}r+=o.size}let a=t.get(k.all).data.length/r;this.vertexCount=a,this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new fi(this.vertexCount*r)}upload(t,e){var r;if(this.vertexGPUBuffer){switch(this.geometryType){case qe.split:{let a=this._attributeLocation[t],i=this._vertexBufferLayouts[a];this.vertexGPUBuffer.node.setFloat32Array(i.offset/4,e.data)}break;case qe.compose:for(let a=0;a<this.vertexCount;a++){const i=this._attributeSlotLayouts[0][this._attributeLocation[t]];for(let o=0;o<i.stride;o++){let l=e.data[a*i.stride+o],h=a*(this._vertexBufferLayouts[0].arrayStride/4)+i.offset/4+o;this.vertexGPUBuffer.node.setFloat(l,h)}}break;case qe.compose_bin:this.vertexGPUBuffer.node.setFloat32Array(0,e.data);break}(r=this.vertexGPUBuffer)==null||r.apply()}}updateAttributes(t){switch(this.geometryType){case qe.split:for(let e=0;e<this._vertexBufferLayouts.length;e++){const r=this._vertexBufferLayouts[e];let a=t.get(r.name);this.vertexGPUBuffer.node.setFloat32Array(r.offset/4,a.data)}break;case qe.compose:for(let e=0;e<this.vertexCount;e++)this._attributeSlotLayouts.forEach(r=>{for(let a=0;a<r.length;a++){const i=r[a];let o=t.get(i.name);for(let l=0;l<i.stride;l++){let h=o.data[e*i.stride+l],c=e*(this._vertexBufferLayouts[0].arrayStride/4)+i.offset/4+l;this.vertexGPUBuffer.node.setFloat(h,c)}}});break;case qe.compose_bin:{let e=t.get(k.all);this.vertexGPUBuffer.node.setFloat32Array(0,e.data)}break}this.vertexGPUBuffer.apply()}compute(){}destroy(){this.vertexCount=null,this.geometryType=null,this._vertexBufferLayouts=null,this._attributeSlotLayouts=null,this._attributeLocation=null,this.vertexGPUBuffer&&this.vertexGPUBuffer.destroy(),this.vertexGPUBuffer=null}}class Fh extends kr{constructor(e){super();s(this,"indicesNode");this.bufferType=ir.IndicesGPUBuffer,this.createIndicesBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.INDEX|GPUBufferUsage.INDIRECT,e)}createIndicesBuffer(e,r){let a=R.device;this.byteSize=r.length*4,this.usage=e,this.buffer&&this.destroy(),this.buffer=a.createBuffer({label:"IndicesGPUBuffer",size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory=new Ma,this.memoryNodes=new Map,this.memory.allocation(this.byteSize),r&&(this.indicesNode=this.memory.allocation_node(r.length*4),this.indicesNode.setArrayBuffer(0,r),this.apply())}}class Ch{constructor(){s(this,"uuid","");s(this,"name");s(this,"indicesGPUBuffer");s(this,"indicesFormat","uint16");s(this,"indicesCount",0)}createIndicesBuffer(t){t.data instanceof Uint16Array?this.indicesFormat="uint16":t.data instanceof Uint32Array&&(this.indicesFormat="uint32"),this.indicesCount=t.data.length,this.indicesGPUBuffer=new Fh(t.data)}upload(t){this.indicesGPUBuffer.indicesNode.setArrayBuffer(0,t),this.indicesGPUBuffer.apply()}compute(){}destroy(){this.uuid=null,this.name=null,this.indicesFormat=null,this.indicesCount=null,this.indicesGPUBuffer.destroy(),this.indicesGPUBuffer=null}}class Qh{constructor(){s(this,"lodLevels")}}const it=class it{constructor(){s(this,"instanceID");s(this,"name");s(this,"subGeometries",[]);s(this,"morphTargetsRelative");s(this,"morphTargetDictionary");s(this,"skinNames");s(this,"bindPose");s(this,"blendShapeData");s(this,"vertexDim");s(this,"vertexCount",0);s(this,"_bounds");s(this,"_attributeMap");s(this,"_attributes");s(this,"_indicesBuffer");s(this,"_vertexBuffer");s(this,"_onChange",!0);s(this,"_wireframeLines");this.instanceID=Ft(),this._attributeMap=new Map,this._attributes=[],this._vertexBuffer=new Bh}get indicesBuffer(){return this._indicesBuffer}get vertexBuffer(){return this._vertexBuffer}get vertexAttributes(){return this._attributes}get vertexAttributeMap(){return this._attributeMap}get geometryType(){return this._vertexBuffer.geometryType}set geometryType(t){this._vertexBuffer.geometryType=t}get bounds(){if(!this._bounds){this._bounds=new Pe(new g,new g(1,1,1)),this._bounds.min.x=Number.MAX_VALUE,this._bounds.min.y=Number.MAX_VALUE,this._bounds.min.z=Number.MAX_VALUE,this._bounds.max.x=-Number.MAX_VALUE,this._bounds.max.y=-Number.MAX_VALUE,this._bounds.max.z=-Number.MAX_VALUE;let t=this.getAttribute(k.position);if(t&&t.data)for(let e=0;e<t.data.length/3;e++){const r=t.data[e*3+0],a=t.data[e*3+1],i=t.data[e*3+2];this._bounds.min.x>r&&(this._bounds.min.x=r),this._bounds.min.y>a&&(this._bounds.min.y=a),this._bounds.min.z>i&&(this._bounds.min.z=i),this._bounds.max.x<r&&(this._bounds.max.x=r),this._bounds.max.y<a&&(this._bounds.max.y=a),this._bounds.max.z<i&&(this._bounds.max.z=i)}this._bounds.setFromMinMax(this._bounds.min,this._bounds.max)}return this._bounds}set bounds(t){this._bounds=t}addSubGeometry(...t){let e=new Qh;return e.lodLevels=t,this.subGeometries.push(e),e}generate(t){this._onChange&&(this._onChange=!1,this._indicesBuffer.upload(this.getAttribute(k.indices).data),this._vertexBuffer.createVertexBuffer(this._attributeMap,t),this._vertexBuffer.updateAttributes(this._attributeMap),this.vertexCount=this._vertexBuffer.vertexCount)}setIndices(t){if(!this._attributeMap.has(k.indices)){let e={attribute:k.indices,data:t};this._attributeMap.set(k.indices,e),this._indicesBuffer=new Ch,this._indicesBuffer.createIndicesBuffer(e)}}setAttribute(t,e){if(t==k.indices)this.setIndices(e);else{let r={attribute:t,data:e};this._attributeMap.set(t,r),this._attributes.push(t)}}getAttribute(t){return this._attributeMap.get(t)}hasAttribute(t){return this._attributeMap.has(t)}genWireframe(){if(this._wireframeLines)return this._wireframeLines;if(this.geometryType==qe.split||this.geometryType==qe.compose){let t=this.getAttribute(k.position),e=this.getAttribute(k.indices);if(e&&t&&e.data.length>0){let r=t.data,a=[];for(let i=0;i<e.data.length/3;i++){const o=e.data[i*3+0],l=e.data[i*3+1],h=e.data[i*3+2];let c=new g(r[o*3+0],r[o*3+1],r[o*3+2]),u=new g(r[l*3+0],r[l*3+1],r[l*3+2]),d=new g(r[h*3+0],r[h*3+1],r[h*3+2]);a.push(c,u),a.push(u,d),a.push(d,c)}return this._wireframeLines=a,a}}else if(this.geometryType==qe.compose_bin){let t=this.getAttribute(k.all),e=this.vertexDim,r=this.getAttribute(k.indices);if(r&&t&&r.data.length>0){let a=t.data,i=[];for(let o=0;o<r.data.length/3;o++){const l=r.data[o*3+0],h=r.data[o*3+1],c=r.data[o*3+2];let u=new g(a[l*e+0],a[l*e+1],a[l*e+2]),d=new g(a[h*e+0],a[h*e+1],a[h*e+2]),f=new g(a[c*e+0],a[c*e+1],a[c*e+2]);i.push(u,d),i.push(d,f),i.push(f,u)}return this._wireframeLines=i,i}}return null}compute(){this._indicesBuffer&&this._indicesBuffer.compute(),this._vertexBuffer&&this._vertexBuffer.compute()}computeNormals(){let t=this.getAttribute(k.position),e=this.getAttribute(k.normal),r=this.getAttribute(k.indices);if(!t||!e||!r)return this;let a=r.data.length/3,i=it.point1,o=it.point2,l=it.point3,h=it.crossA,c=it.crossB,u=it.crossRet;for(let d=0;d<a;d++){let f=r.data[d*3],A=r.data[d*3+1],p=r.data[d*3+2];i.set(t.data[f*3],t.data[f*3+1],t.data[f*3+2]),o.set(t.data[A*3],t.data[A*3+1],t.data[A*3+2]),l.set(t.data[p*3],t.data[p*3+1],t.data[p*3+2]),g.sub(i,o,h).normalize(),g.sub(i,l,c).normalize();let B=h.crossProduct(c,u).normalize();e.data[f*3]=e.data[A*3]=e.data[p*3]=B.x,e.data[f*3+1]=e.data[A*3+1]=e.data[p*3+1]=B.y,e.data[f*3+2]=e.data[A*3+2]=e.data[p*3+2]=B.z}return this._vertexBuffer.upload(k.normal,e),this}isPrimitive(){return!1}destroy(t){this.instanceID=null,this.name=null,this.subGeometries=null,this.morphTargetDictionary=null,this._bounds.destroy(),this._bounds=null,this._attributeMap=null,this._attributes=null,this._indicesBuffer.destroy(),this._vertexBuffer.destroy(),this._indicesBuffer=null,this._vertexBuffer=null}};s(it,"crossA",g.UP.clone()),s(it,"crossB",g.UP.clone()),s(it,"crossRet",g.UP.clone()),s(it,"point1",g.UP.clone()),s(it,"point2",g.UP.clone()),s(it,"point3",g.UP.clone());let ar=it;class vh extends ar{constructor(e,r,a=1,i=1,o=g.Y_AXIS){super();s(this,"width");s(this,"height");s(this,"segmentW");s(this,"segmentH");s(this,"up");this.width=e,this.height=r,this.segmentW=a,this.segmentH=i,this.up=o,this.buildGeometry(this.up)}buildGeometry(e){var r,a,i,o,l=this.segmentW+1;(this.segmentH+1)*l,this.bounds=new Pe(g.ZERO.clone(),new g(this.width,1,this.height)),i=this.segmentH*this.segmentW*6;let h=(this.segmentW+1)*(this.segmentH+1),c=new Float32Array(h*3),u=new Float32Array(h*3),d=new Float32Array(h*2),f;this.segmentW*this.segmentH*2*3>=Uint16Array.length?f=new Uint32Array(this.segmentW*this.segmentH*2*3):f=new Uint16Array(this.segmentW*this.segmentH*2*3),i=0;for(var A=0,p=0,B=0,F=0;F<=this.segmentH;++F)for(var U=0;U<=this.segmentW;++U){switch(r=(U/this.segmentW-.5)*this.width,a=(F/this.segmentH-.5)*this.height,e){case g.Y_AXIS:c[A++]=r,c[A++]=0,c[A++]=a,u[p++]=0,u[p++]=1,u[p++]=0;break;case g.Z_AXIS:c[A++]=r,c[A++]=-a,c[A++]=0,u[p++]=0,u[p++]=0,u[p++]=1;break;case g.X_AXIS:c[A++]=0,c[A++]=r,c[A++]=a,u[p++]=1,u[p++]=0,u[p++]=0;break;default:c[A++]=r,c[A++]=0,c[A++]=a,u[p++]=0,u[p++]=1,u[p++]=0;break}d[B++]=U/this.segmentW,d[B++]=F/this.segmentH,U!=this.segmentW&&F!=this.segmentH&&(o=U+F*l,f[i++]=o+1,f[i++]=o,f[i++]=o+l,f[i++]=o+1,f[i++]=o+l,f[i++]=o+l+1)}this.setIndices(f),this.setAttribute(k.position,c),this.setAttribute(k.normal,u),this.setAttribute(k.uv,d),this.setAttribute(k.TEXCOORD_1,d),this.addSubGeometry({indexStart:0,indexCount:f.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class Fr{constructor(){s(this,"instanceID");s(this,"name");s(this,"enable",!0);s(this,"_defaultSubShader");s(this,"_shader");this.instanceID=Ft()}set shader(t){this._shader=t,this._defaultSubShader=t.getDefaultShaders()[0]}get shader(){return this._shader}get doubleSide(){return this._defaultSubShader.doubleSide}set doubleSide(t){this._defaultSubShader.doubleSide=t}get castShadow(){return this._defaultSubShader.shaderState.castShadow}set castShadow(t){let e=this._defaultSubShader.shaderState;t!=e.castShadow&&(e.castShadow=t)}get acceptShadow(){return this._defaultSubShader.shaderState.acceptShadow}set acceptShadow(t){let e=this._defaultSubShader.shaderState;e.acceptShadow!=t&&(e.acceptShadow=t,this._defaultSubShader.noticeShaderChange(),this._defaultSubShader.noticeValueChange())}get castReflection(){return this._defaultSubShader.shaderState.castReflection}set castReflection(t){this._defaultSubShader.shaderState.castReflection=t}get blendMode(){return this._defaultSubShader.blendMode}set blendMode(t){this._defaultSubShader.blendMode=t}get depthCompare(){return this._defaultSubShader.depthCompare}set depthCompare(t){this._defaultSubShader.depthCompare=t;for(let e of this._shader.passShader.values())for(let r of e)r.depthCompare=t}get transparent(){return this._defaultSubShader.shaderState.transparent}set transparent(t){this._defaultSubShader.shaderState.transparent=t,t&&(this._defaultSubShader.renderOrder=3e3)}get cullMode(){return this._defaultSubShader.cullMode}set cullMode(t){if(this._defaultSubShader.cullMode!=t){for(let e of this._shader.passShader.values())for(let r of e)r.cullMode=t;this._defaultSubShader.cullMode=t}}get depthWriteEnabled(){return this._defaultSubShader.depthWriteEnabled}set depthWriteEnabled(t){this._defaultSubShader.depthWriteEnabled=t}set useBillboard(t){this._defaultSubShader.setDefine("USE_BILLBOARD",t)}get topology(){return this._defaultSubShader.topology}set topology(t){this._defaultSubShader.topology=t}set baseColor(t){this.shader.setUniformColor("baseColor",t)}get baseColor(){return this.shader.getUniformColor("baseColor")}getPass(t){return this._shader.getSubShaders(t)}getAllPass(){return this._shader.getSubShaders(W.COLOR)}clone(){let t=new Fr;return t.shader=this.shader.clone(),t}destroy(t){this.name=null,this.instanceID=null,this._shader.destroy(t),this._shader=null}setDefine(t,e){this.shader.setDefine(t,e)}setTexture(t,e){this._shader.setTexture(t,e)}setStorageBuffer(t,e){this._shader.setStorageBuffer(t,e)}setUniformBuffer(t,e){this._shader.setStorageBuffer(t,e)}setUniformFloat(t,e){this._shader.setUniformFloat(t,e)}setUniformVector2(t,e){this._shader.setUniformVector2(t,e)}setUniformVector3(t,e){this._shader.setUniformVector3(t,e)}setUniformVector4(t,e){this._shader.setUniformVector4(t,e)}setUniformColor(t,e){this._shader.setUniformColor(t,e)}getUniformFloat(t){return this._shader.getUniform(t).data}getUniformV2(t){return this._shader.getUniformVector2(t)}getUniformV3(t){return this._shader.getUniformVector3(t)}getUniformV4(t){return this._shader.getUniformVector4(t)}getUniformColor(t){return this._shader.getUniformColor(t)}getTexture(t){return this._shader.getTexture(t)}getStorageBuffer(t){return this._shader.getStorageBuffer(t)}getStructStorageBuffer(t){return this._shader.getStructStorageBuffer(t)}getUniformBuffer(t){return this._shader.getUniformBuffer(t)}applyUniform(){this._shader.applyUniform()}}class Ct{constructor(){s(this,"computes");s(this,"passShader");this.computes=[],this.passShader=new Map}addRenderPass(t,e=-1){let r=this.passShader.get(t.passType)||[];e==-1?r.push(t):r.splice(e,-1,t),this.passShader.set(t.passType,r)}removeShader(t,e=-1){let r=this.passShader.get(t.passType);if(r)if(e==-1){let a=r.indexOf(t);a!=-1&&r.splice(a)}else r.splice(e,1)}removeShaderByIndex(t,e=-1){let r=this.passShader.get(t);r&&(e==-1?this.passShader.delete(t):r.splice(e,1))}getSubShaders(t){return this.passShader.get(t)||[]}hasSubShaders(t){return this.passShader.get(t).length>0}getDefaultShaders(){return this.passShader.get(W.COLOR)}getDefaultColorShader(){return this.passShader.get(W.COLOR)[0]}setDefine(t,e){for(const r of this.passShader)for(const a of r[1])a.setDefine(t,e)}hasDefine(t){for(const e of this.passShader)for(const r of e[1]){let a=r.hasDefine(t);if(a)return a}return!1}deleteDefine(t){for(const e of this.passShader)for(const r of e[1])r.deleteDefine(t)}setUniform(t,e){for(const r of this.passShader)for(const a of r[1])a.setUniform(t,e)}setUniformFloat(t,e){for(const r of this.passShader)for(const a of r[1])a.setUniformFloat(t,e)}setUniformVector2(t,e){for(const r of this.passShader)for(const a of r[1])a.setUniformVector2(t,e)}setUniformVector3(t,e){for(const r of this.passShader)for(const a of r[1])a.setUniformVector3(t,e)}setUniformVector4(t,e){for(const r of this.passShader)for(const a of r[1])a.setUniformVector4(t,e)}setUniformColor(t,e){for(const r of this.passShader)for(const a of r[1])a.setUniformColor(t,e)}getUniform(t){return this.getDefaultColorShader().getUniform(t)}getUniformFloat(t){return this.getDefaultColorShader().getUniformFloat(t)}getUniformVector2(t){return this.getDefaultColorShader().getUniformVector2(t)}getUniformVector3(t){return this.getDefaultColorShader().getUniformVector3(t)}getUniformVector4(t){return this.getDefaultColorShader().getUniformVector4(t)}getUniformColor(t){return this.getDefaultColorShader().getUniformColor(t)}setTexture(t,e){for(const r of this.passShader)for(const a of r[1])a.setTexture(t,e);this.setDefine(`USE_${t.toLocaleUpperCase()}`,!0)}getTexture(t){return this.getDefaultColorShader().textures[t]}setUniformBuffer(t,e){for(const r of this.passShader)for(const a of r[1])a.setUniformBuffer(t,e)}getUniformBuffer(t){return this.getDefaultColorShader().getBuffer(t)}setStorageBuffer(t,e){for(const r of this.passShader)for(const a of r[1])a.setStorageBuffer(t,e)}getStorageBuffer(t){return this.getDefaultColorShader().getBuffer(t)}setStructStorageBuffer(t,e){for(const r of this.passShader)for(const a of r[1])a.setStructStorageBuffer(t,e)}getStructStorageBuffer(t){return this.getDefaultColorShader().getBuffer(t)}noticeValueChange(){for(const t of this.passShader)for(const e of t[1])e.noticeValueChange()}destroy(t){this.getDefaultColorShader().destroy(t)}clone(){let t=new Ct,e=this.getDefaultShaders();for(const r of e)t.addRenderPass(r);return t}applyUniform(){for(const t of this.passShader)for(const e of t[1])e.applyUniform()}}var Sh=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let Ri=class extends Ct{constructor(n="QuadGlsl_vs",t="QuadGlsl_fs"){super();let e=new _e(n,t);this.addRenderPass(e);let r=e.shaderState;e.blendMode=q.NONE,r.frontFace="cw",r.depthWriteEnabled=!1,r.depthCompare=tr.always,r.multisample=0,this.setTexture("baseMap",C.res.blackTexture),this.setUniformFloat("x",0),this.setUniformFloat("y",0),this.setUniformFloat("width",100),this.setUniformFloat("height",100)}};Ri=Sh([Mr],Ri);class nn extends ie{constructor(e="QuadGlsl_vs",r="QuadGlsl_fs",a,i=0,o=!1){super();s(this,"width",128);s(this,"height",128);s(this,"quadRenderer");s(this,"material");s(this,"rendererPassState");s(this,"quadShader");let l=a?a.renderTargets:[];this.material=new Fr,this.quadShader=new Ri(e,r),this.material.shader=this.quadShader,this.quadRenderer=this.addComponent(Be),this.quadRenderer.material=this.material,this.quadRenderer.castGI=!1,this.quadRenderer.castShadow=!1,this.quadRenderer.drawType=o?2:0,this.quadRenderer.geometry=new vh(100,100,1,1),this.quadRenderer.material=this.material,this.quadRenderer.__start(),this.quadRenderer._enable=!0,this.quadRenderer.onEnable(),this.rendererPassState=rr.createRendererPassState(a,"load"),i>0&&(this.rendererPassState.multisample=this.quadShader.getDefaultColorShader().shaderState.multisample,this.rendererPassState.multiTexture=R.device.createTexture({size:{width:R.presentationSize[0],height:R.presentationSize[1]},sampleCount:i,format:l.length>0?l[0].format:R.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT})),R.addEventListener(pr.RESIZE,h=>{this.rendererPassState=rr.createRendererPassState(a,"load"),i>0&&(this.rendererPassState.multisample=this.quadShader.getDefaultColorShader().shaderState.multisample,this.rendererPassState.multiTexture=R.device.createTexture({size:{width:R.presentationSize[0],height:R.presentationSize[1]},sampleCount:i,format:l.length>0?l[0].format:R.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}))},this)}renderTarget(e,r,a){let i=e.camera,o=S.beginRenderPass(a,r.rendererPassState);S.bindCamera(o,i),r.quadRenderer.nodeUpdate(e,W.COLOR,r.rendererPassState,null),r.quadRenderer.renderPass2(e,W.COLOR,r.rendererPassState,null,o),S.endPass(o)}renderToViewQuad(e,r,a,i){let o=e.camera;r.quadShader.setTexture("baseMap",i);let l=S.beginRenderPass(a,r.rendererPassState);S.bindCamera(l,o),r.quadRenderer.nodeUpdate(e,W.COLOR,r.rendererPassState,null),r.quadRenderer.renderPass2(e,W.COLOR,r.rendererPassState,null,l),S.endPass(l)}}const Er=class Er{static init(){this.rtTextureMap=new Map,this.rtViewQuad=new Map}static createRTTexture(t,e,r,a,i=!1,o=0){let l=this.rtTextureMap.get(t);return l||(t==ze.colorBufferTex_NAME?l=new tt(e,r,a,i,void 0,1,o,!1):l=new tt(e,r,a,i,void 0,1,o,!0),l.name=t,Er.rtTextureMap.set(t,l)),l}static createRTTextureArray(t,e,r,a,i=1,o=!1,l=0){let h=this.rtTextureMap.get(t);return h||(h=new tt(e,r,a,o,void 0,i,l),h.name=t,Er.rtTextureMap.set(t,h)),h}static createViewQuad(t,e,r,a,i=0){let o=new sr([a],[new Ot]),l=new nn(e,r,o,i);return Er.rtViewQuad.set(t,l),l}static getTexture(t){return this.rtTextureMap.get(t)}static CreateSplitTexture(t){let e=this.getTexture(ze.colorBufferTex_NAME),r=this.getTexture(t+"_split");return r||(r=this.createRTTexture(t+"_split",e.width,e.height,e.format,!1)),r}static WriteSplitColorTexture(t){let e=this.getTexture(ze.colorBufferTex_NAME),r=this.getTexture(t+"_split");const a=S.beginCommandEncoder();a.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{width:r.width,height:r.height,depthOrArrayLayers:1}),S.endCommandEncoder(a)}};s(Er,"rtTextureMap"),s(Er,"rtViewQuad");let xt=Er;class Is{constructor(t){s(this,"command");s(this,"encoder");s(this,"rendererPassStates");s(this,"rtFrame");this.rtFrame=t,this.rendererPassStates=[]}clean(){this.rendererPassStates.length=0,S.cleanCache()}beginContinueRendererPassState(t="load",e="load"){if(this.rendererPassStates.length>0){let r=this.rtFrame.clone();for(const i of r.rtDescriptors)i.loadOp="load";r.depthLoadOp=e;let a=rr.createRendererPassState(r,t);return this.rendererPassStates.push(a),a}else{this.rtFrame.depthLoadOp=e;let r=rr.createRendererPassState(this.rtFrame,t);return this.rendererPassStates.push(r),r}}get rendererPassState(){return this.rendererPassStates[this.rendererPassStates.length-1]}beginOpaqueRenderPass(){this.beginContinueRendererPassState("clear","clear"),this.begineNewCommand(),this.beginNewEncoder()}beginTransparentRenderPass(){this.beginContinueRendererPassState("load","load"),this.begineNewCommand(),this.beginNewEncoder()}specialtRenderPass(){this.beginContinueRendererPassState("load","load"),this.begineNewCommand(),this.beginNewEncoder()}endRenderPass(){this.endEncoder(),this.endCommand()}begineNewCommand(){return this.command=S.beginCommandEncoder(),this.command}endCommand(){S.endCommandEncoder(this.command),this.command=null}beginNewEncoder(){return this.encoder=S.beginRenderPass(this.command,this.rendererPassState),this.encoder}endEncoder(){S.endPass(this.encoder),this.encoder=null}}class nr extends ra{constructor(){super();s(this,"rendererPassState");s(this,"splitRendererPassState");s(this,"useRenderBundle",!1);s(this,"debugViewQuads");s(this,"debugTextures");s(this,"renderContext");s(this,"_rendererType");s(this,"_rtFrame");this.debugTextures=[],this.debugViewQuads=[]}get passType(){return this._rendererType}set passType(e){this._rendererType=e}setRenderStates(e){if(this._rtFrame=e,e){this.rendererPassState=rr.createRendererPassState(e);let r=e.clone();r.depthLoadOp="load";for(const a of r.rtDescriptors)a.loadOp="load";this.splitRendererPassState=rr.createRendererPassState(r)}this.renderContext=new Is(e)}getRenderContext(e){return this._rtFrame=e,new Is(e)}setIrradiance(e,r){this.rendererPassState.irradianceBuffer=[e,r]}compute(e,r){}render(e,r,a,i=!1){S.cleanCache();let o=e.camera,l=e.scene;this.rendererPassState.camera3D=o;let h=P.instance.getRenderNodes(l,o),c=this.renderBundleOp(e,h,r,a),u=i?[]:this.renderBundleTr(e,h,r,a);{let d=S.beginCommandEncoder(),f=S.beginRenderPass(d,this.rendererPassState);c.length>0&&f.executeBundles(c),!i&&P.instance.sky&&(S.bindCamera(f,o),P.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,a,f)),this.drawRenderNodes(e,f,d,h.opaqueList,r),S.endPass(f),S.endCommandEncoder(d)}{let d=S.beginCommandEncoder(),f=S.beginRenderPass(d,this.rendererPassState);u.length>0&&f.executeBundles(u),i||(S.bindCamera(f,o),this.drawRenderNodes(e,f,d,h.transparentList,r)),S.endPass(f),S.endCommandEncoder(d)}}nodeUpload(e,r,a){}occlusionRenderNodeTest(e,r,a){return a?a.occlusionRenderNodeTest(e)>0:!0}renderOp(e,r,a,i,o){}renderTr(e,r,a,i,o){}renderBundleOp(e,r,a,i){let o=P.instance.getOpRenderGroup(e.scene);if(o){let l=[];return o.renderGroup.forEach(h=>{if(h.bundleMap.has(this._rendererType))l.push(h.bundleMap.get(this._rendererType));else{let c=S.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,c,h.renderNodes,i);let u=c.finish();h.bundleMap.set(this._rendererType,u),l.push(u)}}),l}return[]}renderBundleTr(e,r,a,i){let o=P.instance.getTrRenderGroup(e.scene);if(o){let l=[];return o.renderGroup.forEach(h=>{if(h.bundleMap.has(this._rendererType))l.push(h.bundleMap.get(this._rendererType));else{let c=S.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,c,h.renderNodes,i);let u=c.finish();h.bundleMap.set(this._rendererType,u),l.push(u)}}),l}return[]}recordRenderBundleNode(e,r,a,i){S.bindCamera(r,e.camera),S.bindGeometryBuffer(r,a[0].geometry);for(let o=0;o<a.length;++o){let l=a[o];l.transform.worldMatrix.index,l.transform.enable&&l.recordRenderPass2(e,this._rendererType,this.rendererPassState,i,r)}}drawRenderNodes(e,r,a,i,o,l){S.bindCamera(r,e.camera);for(let h=C.setting.render.drawOpMin;h<Math.min(i.length,C.setting.render.drawOpMax);++h){let c=i[h];c.transform.enable&&c.enable&&c.renderPass2(e,this._rendererType,this.rendererPassState,l,r)}}}class Rh extends nr{constructor(){super(),this.passType=W.COLOR}render(t,e,r,a=!1){this.renderContext.clean();let i=t.scene,o=t.camera;ce.updateCameraGroup(o),this.rendererPassState.camera3D=o;let l=P.instance.getRenderNodes(i,o),h=this.renderBundleOp(t,l,e,r),c=a?[]:this.renderBundleTr(t,l,e,r);{this.renderContext.beginOpaqueRenderPass();let u=this.renderContext.encoder;h.length>0&&(P.instance.getOpRenderGroup(i),u.executeBundles(h)),!a&&P.instance.sky&&(S.bindCamera(u,o),P.instance.sky.preInit(this._rendererType)||P.instance.sky.nodeUpdate(t,this._rendererType,this.rendererPassState,r),P.instance.sky.renderPass2(t,this._rendererType,this.rendererPassState,r,u)),l.opaqueList&&(S.bindCamera(u,o),this.drawNodes(t,this.renderContext,l.opaqueList,e,r))}{let u=this.renderContext.encoder;c.length>0&&u.executeBundles(c),!a&&l.transparentList&&(S.bindCamera(u,o),this.drawNodes(t,this.renderContext,l.transparentList,e,r));let d=P.instance.getGraphicList();for(let f=0;f<d.length;f++){const A=d[f];A.nodeUpdate(t,this._rendererType,this.splitRendererPassState,r),A.renderPass2(t,this._rendererType,this.splitRendererPassState,r,u)}this.renderContext.endRenderPass(),ve.end("ColorPass Draw Transparent")}}drawNodes(t,e,r,a,i){let o=P.instance.getRenderShaderCollect(t);if(o){for(const l of o){let h=l[1];for(const c of h){let u=c[1];if(!u.isDestroyed&&u.preInit(this._rendererType)){u.nodeUpdate(t,this._rendererType,this.rendererPassState,i);break}}}for(let l=C.setting.render.drawOpMin;l<Math.min(r.length,C.setting.render.drawOpMax);++l){let h=r[l];h.transform.enable&&h.enable&&(h.hasMask(de.UI)&&!h.isRecievePostEffectUI||h.isDestroyed||(h.preInit(this._rendererType)||h.nodeUpdate(t,this._rendererType,this.rendererPassState,i),h.renderPass(t,this.passType,this.renderContext)))}}}occlusionRenderNodeTest(t,e,r){return r.zDepthRenderNodeTest(e)>0}}class on{constructor(){s(this,"frustumCullingList");s(this,"zVisibleList");s(this,"_renderList");this._renderList=new Map}occlusionRenderNodeTest(t){return C.setting.occlusionQuery.enable?this.frustumCullingList?this.frustumCullingList[t]:0:1}zDepthRenderNodeTest(t){return this.zVisibleList?this.zVisibleList[t]:0}update(t,e){}collect(t,e){}renderCommitTesting(t,e){return!0}}s(on,"enable",!0);class ba extends kr{constructor(t,e){super(),this.bufferType=ir.ComputeGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,t,e,"ComputeGPUBuffer")}}class Eh{constructor(t,e){s(this,"clusterBuffer");s(this,"lightAssignBuffer");s(this,"assignTableBuffer");s(this,"clustersUniformBuffer");this.clusterBuffer=new ba(t*2*4),this.clustersUniformBuffer=new aa(10),this.clustersUniformBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.lightAssignBuffer=new ba(t*e),this.lightAssignBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.assignTableBuffer=new ba(t*4),this.assignTableBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(t,e,r,a,i,o,l,h,c,u){this.clustersUniformBuffer.setFloat("clusterTileX",a),this.clustersUniformBuffer.setFloat("clusterTileY",i),this.clustersUniformBuffer.setFloat("clusterTileZ",o),this.clustersUniformBuffer.setFloat("numLights",l),this.clustersUniformBuffer.setFloat("maxNumLightsPerCluster",h),this.clustersUniformBuffer.setFloat("near",c),this.clustersUniformBuffer.setFloat("far",u),this.clustersUniformBuffer.setFloat("screenWidth",t),this.clustersUniformBuffer.setFloat("screenHeight",e),this.clustersUniformBuffer.setFloat("clusterPix",r),this.clustersUniformBuffer.apply()}}class Ve{}s(Ve,"clusterTileX",16),s(Ve,"clusterTileY",16),s(Ve,"clusterTileZ",32);let yh=`
  #include "GlobalUniform"

        struct ClusterBox{
            minPoint:vec4<f32>,
            maxPoint:vec4<f32>
        }

        struct ClustersUniform{
            clusterTileX:f32,
            clusterTileY:f32,
            clusterTileZ:f32,
            numLights:f32,
            maxNumLightsPerCluster:f32,
            near:f32,
            far:f32,
            screenWidth:f32,
            screenHeight:f32,
            clusterPix:f32
        }
     
        @group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
        @group(0) @binding(2) var<storage,read_write> clusterBuffer : array<ClusterBox>;


        var<private> clusterTileX:f32 ;
        var<private> clusterTileY:f32 ;
        var<private> clusterTileZ:f32 ;
        fn convertNDCToView( v4:vec4<f32> ) -> vec4<f32> {
            var v = globalUniform.pvMatrixInv * v4 ;
            v = v / v.w ;
            return v ;
        }

        fn ScreenToView(screen : vec4<f32>) -> vec4<f32> {
            let texCoord = screen.xy / vec2<f32>(clustersUniform.screenWidth, clustersUniform.screenHeight);
            let clip = vec4<f32>(vec2<f32>(texCoord.x, 1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0, 1.0), screen.z, screen.w);
            return convertNDCToView(clip);
        }

        fn gridToIndex(i:vec3<u32>) -> u32{
            return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
        }

        fn LineIntersectionToZPlane( eye:vec3<f32> , ndcPoint :vec3<f32> , z:f32) -> vec3<f32>
        {
            var normal = vec3<f32>(0.0, 0.0, 1.0);
            var dir = ndcPoint - eye;
            var t = (z - dot(normal, eye)) / dot(normal, dir);
            var result = eye + t * dir;
            return result;
        }

        @compute @workgroup_size(${Ve.clusterTileX},${Ve.clusterTileY},1)
        fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){

            let i = local_invocation_id.x ;
            let j = local_invocation_id.y ;
            let k = workgroup_id.x ;

            clusterTileX = clustersUniform.clusterTileX;
            clusterTileY = clustersUniform.clusterTileY;
            clusterTileZ = clustersUniform.clusterTileZ;

            let clusterGrid = vec3<u32>(i,j,k);
            let tileIndex = gridToIndex(clusterGrid);
            let eyePos = vec3<f32>(0.0, 0.0, 0.0);

            let tx = clusterTileX;
            let ty = clusterTileY;
            let tz = clusterTileZ ;
            let near = clustersUniform.near ;
            let far = clustersUniform.far ;

            let titleSize = vec2<f32>( globalUniform.windowWidth / tx , globalUniform.windowHeight / ty ) ;

            var maxPointSs = vec4<f32>(vec2<f32>(f32(i) + 1.0, f32(j) + 1.0) * titleSize, 0.0, 1.0);
	        var minPointSs = vec4<f32>(vec2<f32>(f32(i) , f32(j)) * titleSize, 0.0, 1.0);

            var maxPointVs = ScreenToView(maxPointSs).xyz;
	        var minPointVs = ScreenToView(minPointSs).xyz;
 
            var tileNear = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, f32(k) / clustersUniform.clusterTileZ);
	        var tileFar = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, (f32(k) + 1.0) / clustersUniform.clusterTileZ);

            var minPointNear = LineIntersectionToZPlane(eyePos, minPointVs, tileNear);
            var minPointFar = LineIntersectionToZPlane(eyePos, minPointVs, tileFar);
            var maxPointNear = LineIntersectionToZPlane(eyePos, maxPointVs, tileNear);
            var maxPointFar = LineIntersectionToZPlane(eyePos, maxPointVs, tileFar);

            var minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
            var maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

            var clusterBox : ClusterBox ;
            clusterBox.minPoint = vec4<f32>(minPointAABB,f32(tileIndex)) ;
            clusterBox.maxPoint = vec4<f32>(maxPointAABB,f32(tileIndex)) ;
            clusterBuffer[tileIndex] = clusterBox;
        }
`,Ih=`
#include "GlobalUniform"

struct ClusterBox{
    min:vec4<f32>,
    max:vec4<f32>
}

struct Light {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,

    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:f32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct LightIndex
{
    count:f32,
    start:f32,
    empty0:f32,
    empty1:f32,
};

struct ClustersUniform{
    clusterTileX:f32,
    clusterTileY:f32,
    clusterTileZ:f32,
    numLights:f32,
    maxNumLightsPerCluster:f32,
    near:f32,
    far:f32,
    screenWidth:f32,
    screenHeight:f32,
    clusterPix:f32, 
}

var<private> clusterTileX:f32 ;
var<private> clusterTileY:f32 ;
var<private> clusterTileZ:f32 ;

// @group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
@group(0) @binding(2) var<storage,read> clusterBuffer : array<ClusterBox>;
@group(0) @binding(3) var<storage,read> lightBuffer : array<Light>; 
@group(0) @binding(4) var<storage,read_write> lightAssignBuffer : array<f32>;
@group(0) @binding(5) var<storage,read_write> assignTable : array<LightIndex>;

fn gridToIndex(i:vec3<u32>) -> u32{
    return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
}

fn GetSqdisPointAABB( pos:vec3<f32>,  cluster:ClusterBox  ) -> f32
{
    var sqDistance = 0.0;
    for (var i = 0u; i < 3u; i+=1u)
    {
        var v = pos[i];
        if (v < cluster.min[i])
        {
            let diff = cluster.min[i] - v;
            sqDistance += diff * diff;
        }

        if (v > cluster.max[i])
        {
            let diff =  v - cluster.max[i];
            sqDistance += diff * diff;
        }
    }
    return sqDistance;
}

fn TestSphereAABB( box:ClusterBox ,light:Light ) -> bool
{
    let lightPos = light.position.xyz;
    var radius = light.range * 2.0 ;
    var spherePos = globalUniform.viewMat * vec4<f32>(lightPos.xyz, 1.0) ;
    spherePos = spherePos / spherePos.w ;
    let sqDistance = GetSqdisPointAABB(spherePos.xyz , box);
    return sqDistance <= (radius*radius);
}

@compute @workgroup_size(${Ve.clusterTileX},${Ve.clusterTileY},1)
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
    // cluster ID 
    let i = local_invocation_id.x ;
    let j = local_invocation_id.y ;
    let k = workgroup_id.x ;

    clusterTileX = clustersUniform.clusterTileX;
    clusterTileY = clustersUniform.clusterTileY;
    clusterTileZ = clustersUniform.clusterTileZ;

    var clusterId_3D = vec3<u32>(i,j,k);
    var clusterId_1D = gridToIndex(clusterId_3D);

    var box:ClusterBox = clusterBuffer[clusterId_1D];

    var startIndex = i32(clusterId_1D) * i32(clustersUniform.maxNumLightsPerCluster) ;
    var endIndex = startIndex;

    for(var lightID = 0 ; lightID < i32(clustersUniform.numLights) ; lightID+=1)
    {
        let li:Light = lightBuffer[lightID];
        if(!TestSphereAABB(box, li)) {
            continue;
        }
        lightAssignBuffer[endIndex] = f32(lightID);
        endIndex++;
    }

    var idx: LightIndex;
    idx.count = f32(endIndex-startIndex);
    idx.start = f32(startIndex);
    idx.empty0 = f32(clusterId_1D);
    idx.empty1 = f32(clustersUniform.maxNumLightsPerCluster);
    assignTable[clusterId_1D] = idx;
}
`;class xh extends nr{constructor(e){super();s(this,"maxNumLightsPerCluster",64);s(this,"clusterPix",1);s(this,"clusterLightingBuffer");s(this,"_currentLightCount",0);s(this,"_clusterGenerateCompute");s(this,"_clusterLightingCompute");s(this,"_useCamera");s(this,"resize",!1);this.passType=W.Cluster,this.initCompute(e)}initCompute(e){this._clusterGenerateCompute=new bt(yh),this._clusterLightingCompute=new bt(Ih);let r=R.presentationSize,a=Ve.clusterTileX*Ve.clusterTileY*Ve.clusterTileZ,i=e.camera,o=i.near,l=i.far;this.clusterLightingBuffer=new Eh(a,this.maxNumLightsPerCluster),this.clusterLightingBuffer.update(r[0],r[1],this.clusterPix,Ve.clusterTileX,Ve.clusterTileY,Ve.clusterTileZ,0,this.maxNumLightsPerCluster,o,l),this._clusterGenerateCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterGenerateCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer);let h=ce.getLightEntries(e.scene);this._clusterLightingCompute.setStorageBuffer("models",ce.modelMatrixBindGroup.matrixBufferDst),this._clusterLightingCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterLightingCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer),this._clusterLightingCompute.setStorageBuffer("lightBuffer",h.storageGPUBuffer),this._clusterLightingCompute.setStorageBuffer("lightAssignBuffer",this.clusterLightingBuffer.lightAssignBuffer),this._clusterLightingCompute.setStorageBuffer("assignTable",this.clusterLightingBuffer.assignTableBuffer),this.resize=!0}render(e,r){let a=e.scene,i=P.instance.getLights(a);if(this._useCamera!=e.camera){this._useCamera=e.camera;let h=ce.getCameraGroup(this._useCamera);this._clusterGenerateCompute.setUniformBuffer("globalUniform",h.uniformGPUBuffer),this._clusterLightingCompute.setUniformBuffer("globalUniform",h.uniformGPUBuffer)}this._currentLightCount!=i.length&&(this._currentLightCount=i.length,this.clusterLightingBuffer.clustersUniformBuffer.setFloat("numLights",i.length),this.clusterLightingBuffer.clustersUniformBuffer.apply(),this._clusterGenerateCompute.workerSizeX=Ve.clusterTileZ,this._clusterLightingCompute.workerSizeX=Ve.clusterTileZ);let o=R.presentationSize;this.clusterLightingBuffer.update(o[0],o[1],this.clusterPix,Ve.clusterTileX,Ve.clusterTileY,Ve.clusterTileZ,i.length,this.maxNumLightsPerCluster,e.camera.near,e.camera.far),this.resize=!1;let l=S.beginCommandEncoder();S.computeCommand(l,[this._clusterGenerateCompute,this._clusterLightingCompute]),S.endCommandEncoder(l)}}class _t extends rt{constructor(e,r,a=H.rgba8unorm,i=!1,o,l=1,h=0,c=1){super(e,r,l);s(this,"resolveTarget");s(this,"sampleCount");R.device,this.name=Ft(),this.useMipmap=i,this.sampleCount=h,this.format=a,this.numberLayer=l,this.mipmapCount=c,o!=null?this.usage=o:this.usage=o|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.resize(e,r)}clone(){let e=new _t(this.width,this.height,this.format,this.useMipmap,this.usage,this.numberLayer,this.sampleCount);return e.name="clone_"+e.name,e}resize(e,r){let a=R.device;this.gpuTexture&&(rt.delayDestroyTexture(this.gpuTexture),this.gpuTexture=null,this.view=null),this.width=e,this.height=r,this.createTextureDescriptor(e,r,this.mipmapCount,this.format,this.usage,this.numberLayer,this.sampleCount),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this.format==H.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=a.createSampler({})):this.format==H.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=R.device.createSampler({}),this.gpuSampler_comparison=R.device.createSampler({compare:"less",label:"sampler_comparison"})):this.format==H.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=R.device.createSampler({}),this.gpuSampler_comparison=R.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.sampleCount>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="nearest",this.maxAnisotropy=1,this.addressModeU=Bt.mirror_repeat,this.addressModeV=Bt.mirror_repeat,this.gpuSampler=a.createSampler(this)),this._textureChange=!0}create(e,r,a=!0){let i=R.device;const o=e*4;let l=new Float32Array(e*r*4);const h=i.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});i.queue.writeBuffer(h,0,l);const c=S.beginCommandEncoder();c.copyBufferToTexture({buffer:h,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:r,depthOrArrayLayers:1}),S.endCommandEncoder(c)}readTextureToImage(){let e=R.device,r=R.windowWidth,a=R.windowHeight,i=new Float32Array(r*a*4);const o=e.createBuffer({size:i.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return S.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:o},[r,a]),o.getMappedRange(0,i.byteLength)}}class bh extends ie{constructor(e=.001,r=1e4,a=90,i=!1){super();s(this,"up_camera");s(this,"down_camera");s(this,"left_camera");s(this,"right_camera");s(this,"front_camera");s(this,"back_camera");this.initCubeCamera(e,r,a,i)}set label(e){this.up_camera.name=e+"up",this.down_camera.name=e+"down",this.left_camera.name=e+"left",this.right_camera.name=e+"right",this.front_camera.name=e+"front",this.back_camera.name=e+"back"}initCubeCamera(e,r,a=90,i=!1){this.up_camera=Me.createCamera3DObject(this,"up"),this.down_camera=Me.createCamera3DObject(this,"down"),this.left_camera=Me.createCamera3DObject(this,"left"),this.right_camera=Me.createCamera3DObject(this,"right"),this.front_camera=Me.createCamera3DObject(this,"front"),this.back_camera=Me.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=i,this.down_camera.isShadowCamera=i,this.left_camera.isShadowCamera=i,this.right_camera.isShadowCamera=i,this.front_camera.isShadowCamera=i,this.back_camera.isShadowCamera=i;let o=1;this.up_camera.perspective(a,o,e,r),this.up_camera.lookAt(g.ZERO,g.UP,g.DOWN),this.up_camera.object3D.scaleX=-1,this.up_camera.object3D.rotationY=180,this.down_camera.perspective(a,o,e,r),this.down_camera.lookAt(g.ZERO,g.DOWN,g.DOWN),this.down_camera.object3D.scaleX=-1,this.down_camera.object3D.rotationY=180,this.left_camera.perspective(a,o,e,r),this.left_camera.lookAt(g.ZERO,g.LEFT),this.left_camera.object3D.scaleX=-1,this.right_camera.perspective(a,o,e,r),this.right_camera.lookAt(g.ZERO,g.RIGHT),this.right_camera.object3D.scaleX=-1,this.front_camera.perspective(a,o,e,r),this.front_camera.lookAt(g.ZERO,g.FORWARD),this.front_camera.object3D.scaleX=-1,this.back_camera.perspective(a,o,e,r),this.back_camera.lookAt(g.ZERO,g.BACK),this.back_camera.object3D.scaleX=-1,this.up_camera.type=Ne.shadow,this.down_camera.type=Ne.shadow,this.left_camera.type=Ne.shadow,this.right_camera.type=Ne.shadow,this.front_camera.type=Ne.shadow,this.back_camera.type=Ne.shadow}}class _h extends rt{constructor(t,e,r){super(t,e,r),this.format=H.depth32float,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="cube-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:6*this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"cube-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=R.device.createSampler({minFilter:Tr.linear,magFilter:Tr.linear}),this.gpuSampler_comparison=R.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Th extends nr{constructor(){super();s(this,"shadowPassCount");s(this,"_forceUpdate",!1);s(this,"_shadowCameraDic");s(this,"shadowCamera");s(this,"cubeArrayTexture");s(this,"colorTexture");s(this,"shadowSize",1024);this.passType=W.POINT_SHADOW,this._shadowCameraDic=new Map,this.cubeArrayTexture=new _h(this.shadowSize,this.shadowSize,8),this.colorTexture=new _t(this.shadowSize,this.shadowSize,H.bgra8unorm,!1),ae.getInstance().attached(this.cubeArrayTexture,this)}getShadowCamera(e,r){let a;if(this._shadowCameraDic.has(r))a=this._shadowCameraDic.get(r);else{let i=new bh(e.camera.near,e.camera.far,90,!0);i.label=r.name;let o=[],l=[];for(let h=0;h<6;h++){let c=new _t(this.shadowSize,this.shadowSize,this.cubeArrayTexture.format,!1),u=new sr([this.colorTexture],[new Ot]);c.name="shadowDepthTexture_"+r.name+h+"_face",o[h]=c,u.depthTexture=c,u.label="shadowRender",u.customSize=!0,l[h]=this.getRenderContext(u)}a={cubeCamera:i,depthTexture:o,renderContext:l},this._shadowCameraDic.set(r,a)}return a}render(e,r){if(!C.setting.shadow.enable)return;this.shadowPassCount=0,e.camera;let a=e.scene,i=mt.getPointShadowLightWhichScene(a),o=i.length;for(let l=0;l<o;l++){let h=i[l];if(h.lightData.lightType!=De.DirectionLight&&h.lightData.castShadowIndex>-1&&(h.needUpdateShadow||this._forceUpdate||Ae.frame<5||h.realTimeShadow)){h.needUpdateShadow=!1;let c=this.getShadowCamera(e,h),u=h.transform.worldPosition;c.cubeCamera.x=u.x,c.cubeCamera.y=u.y,c.cubeCamera.z=u.z;let d;c.cubeCamera.transform.updateWorldMatrix(!0),r.update(c.cubeCamera.right_camera,a),d=P.instance.getRenderNodes(a,c.cubeCamera.right_camera),this.renderSceneOnce(0,c,e,c.cubeCamera.right_camera,d,r),r.update(c.cubeCamera.left_camera,a),d=P.instance.getRenderNodes(a,c.cubeCamera.left_camera),this.renderSceneOnce(1,c,e,c.cubeCamera.left_camera,d,r),r.update(c.cubeCamera.up_camera,a),d=P.instance.getRenderNodes(a,c.cubeCamera.up_camera),this.renderSceneOnce(2,c,e,c.cubeCamera.up_camera,d,r),r.update(c.cubeCamera.down_camera,a),d=P.instance.getRenderNodes(a,c.cubeCamera.down_camera),this.renderSceneOnce(3,c,e,c.cubeCamera.down_camera,d,r),r.update(c.cubeCamera.front_camera,a),d=P.instance.getRenderNodes(a,c.cubeCamera.front_camera),this.renderSceneOnce(4,c,e,c.cubeCamera.front_camera,d,r),r.update(c.cubeCamera.back_camera,a),d=P.instance.getRenderNodes(a,c.cubeCamera.back_camera),this.renderSceneOnce(5,c,e,c.cubeCamera.back_camera,d,r);let f=S.beginCommandEncoder();for(let A=0;A<6;A++)f.copyTextureToTexture({texture:c.depthTexture[A].getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.cubeArrayTexture.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:h.shadowIndex*6+A}},{width:this.shadowSize,height:this.shadowSize,depthOrArrayLayers:1});S.endCommandEncoder(f)}}this._forceUpdate=!1}renderSceneOnce(e,r,a,i,o,l){let h=r.renderContext[e];h.clean(),h.beginOpaqueRenderPass(),h.encoder.setViewport(0,0,this.shadowSize,this.shadowSize,0,1),h.encoder.setScissorRect(0,0,this.shadowSize,this.shadowSize),i.onUpdate(),i.transform.updateWorldMatrix(!0);for(const c of o.opaqueList){let u=c;if(!u.isDestroyed&&u.preInit(this._rendererType)){u.nodeUpdate(a,this._rendererType,h.rendererPassState,null);break}}this.drawShadowRenderNodes(a,i,h,o.opaqueList,l),this.drawShadowRenderNodes(a,i,h,o.transparentList,l),h.endRenderPass()}drawShadowRenderNodes(e,r,a,i,o){ce.updateCameraGroup(r),S.bindCamera(a.encoder,r),e.scene,e.camera,this.drawNodes(e,r,a,i,o,null)}drawNodes(e,r,a,i,o,l){let h=P.instance.getRenderShaderCollect(e);if(h){for(const c of h){let u=c[1];for(const d of u){let f=d[1];if(!f.isDestroyed&&f.preInit(this._rendererType)){f.nodeUpdate(e,this._rendererType,a.rendererPassState,l);break}}}for(let c=C.setting.render.drawOpMin;c<Math.min(i.length,C.setting.render.drawOpMax);++c){let u=i[c];if(u.transform.enable&&u.enable&&u.castShadow&&!u.isDestroyed){u.preInit(this._rendererType)||u.nodeUpdate(e,this._rendererType,a.rendererPassState,l);for(let d of u.materials){let f=d.getPass(this._rendererType);if(!(!f||f.length==0))for(let A of f){const p=A;p.pipeline&&(p.setUniformFloat("cameraFar",r.far),p.setUniformVector3("lightWorldPos",r.transform.worldPosition),p.materialDataUniformBuffer.apply())}}u.renderPass(e,this.passType,a)}}}}}class wh extends rt{constructor(t,e,r=H.depth32float,a=4){super(t,e,a),this.format=r,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=R.device.createSampler({}),this.gpuSampler_comparison=R.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Dh extends nr{constructor(){super();s(this,"shadowPassCount");s(this,"depth2DArrayTexture");s(this,"rendererPassStates");s(this,"_forceUpdate",!1);s(this,"_shadowPos",new g);s(this,"_shadowCameraTarget",new g);this.setShadowMap(C.setting.shadow.shadowSize,zt.Cascades),this.passType=W.SHADOW}setShadowMap(e,r){this.rendererPassStates=[],this.depth2DArrayTexture=new wh(e,e,H.depth32float,8),ae.getInstance().attached(this.depth2DArrayTexture,this);for(let a=0;a<8;a++){let i=new sr([],[]);const o=new _t(e,e,H.depth32float,!1);o.name=`shadowDepthTexture_${a}`,i.depthTexture=o,i.label="shadowRender",i.customSize=!0,i.depthCleanValue=1;let l=rr.createRendererPassState(i);this.rendererPassStates[a]=l}}render(e,r){let a=C.setting.shadow;if(!a.enable)return;let i=e.camera,o=e.scene;if(this.shadowPassCount=0,!a.needUpdate||Ae.frame%a.updateFrameRate!=0)return;let l=mt.getDirectShadowLightWhichScene(o),h=a.shadowSize;const c=zt.Cascades;for(let u of l){const d=u;let f=d.shadowIndex;this.rendererPassState=this.rendererPassStates[f],h=this.rendererPassState.depthTexture.width;let A=P.instance.getRenderShaderCollect(e);for(const p of A){let B=p[1];for(const F of B){let U=F[1];if(!U.isDestroyed&&U.preInit(this._rendererType)){U.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}if(d.castShadow&&d.needUpdateShadow||this._forceUpdate||d.castShadow&&a.autoUpdate)if(d.needUpdateShadow=!1,i.enableCSM&&f==0)for(let p=0;p<c;p++){this.rendererPassState=this.rendererPassStates[p];let B=i.csm.children[p],F=i.getCSMShadowWorldExtents(p);this.poseShadowCamera(i,d.direction,B.shadowCamera,F,B.bound.center),this.renderShadow(e,B.shadowCamera,r,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,p,h)}else{i.enableCSM&&(f+=c-1);let p=i.getShadowWorldExtents();this.rendererPassState=this.rendererPassStates[f],this.poseShadowCamera(i,d.direction,d.shadowCamera,p,i.lookTarget),this.renderShadow(e,d.shadowCamera,r,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,f,h)}}this._forceUpdate=!1}copyDepthTexture(e,r,a,i){let o=S.beginCommandEncoder();o.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:a}},{width:i,height:i,depthOrArrayLayers:1}),S.endCommandEncoder(o)}poseShadowCamera(e,r,a,i,o){this._shadowPos.copy(r).normalize(e.far),o.add(this._shadowPos,this._shadowCameraTarget),o.subtract(this._shadowPos,this._shadowPos),a.transform.lookAt(this._shadowPos,this._shadowCameraTarget),a.orthoOffCenter(-i,i,-i,i,e.near,e.far*2)}compute(){}renderShadow(e,r,a,i){let o=P.instance.getRenderNodes(e.scene,r),l=S.beginCommandEncoder(),h=S.beginRenderPass(l,i);r.transform.updateWorldMatrix(),a.update(r,e.scene),a.collect(o,r),ce.updateCameraGroup(r),S.bindCamera(h,r);let c=this.renderShadowBundleOp(e,r,i),u=this.renderShadowBundleTr(e,r,i);c.length>0&&h.executeBundles(c),this.drawShadowRenderNodes(e,r,h,o.opaqueList),u.length>0&&h.executeBundles(u),this.drawShadowRenderNodes(e,r,h,o.transparentList),S.endPass(h),S.endCommandEncoder(l)}renderShadowBundleOp(e,r,a){let i=P.instance.getOpRenderGroup(e.scene);if(i){let o=[];return i.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))o.push(l.bundleMap.get(this._rendererType));else{let h=S.recordBundleEncoder(a.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,r,h,l.renderNodes);let c=h.finish();l.bundleMap.set(this._rendererType,c),o.push(c)}}),o}return[]}renderShadowBundleTr(e,r,a){let i=P.instance.getTrRenderGroup(e.scene);if(i){let o=[];return i.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))o.push(l.bundleMap.get(this._rendererType));else{let h=S.recordBundleEncoder(a.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,r,h,l.renderNodes);let c=h.finish();l.bundleMap.set(this._rendererType,c),o.push(c)}}),o}return[]}recordShadowRenderBundleNode(e,r,a,i,o){if(ce.updateCameraGroup(r),S.bindCamera(a,r),i){S.bindGeometryBuffer(a,i[0].geometry);for(let l=0;l<i.length;++l){let h=i[l];h.transform.enable&&h.recordRenderPass2(e,this._rendererType,this.rendererPassState,o,a)}}}drawShadowRenderNodes(e,r,a,i,o){if(ce.updateCameraGroup(r),S.bindCamera(a,r),i)for(let l=C.setting.render.drawOpMin;l<Math.min(i.length,C.setting.render.drawOpMax);++l){let h=i[l];h.transform.enable&&h.enable&&h.castShadow&&(h.isDestroyed||(h.preInit(this._rendererType)||h.nodeUpdate(e,this._rendererType,this.rendererPassState,o),h.renderPass2(e,this._rendererType,this.rendererPassState,o,a)))}}}class Vh extends nr{constructor(){super();s(this,"zBufferTexture");s(this,"useRenderBundle",!1);s(this,"shadowPassCount");s(this,"zCullingCompute");this.passType=W.DEPTH;let e=R.presentationSize,r=1;this.zBufferTexture=xt.createRTTexture(ze.zBufferTexture_NAME,Math.floor(e[0]*r),Math.floor(e[1]*r),H.rgba16float,!1);let a=new Ot;a.clearValue=[0,0,0,0],a.loadOp="clear";let i=new sr([],[],xt.createRTTexture(ze.zPreDepthTexture_NAME,Math.floor(e[0]),Math.floor(e[1]),H.depth32float,!1),null,!1);this.setRenderStates(i)}render(e,r){let a=e.camera,i=e.scene;S.cleanCache(),ve.start("DepthPass Renderer");let o=i;this.rendererPassState.camera3D=a;let l=P.instance.getRenderNodes(o,a);this.compute(e,r);let h=this.renderBundleOp(e,l,r),c=[],u=S.beginCommandEncoder(),d=S.beginRenderPass(u,this.rendererPassState);h.length>0&&d.executeBundles(h);let f=P.instance.getRenderShaderCollect(e);for(const A of f){let p=A[1];for(const B of p){let F=B[1];if(!F.isDestroyed&&F.preInit(this._rendererType)){F.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}this.drawRenderNodes(e,d,u,l.opaqueList,r),c.length>0&&d.executeBundles(c),S.endPass(d),S.endCommandEncoder(u),ve.end("DepthPass Renderer")}drawRenderNodes(e,r,a,i,o,l){S.bindCamera(r,e.camera);for(let h=C.setting.render.drawOpMin;h<Math.min(i.length,C.setting.render.drawOpMax);++h){let c=i[h];c.transform.enable&&c.enable&&(c.isDestroyed||(c.preInit(this._rendererType)||c.nodeUpdate(e,this._rendererType,this.rendererPassState),c.renderPass2(e,this._rendererType,this.rendererPassState,l,r)))}}}class Nh{constructor(){s(this,"map");s(this,"passRendererList");this.map=new Map,this.passRendererList=[]}addRenderer(t){this.map.has(t.passType)?console.error("same renderer pass repeat!"):(this.map.set(t.passType,t),t.passType<=8&&this.addPassRenderer(t))}getRenderer(t){return this.map.get(t)}addPassRenderer(t){this.passRendererList.push(t)}getAllRenderer(){return this.map}getAllPassRenderer(){return this.passRendererList}}class Mh extends nr{constructor(){super();s(this,"finalQuadView");s(this,"postList");this._rendererType=W.POST,this.postList=new Map,this.initRenderer()}initRenderer(){N.register("FullQuad_vert_wgsl",$o),this.finalQuadView=new nn("Quad_vert_wgsl","Quad_frag_wgsl",new sr([],[]),0,!1)}attachPost(e,r){r.postRenderer=this;let a=r.constructor.name;this.postList.get(a)||(this.postList.set(a,r),r.onAttach(e))}detachPost(e,r){let a=r.constructor.name,i=this.postList.get(a);return i&&(this.postList.delete(a),r.onDetach(e),r.postRenderer=null),i!=null}render(e){this.postList.forEach(a=>{a.enable&&a.compute(e)});let r=S.beginCommandEncoder();this.postList.forEach(a=>{a.enable&&(a.render(e,r),a.rendererPassState&&(S.lastRenderPassState=a.rendererPassState))}),S.endCommandEncoder(r)}presentContent(e,r){let a=S.beginCommandEncoder();this.finalQuadView.renderToViewQuad(e,this.finalQuadView,a,r),S.endCommandEncoder(a)}}class Ei{constructor(){s(this,"enable",!0);s(this,"postRenderer");s(this,"rendererPassState");s(this,"rtViewQuad");s(this,"virtualTexture");this.rtViewQuad=new Map,this.virtualTexture=new Map,R.addEventListener(pr.RESIZE,this.onResize,this)}createRTTexture(t,e,r,a,i=!1,o=0){let l=xt.createRTTexture(t,e,r,a,i,o);return l.name=t,this.virtualTexture.set(t,l),ae.getInstance().attached(l,this),l}createViewQuad(t,e,r,a=0){let i=xt.createViewQuad(t,"Quad_vert_wgsl",e,r,a);return this.rtViewQuad.set(t,i),i}getLastRenderTexture(){let t,e=S.lastRenderPassState.renderTargets;return e.length>0?t=e[0]:t=xt.getTexture(ze.colorBufferTex_NAME),t}compute(t){}onAttach(t){}onDetach(t){}onResize(){}render(t,e){}destroy(t){this.postRenderer=null;for(let e=0;e<this.rtViewQuad.size;e++)this.rtViewQuad.values[e].destroy(t);this.rtViewQuad.clear(),this.rtViewQuad=null;for(let e=0;e<this.virtualTexture.size;e++){const r=this.virtualTexture.values[e];ae.getInstance().detached(r,this),r.destroy(t)}}}class ln extends ie{constructor(e=.001,r=1e4,a=90,i=!1){super();s(this,"up_camera");s(this,"down_camera");s(this,"left_camera");s(this,"right_camera");s(this,"front_camera");s(this,"back_camera");s(this,"_near");s(this,"_far");this.initCubeCamera(e,r,a,i)}initCubeCamera(e,r,a=90,i=!1){this.up_camera=Me.createCamera3DObject(this,"up"),this.down_camera=Me.createCamera3DObject(this,"down"),this.left_camera=Me.createCamera3DObject(this,"left"),this.right_camera=Me.createCamera3DObject(this,"right"),this.front_camera=Me.createCamera3DObject(this,"front"),this.back_camera=Me.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=i,this.down_camera.isShadowCamera=i,this.left_camera.isShadowCamera=i,this.right_camera.isShadowCamera=i,this.front_camera.isShadowCamera=i,this.back_camera.isShadowCamera=i;let o=1;this.up_camera.perspective(a,o,e,r),this.up_camera.lookAt(g.ZERO,g.UP,g.DOWN),this.down_camera.perspective(a,o,e,r),this.down_camera.lookAt(g.ZERO,g.DOWN,g.DOWN),this.left_camera.perspective(a,o,e,r),this.left_camera.lookAt(g.ZERO,g.LEFT),this.right_camera.perspective(a,o,e,r),this.right_camera.lookAt(g.ZERO,g.RIGHT),this.front_camera.perspective(a,o,e,r),this.front_camera.lookAt(g.ZERO,g.FORWARD),this.back_camera.perspective(a,o,e,r),this.back_camera.lookAt(g.ZERO,g.BACK),this.up_camera.type=Ne.shadow,this.down_camera.type=Ne.shadow,this.left_camera.type=Ne.shadow,this.right_camera.type=Ne.shadow,this.front_camera.type=Ne.shadow,this.back_camera.type=Ne.shadow}set near(e){this._near=e,this.up_camera.near=e,this.down_camera.near=e,this.left_camera.near=e,this.right_camera.near=e,this.front_camera.near=e,this.back_camera.near=e}get near(){return this._near}set far(e){this._far=e,this.up_camera.far=e,this.down_camera.far=e,this.left_camera.far=e,this.right_camera.far=e,this.front_camera.far=e,this.back_camera.far=e}get far(){return this._far}}let kh=`
    // input reflection buffer texture
    // sample prefiltered cube uv texture 
    // storge info to oct map 
    #include "GenerayRandomDir"
    #include "BitUtil"
    #include "MathShader"
    #include "ColorUtil_frag"
    
    struct UniformData{
        probeSize : f32 ,
        probeCount : f32 ,
        width : f32 ,
        height : f32 ,
    }

    @group(0) @binding(0) var inputTex : texture_2d<f32>;
    @group(0) @binding(1) var outputTexture : texture_storage_2d<rgba16float, write>;//rgba32float rgba16float
    @group(1) @binding(0) var<uniform> uniformData:UniformData;//rgba32float

    var<private> reflectionSize : vec2f ; 
    var<private> PROBE_SOURCESIZE : vec2f ; 
    var<private> PROBEMAP_SOURCESIZE : vec2f ; 
    var<private> aspect : vec2f ; 
    var<private> spaceV : f32 ; 
    
    var<private> i32InputFragCoord : vec2i;
    var<private> PI_2 : f32 = 3.1415926 * 2.0 ;
    var<private> PI : f32 = 3.1415926 ;

    var<private> probeSize : f32 = 256.0 ;
    var<private> probeCount : f32 = 8.0 ;
    var<private> faceCount : f32 = 6.0 ;
    var<private> mipCount : f32 = 8.0 ;

    const NUM_SAMPLES = 256u;
    var<private> inputSize : vec2f ; 
    var<private> outSize : vec2f ; 

    fn useSphereReflection(){
        probeSize = uniformData.probeSize ;
        probeCount = uniformData.probeCount;
        reflectionSize = vec2f(textureDimensions(inputTex).xy);
        PROBE_SOURCESIZE = reflectionSize / vec2f(faceCount,probeCount);
        PROBEMAP_SOURCESIZE = reflectionSize ;
        aspect = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
        spaceV = 1.0 / probeCount ;
    }

    @compute @workgroup_size( 16 , 16 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
        var color : vec4f ;
        useSphereReflection();
        inputSize = vec2f(textureDimensions(inputTex).xy);
        outSize = vec2f(textureDimensions(outputTexture).xy);
        
        i32InputFragCoord = vec2<i32>( globalInvocation_id.xy ) ;

        let i = f32(globalInvocation_id.z) ;
        let count = floor(i / mipCount) ;
        preOneMip(count,floor(i % mipCount));
    }

    fn preOneMip( gid:f32,mip:f32 ){
        let isuv = vec2f(i32InputFragCoord) ;
        let suv = isuv * (inputSize/outSize);
        let probeID = i32(floor(suv.y / probeSize));
        let mipID = i32((isuv.x / probeSize));
        if(probeID == i32(gid) && mipID == i32(mip)){

            let sphereUV = vec2f((isuv.x+0.5) % (probeSize),(isuv.y+0.5) % probeSize) / vec2f( (probeSize), probeSize ) ;
            var dir: vec3<f32> = octDecode(sphereUV * 2.0 - 1.0) ;
            var preColor = PreFilterEnvMap(mip/mipCount + 0.05,dir,gid);
            textureStore(outputTexture,vec2i(i32InputFragCoord),preColor);
        }
    }

    fn PreFilterEnvMap( roughness2:f32,  R:vec3f , gid:f32 ) -> vec4f
    {
        var resColor = vec3f(0.0f);  
        var resDepth = 0.0;  

        var totalColorWeight = 0.0f;   
        var totalDepthWeight = 0.0f;   
        
        var normal = normalize(R);
        var toEye = normal;
        
        var roughness = roughness2;
        
        for(var i=1u;i<=NUM_SAMPLES;i+=1u)
        {
            var xi:vec2f = hammersley(i, NUM_SAMPLES) ; 
            
            var halfway = ImportanceSampleGGX(xi,roughness,normal);
            var lightVec = 2.0f * dot( toEye,halfway ) * halfway - toEye;
            
            var NdotL = dot( normal, lightVec )  ;
            var NdotH = max(0.0,dot( normal, halfway ))  ;
            var HdotV = max(0.0,dot( halfway, toEye ))  ;
            
            if( NdotL > 0.0 )
            {
                var D = specularD(roughness,NdotH);
                var pdf = (D * NdotH / (4.0 * HdotV)) + 0.0001f  ;

                var saSample = 1.0f / (f32(NUM_SAMPLES) * pdf + 0.00001f);
                lightVec = normalize(lightVec);

                var buffer = getReflectionsMap(lightVec,gid); 
                var rgb = unpack4x8unorm(u32(buffer.z)).rgb;
                var m = unpack4x8unorm(u32(buffer.w)).z;
                var rgbmColor = DecodeRGBM(vec4f(rgb,m));
                resDepth += buffer.x ;
                resColor += rgbmColor * NdotL;

                totalColorWeight += NdotL;
                totalDepthWeight += 1.0;
            }
        }

        resDepth = resDepth / max(totalDepthWeight,0.001f);
        resColor = resColor / max(totalColorWeight,0.001f);
        
        let rgbm = EncodeRGBM(resColor) ; 
        let gBuffer = vec4f(
            resDepth,
            0.0,
            f32(pack4x8unorm(vec4f(rgbm.rgb,0.0))),
            f32(pack4x8unorm(vec4f(0.0,0.0,rgbm.w,0.0))),
        ) ;
        // return gBuffer ;
        return vec4f(resColor,1.0) ;
    } 

    fn getReflectionsMap(n:vec3<f32>,gid:f32) -> vec4f {
        var uv = getSampleProbeUV(n,gid);
        let color = textureLoad(inputTex, vec2i(uv*inputSize) , 0);
        return color ;
    }

    fn getSampleProbeUV(dir:vec3<f32>,gid:f32) -> vec2<f32> {
        let faceId = dir_to_faceId(dir);
        var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
        targetUV.x = 1.0 - targetUV.x;
        let threshould = 0.5 / PROBE_SOURCESIZE;
        targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));
        targetUV.x = f32(faceId) + targetUV.x;
        let aspect:vec2f = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
        targetUV = targetUV * aspect ;
        targetUV.y = targetUV.y + (spaceV * gid);
        return targetUV ;
     }

    fn radicalInverse_VdC( bits2:u32) -> f32
    {
        var bits = bits2; 
        bits = (bits << 16u) | (bits >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        return f32(bits) * 2.3283064365386963e-10f; // / 0x100000000
    }

    fn hammersley( i:u32, N:u32) -> vec2f
    {
        return vec2f(f32(i) / f32(N), radicalInverse_VdC(i));
    }

    fn ImportanceSampleGGX( xi:vec2f,  roughness:f32,  N:vec3f) -> vec3f
    {
        var alpha2 = roughness * roughness * roughness * roughness;
        
        var phi = 2.0f * 3.1415926 * xi.x  ;
        var cosTheta = sqrt( (1.0f - xi.y) / (1.0f + (alpha2 - 1.0f) * xi.y ));
        var sinTheta = sqrt( 1.0f - cosTheta*cosTheta );
        
        var h : vec3f ;
        h.x = sinTheta * cos( phi );
        h.y = sinTheta * sin( phi );
        h.z = cosTheta;
        
        var up = vec3f(1,0,0) ;
        if(abs(N.z) < 0.9999){
            up = vec3f(0,0,1) ;
        }

        var tangentX = normalize( cross( up, N ) );
        var tangentY = cross( N, tangentX );
        return (tangentX * h.x + tangentY * h.y + N * h.z);
    } 

    fn  specularD( roughness:f32,  NoH:f32) -> f32
    {
        var NoH2 = NoH * NoH;
        var r2 = roughness * roughness;
        return r2 / pow(NoH2 * (r2 - 1.0) + 1.0, 2.0);
    }
    
`;class Ph extends nr{constructor(){super();s(this,"cubeCamera");s(this,"gBuffer");s(this,"sizeW",0);s(this,"sizeH",0);s(this,"probeSize",64);s(this,"probeCount",32);s(this,"mipCount",8);s(this,"preFilteredEnvironmentCompute");s(this,"outTexture");s(this,"preFilteredEnvironmentUniform");s(this,"onChange",!0);s(this,"needUpdate",!0);this.passType=W.REFLECTION,this.cubeCamera=new ln(.01,5e3);let e=1;this.probeSize=C.setting.reflectionSetting.reflectionProbeSize,this.probeCount=C.setting.reflectionSetting.reflectionProbeMaxCount,this.sizeW=C.setting.reflectionSetting.width,this.sizeH=C.setting.reflectionSetting.height,this.gBuffer=Le.getGBufferFrame(Le.reflections_GBuffer,this.sizeW,this.sizeH,!1),this.setRenderStates(this.gBuffer),this.outTexture=new _t(this.probeSize*this.mipCount,this.sizeH,H.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,1,0,e),this.outTexture.name="texture_AAA",this.preFilteredEnvironmentUniform=new aa(4+this.probeCount*4),this.preFilteredEnvironmentUniform.setFloat("probeSize",this.probeSize),this.preFilteredEnvironmentUniform.setFloat("probeCount",this.probeCount),this.preFilteredEnvironmentUniform.setFloat("width",this.sizeW),this.preFilteredEnvironmentUniform.setFloat("height",this.sizeH),this.preFilteredEnvironmentUniform.apply(),this.preFilteredEnvironmentCompute=new bt(kh),this.preFilteredEnvironmentCompute.setSamplerTexture("inputTex",this.gBuffer.getCompressGBufferTexture()),this.preFilteredEnvironmentCompute.setStorageTexture("outputTexture",this.outTexture),this.preFilteredEnvironmentCompute.setUniformBuffer("uniformData",this.preFilteredEnvironmentUniform)}forceUpdate(){this.onChange=!0}compute(e,r){if(this.needUpdate){this.needUpdate=!1;let a=ce.getReflectionEntries(e.scene);a.reflectionMap=this.outTexture,this.preFilteredEnvironmentCompute.workerSizeX=Math.ceil(this.probeSize*this.mipCount/16),this.preFilteredEnvironmentCompute.workerSizeY=Math.ceil(this.sizeH/16),this.preFilteredEnvironmentCompute.workerSizeZ=this.mipCount*a.count;let i=S.beginCommandEncoder();S.computeCommand(i,[this.preFilteredEnvironmentCompute]),S.endCommandEncoder(i)}}render(e,r,a,i=!1,o=!1){this.renderContext.clean();let l=this.probeSize,h=this.probeSize,c=P.instance.getReflections(e.scene);for(let u=0;u<c.length;u++){let d=c[u];if(d.autoUpdate&&(d.needUpdate||this.onChange)||Ae.frame<10){d.needUpdate=!1,this.needUpdate=!0,this.renderContext.beginOpaqueRenderPass();let f=this.renderContext.encoder,A=u*h;c[u].transform.updateWorldMatrix();let p=c[u].transform.worldPosition;this.cubeCamera.x=p.x,this.cubeCamera.y=p.y,this.cubeCamera.z=p.z,this.cubeCamera.far=1e4,this.cubeCamera.transform.updateWorldMatrix(),f.setViewport(l*0,A,l,h,0,1),this.renderOnce(e,this.cubeCamera.right_camera,f,r,a,i),f.setViewport(l*1,A,l,h,0,1),this.renderOnce(e,this.cubeCamera.left_camera,f,r,a,i),f.setViewport(l*2,A,l,h,0,1),this.renderOnce(e,this.cubeCamera.up_camera,f,r,a,i),f.setViewport(l*3,A,l,h,0,1),this.renderOnce(e,this.cubeCamera.down_camera,f,r,a,i),f.setViewport(l*4,A,l,h,0,1),this.renderOnce(e,this.cubeCamera.front_camera,f,r,a,i),f.setViewport(l*5,A,l,h,0,1),this.renderOnce(e,this.cubeCamera.back_camera,f,r,a,i),this.renderContext.endRenderPass()}}this.onChange=!1}renderOnce(e,r,a,i,o,l=!1){let h=e.scene;r.transform.scene3D=h,this.rendererPassState.camera3D=r;let c=P.instance.getRenderNodes(h,r);{let u=a;ce.updateCameraGroup(r),!l&&P.instance.sky&&(S.bindCamera(u,r),P.instance.sky.preInit(W.REFLECTION)||P.instance.sky.nodeUpdate(e,W.REFLECTION,this.rendererPassState,o),P.instance.sky.renderPass2(e,W.REFLECTION,this.rendererPassState,o,u)),c.opaqueList&&(S.bindCamera(u,r),this.drawNodes(e,this.renderContext,c.opaqueList,i,o)),!l&&c.transparentList&&(S.bindCamera(u,r),this.drawNodes(e,this.renderContext,c.transparentList,i,o))}}drawNodes(e,r,a,i,o){let l=P.instance.getRenderShaderCollect(e);if(l){for(const h of l){let c=h[1];for(const u of c){let d=u[1];if(!d.hasMask(de.ReflectionDebug)&&!d.isDestroyed&&d.preInit(W.REFLECTION)){d.nodeUpdate(e,W.REFLECTION,this.rendererPassState,o);break}}}for(let h=0;h<a.length;h++){let c=a[h];c.hasMask(de.ReflectionDebug)||c.transform.enable&&c.enable&&(c.isDestroyed||(c.preInit(W.REFLECTION)||c.nodeUpdate(e,W.REFLECTION,this.rendererPassState,o),c.renderPass(e,W.REFLECTION,this.renderContext)))}}}occlusionRenderNodeTest(e,r,a){return!0}}let Lh=`
    #include 'BitUtil'
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> varying_uv: vec2<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;
    // @group(1) @binding(2)
    // var gBuffer: texture_2d<f32>;

    struct MaterialUniform{
        u_texel: vec2<f32>,
        u_strength: f32,
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;


    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3<f32> {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r,0.416666667);
        linRGB.g = pow(linRGB.g,0.416666667);
        linRGB.b = pow(linRGB.b,0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    fn texture2D( uv:vec2<f32> , offset:vec2<f32> ) -> vec4<f32> {
        let buffer = textureSample(baseMap, baseMapSampler, uv.xy + offset ).rgba ;
        return buffer ;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var v_vTexcoord = fragUV ;
        // v_vTexcoord.x = 1.0 - v_vTexcoord.x ;
        v_vTexcoord.y = 1.0 - v_vTexcoord.y ;

        var reducemul = 1.0 / 8.0;
        var reducemin = 1.0 / 128.0;

        var basecol = texture2D(v_vTexcoord , vec2<f32>(0.0)).rgba;
        var baseNW = texture2D(v_vTexcoord , -materialUniform.u_texel).rgb;
        var baseNE = texture2D(v_vTexcoord , vec2<f32>(materialUniform.u_texel.x, -materialUniform.u_texel.y)).rgb;
        var baseSW = texture2D(v_vTexcoord , vec2<f32>(-materialUniform.u_texel.x, materialUniform.u_texel.y)).rgb;
        var baseSE = texture2D(v_vTexcoord , materialUniform.u_texel ).rgb;

        // var gray = vec3<f32>(0.299, 0.587, 0.114);
        var gray = vec3<f32>(0.213, 0.715, 0.072);
        var monocol = dot(basecol.rgb, gray);
        var monoNW = dot(baseNW, gray);
        var monoNE = dot(baseNE, gray);
        var monoSW = dot(baseSW, gray);
        var monoSE = dot(baseSE, gray);

        var monomin = min(monocol, min(min(monoNW, monoNE), min(monoSW, monoSE)));
        var monomax = max(monocol, max(max(monoNW, monoNE), max(monoSW, monoSE)));

        var dir = vec2<f32>(-((monoNW + monoNE) - (monoSW + monoSE)), ((monoNW + monoSW) - (monoNE + monoSE)));
        var dirreduce = max((monoNW + monoNE + monoSW + monoSE) * reducemul * 0.25, reducemin);
        var dirmin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirreduce);
        dir = min(vec2<f32>(materialUniform.u_strength), max(vec2<f32>(-materialUniform.u_strength), dir * dirmin)) * materialUniform.u_texel;

        var resultA = 0.5 * (texture2D(v_vTexcoord , dir * -0.166667).rgb  +
                            texture2D(v_vTexcoord , dir * 0.166667).rgb);
                            
        var resultB = resultA * 0.5 + 0.25 * (texture2D( v_vTexcoord , dir * -0.5).rgb +
                                            texture2D( v_vTexcoord , dir * 0.5).rgb);
        var monoB = dot(resultB.rgb, gray);
        
        var color:vec3<f32> ;
        if(monoB < monomin || monoB > monomax) {
            color = resultA ;//* v_vColour;
        } else {
            color = resultB ;//* v_vColour;
        }
        return FragmentOutput(vec4<f32>(color.rgb,basecol.a));
    }
`;class hn extends Ei{constructor(){super();s(this,"postQuad");s(this,"renderTexture");let[e,r]=R.presentationSize;N.register("FXAA_Shader",Lh),this.renderTexture=this.createRTTexture("FXAAPost",e,r,H.rgba16float),this.postQuad=this.createViewQuad("fxaa","FXAA_Shader",this.renderTexture),this.postQuad.quadShader.setUniform("u_texel",new Ie(1/e,1/r)),this.postQuad.quadShader.setUniform("u_strength",4)}onResize(){let[e,r]=R.presentationSize;this.renderTexture.resize(e,r)}onAttach(e){C.setting.render.postProcessing.fxaa.enable=!0}onDetach(e){C.setting.render.postProcessing.fxaa.enable=!1}render(e,r){this.compute(e),this.rtViewQuad.forEach((a,i)=>{let o=S.lastRenderPassState.getLastRenderTexture();a.renderToViewQuad(e,a,r,o)})}}class Oh{constructor(t){s(this,"rendererMap");s(this,"shadowMapPassRenderer");s(this,"pointLightShadowRenderer");s(this,"ddgiProbeRenderer");s(this,"postRenderer");s(this,"clusterLightingRender");s(this,"reflectionRenderer");s(this,"occlusionSystem");s(this,"depthPassRenderer");s(this,"pauseRender",!1);s(this,"pickFire");s(this,"renderState",!1);s(this,"_view");this._view=t,this.rendererMap=new Nh,this.occlusionSystem=new on,this.clusterLightingRender=this.addRenderer(xh,t),this.reflectionRenderer=this.addRenderer(Ph,t),C.setting.render.zPrePass&&(this.depthPassRenderer=this.addRenderer(Vh)),this.shadowMapPassRenderer=new Dh,this.pointLightShadowRenderer=new Th,this.addPost(new hn)}get colorPassRenderer(){return this.rendererMap.getRenderer(W.COLOR)}addRenderer(t,e){let r;return e?r=new t(e):r=new t,this.rendererMap.addRenderer(r),r}get view(){return this._view}set view(t){this._view=t}start(){this.renderState=!0}stop(){}pause(){this.pauseRender=!0}resume(){this.pauseRender=!1}addPost(t){if(!this.postRenderer){let e=Le.getGBufferFrame("ColorPassGBuffer");this.postRenderer=this.addRenderer(Mh),this.postRenderer.setRenderStates(e)}return t instanceof Ei&&this.postRenderer.attachPost(this.view,t),t}removePost(t){if(t instanceof Ei)this.postRenderer.detachPost(this.view,t);else for(let e=0;e<t.length;e++)this.postRenderer.detachPost(this.view,t[e])}renderFrame(){let t=this._view;ve.startView(t),ce.getLightEntries(t.scene).update(t),ce.getReflectionEntries(t.scene).update(t),this.occlusionSystem.update(t.camera,t.scene),this.clusterLightingRender.render(t,this.occlusionSystem),this.shadowMapPassRenderer&&(mt.update(t),this.shadowMapPassRenderer.render(t,this.occlusionSystem)),this.pointLightShadowRenderer&&this.pointLightShadowRenderer.render(t,this.occlusionSystem),this.depthPassRenderer&&(this.depthPassRenderer.compute(t,this.occlusionSystem),this.depthPassRenderer.render(t,this.occlusionSystem)),C.setting.gi.enable&&this.ddgiProbeRenderer&&(this.ddgiProbeRenderer.compute(t,this.occlusionSystem),this.ddgiProbeRenderer.render(t,this.occlusionSystem));let e=this.rendererMap.getAllPassRenderer();for(let i=0;i<e.length;i++){const o=e[i];o.compute(t,this.occlusionSystem),o.render(t,this.occlusionSystem,this.clusterLightingRender.clusterLightingBuffer,!1)}this.postRenderer.render(t);let r=this.rendererMap.getRenderer(W.UI);r.compute(t,this.occlusionSystem),r.render(t,this.occlusionSystem,this.clusterLightingRender.clusterLightingBuffer,!1);let a=Le.getGUIBufferFrame().getColorTexture();this.postRenderer.presentContent(t,a)}debug(){}}class Gh extends sr{constructor(t,e,r=!0){super([],[]),this.crateGBuffer(t,e,r)}crateGBuffer(t,e,r){let a=this.renderTargets,i=this.rtDescriptors,o=new tt(t,e,H.rgba16float,!1,void 0,1,0,!0,r);o.name="positionMap";let l=new Ot;l.loadOp="load";let h=new tt(t,e,H.rgba16float,!1,void 0,1,0,!0,r);h.name="normalMap";let c=new Ot;c.loadOp="load";let u=new tt(t,e,H.rgba16float,!1,void 0,1,0,!0,r);u.name="colorMap";let d=new Ot;d.loadOp="load";let f=new tt(t,e,H.depth24plus,!1,void 0,1,0,!0,r);f.name="depthTexture";let A=new Ot;A.loadOp="load",a.push(o),a.push(h),a.push(u),i.push(l),i.push(c),i.push(d),this.depthTexture=f}}let Wh=`
#include "GenerayRandomDir"
#include "MathShader"
#include "IrradianceVolumeData_frag"
var<private> PI: f32 = 3.14159265359;

struct ProbeData{
  offsetX:f32,
  offsetY:f32,
  offsetZ:f32,
  frame:f32,
}

 struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

struct RayProbeBuffer{
  WPosition: vec3<f32>,
  WNormal:vec3<f32>,
  WRadiance:vec4<f32>,
}

struct CacheHitData{
  color:vec4<f32>,
  depth:vec4<f32>,
}

//  struct RayInfo{
//   rays:array<vec4<f32>,4096>
//  }

@group(0) @binding(0) var<storage, read> probes : array<ProbeData>;
@group(0) @binding(1) var<storage, read_write> irradianceBuffer : array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> depthBuffer : array<vec4<f32>>;
@group(0) @binding(3) var<uniform> uniformData : IrradianceVolumeData ;
@group(0) @binding(4) var probeIrradianceMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(5) var probeDepthMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(6) var<storage, read_write> depthRaysBuffer : array<vec4<f32>>;

@group(1) @binding(0) var positionMap : texture_2d<f32>;
@group(1) @binding(1) var normalMap : texture_2d<f32>;
@group(1) @binding(2) var colorMap : texture_2d<f32>;

@group(2) @binding(0)
var<storage, read> models : Uniforms;

var<private> probeID: u32 ;
var<private> workgroup_idx: u32 ;
var<private> workgroup_idy: u32 ;
var<private> hysteresis: f32 = 0.98 ;
var<private> epsilon: f32 = 1e-6 ;
var<private> probeLocation:vec3<f32> = vec3<f32>(0.0);
var<private> energyConservation: f32 = 0.85 ;
var<private> resultIrradiance: vec4<f32> ;
var<private> resultDepth: vec4<f32> ;
var<private> RAYS_PER_PROBE: f32 = 144.0 ;
var<private> OCT_RT_SIZE: u32;
var<private> PROBE_OCT_RT_SIZE: u32;
var<private> OCT_SIDE_SIZE_u32: u32;
var<private> OCT_SIDE_SIZE_f32: f32;
var<private> OCT_RT_SIZE_f32: f32;
var<private> PROBE_SOURCESIZE: f32;
var<private> PROBEMAP_SOURCESIZE: f32;
var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);
var<private> randomMatrix:mat4x4<f32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   RAYS_PER_PROBE = f32(i32(uniformData.rayNumber));
   OCT_RT_SIZE = u32(uniformData.OctRTMaxSize);
   OCT_RT_SIZE_f32 = f32(uniformData.OctRTMaxSize);
   OCT_SIDE_SIZE_u32 = u32(uniformData.OctRTSideSize);
   OCT_SIDE_SIZE_f32 = f32(uniformData.OctRTSideSize);
   PROBE_SOURCESIZE = f32(uniformData.ProbeSize);
   PROBEMAP_SOURCESIZE = f32(uniformData.ProbeSourceTextureSize);
   hysteresis = uniformData.hysteresis;
    // probe index
    probeID = globalInvocation_id.z ;
    // pixel coord
    workgroup_idx = globalInvocation_id.x ;
    workgroup_idy = globalInvocation_id.y;

    probeLocation = calcProbePosition(probeID);

    resultIrradiance = vec4<f32>(0.0);
    resultDepth = vec4<f32>(0.0,0.0,0.0,0.0);

    var tdr = normalize(getCurrentDir());
    let orientationIndex = u32(uniformData.orientationIndex);
    randomMatrix = models.matrix[orientationIndex];

    var distancePprobeUV = getSampleProbeUV(tdr.xyz);
    var rayUv:vec2<i32> = vec2<i32>(distancePprobeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
    let rayHitPosition = textureLoad(positionMap, rayUv, 0).xyz ;
    
    for(var i:f32 = 0.0; i < RAYS_PER_PROBE ; i = i + 1.0 ){
      radianceProbeOnce(i, tdr);
    }

    if (resultIrradiance.w > epsilon) {
      var color = vec3<f32>(resultIrradiance.xyz/(2.0*resultIrradiance.w)) ;
      color = pow(color.rgb, vec3<f32>(1.0 / uniformData.ddgiGamma));
      resultIrradiance = vec4<f32>(color,1.0-hysteresis);
    }

    // if nonzero
    if (resultDepth.w > epsilon) {
      resultDepth = vec4<f32>(resultDepth.xyz/(2.0*resultDepth.w),1.0-hysteresis) ;
    }

   let pixelCoord = getWriteOctUVByID();

   var lerpDataResult:CacheHitData;

   lerpDataResult.color = resultIrradiance;

   lerpDataResult.depth = resultDepth;

   lerpDataResult = lerpHitData(lerpDataResult, pixelCoord);

   writeRayHitData(pixelCoord, lerpDataResult);

   storePixelAtCoord(probeIrradianceMap, pixelCoord , vec4<f32>(lerpDataResult.color.xyz, 1.0), true);

   storePixelAtCoord(probeDepthMap, pixelCoord , vec4<f32>(resultDepth.xy, 0.0, 1.0), false);
}

fn lerpHitData(data:CacheHitData, coord:vec2<i32>) -> CacheHitData{
   let frameIndex = probes[probeID].frame;
   var newData:CacheHitData = data;

   //if(frameIndex > 1.0){
      var oldData = readRayHitData(coord);
      newData.color = mix(oldData.color, newData.color, uniformData.lerpHysteresis);
      newData.depth = mix(oldData.depth, newData.depth, uniformData.lerpHysteresis);
   //}
   return newData;
}

fn square(v:vec3<f32>) -> vec3<f32>{
   var v3 = v;
   v3.x = v3.x * v3.x;
   v3.y = v3.y * v3.y;
   v3.z = v3.z * v3.z;
   return v3;
}

 fn testSample() ->vec4<f32>{
   var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
   var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
   var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
   var dir = octDecode(uv);
   var probeUV = getSampleProbeUV(dir.xyz);
   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   return rayProbeBuffer.WRadiance;
 }

 fn gridCoordToProbeIndex(grid:vec3<i32>) -> i32
 {
     return grid.x + grid.z * i32(uniformData.gridXCount) + grid.y * i32(uniformData.gridXCount * uniformData.gridZCount);
 }

fn storePixelAtCoord(texture:texture_storage_2d<rgba16float, write>, coord:vec2<i32>, color:vec4<f32>, isColor:bool){
   let sideCnt = i32(OCT_SIDE_SIZE_u32);
   let sideBorderCnt = sideCnt + 2;
   let indexXY = coord / sideCnt;
   let modeXY = coord % sideCnt;

   var newCoord = indexXY * sideBorderCnt + modeXY;
   textureStore(texture, newCoord + 1, color);

   var borderCoord = vec2<i32>(-1);
   //
   if(modeXY.x % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.y = sideCnt - borderCoord.y;
     if(modeXY.x == sideCnt - 1){
       borderCoord.x = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //
   if(modeXY.y % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.x = sideCnt - borderCoord.x;
     if(modeXY.y == sideCnt - 1){
         borderCoord.y = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //
   if(modeXY.x % (sideCnt - 1) == 0 && modeXY.y % (sideCnt - 1) == 0){
      var cornerCoord = modeXY;
      if(modeXY.x == 0){
         cornerCoord.x = sideBorderCnt - 1;
      }else{
         cornerCoord.x = 0;
      }
       if(modeXY.y == 0){
         cornerCoord.y = sideBorderCnt - 1;
      }else{
         cornerCoord.y = 0;
      }
      cornerCoord = indexXY * sideBorderCnt + cornerCoord;
      textureStore(texture, cornerCoord, color);
   }
}

fn calcProbePosition(id:u32) -> vec3<f32>{
   var probeLocation = vec3<f32>(0.0);
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var grid = vec3<u32>(0u);
   grid.x = (id % blockCount) % u32(uniformData.gridXCount);
   grid.y = id / blockCount;
   grid.z = (id % blockCount) / u32(uniformData.gridXCount);
   probeLocation.x = f32(grid.x) * uniformData.ProbeSpace + uniformData.startX;
   probeLocation.y = f32(grid.y) * uniformData.ProbeSpace + uniformData.startY;
   probeLocation.z = f32(grid.z) * uniformData.ProbeSpace + uniformData.startZ;
   return probeLocation;
}

fn getWriteOctUVByID() -> vec2<i32>
{
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var offsetX = (probeID % blockCount) % u32(uniformData.gridXCount) ;
   var offsetY = u32(uniformData.gridZCount - 1.0) - (probeID % blockCount) / u32(uniformData.gridXCount) ;
   var offsetZ = probeID / blockCount ;
   var pixelCoord = vec2<i32>(i32(workgroup_idx), i32(workgroup_idy));
   pixelCoord.x = pixelCoord.x + i32(offsetX * OCT_SIDE_SIZE_u32);
   pixelCoord.y = pixelCoord.y + i32(offsetY * OCT_SIDE_SIZE_u32 + offsetZ * u32(uniformData.gridZCount) * OCT_SIDE_SIZE_u32);

   pixelCoord = offsetByCol(pixelCoord, OCT_SIDE_SIZE_f32, OCT_RT_SIZE, vec3<f32>(uniformData.gridXCount, uniformData.gridYCount, uniformData.gridZCount));
   return pixelCoord;
}

fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
{
 var pixelCoord = pixelCoord0;
 let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
 let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
 let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
 let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
 let col:i32 = pixelCoord.y / pixelCountYMax;

 pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
 pixelCoord.y = pixelCoord.y % pixelCountYMax;

 return pixelCoord;
}

fn radianceProbeOnce(rayID:f32, tdr:vec3<f32>){
   var texelDirection = sphericalFibonacci(rayID, RAYS_PER_PROBE ) ;
   var rayDirection = normalize( vec3<f32>((randomMatrix * vec4<f32>(texelDirection, 1.0)).xyz));
   var probeUV = getSampleProbeUV(rayDirection.xyz);
   var rayWriteUV = getWriteRayInfoUV();

   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   var rayHitLocation = rayProbeBuffer.WPosition + normalize(rayProbeBuffer.WNormal) * 0.01;

   var rayProbeDistance = length(probeLocation - rayHitLocation) ;
   // rayProbeDistance = min(uniformData.ProbeSpace * 4.0, rayProbeDistance) ;

   // if (dot(rayProbeBuffer.WNormal, rayProbeBuffer.WNormal) < epsilon) {
   //   rayProbeDistance = epsilon ;
   // }

   let rid = i32(probeID) * i32(RAYS_PER_PROBE) + i32(rayID) ;
   depthRaysBuffer[rid] = vec4<f32>(rayDirection.xyz,rayProbeDistance) ;

   // Detect misses and force depth
   var i_weight = max(0.0, dot(tdr,rayDirection) );
   var d_weight = pow(i_weight, uniformData.depthSharpness);
   
   if (i_weight >= epsilon) {
     //  var weightColor = pow(weight, (2.0 - uniformData.probeRoughness) * 2.0);
      resultIrradiance += vec4(rayProbeBuffer.WRadiance.rgb, i_weight );
     
   }
   if(d_weight>= epsilon){
       resultDepth += vec4(rayProbeDistance * d_weight, rayProbeDistance * rayProbeDistance * d_weight, 0.0 , i_weight);
   }
}

fn getCurrentRayHitBuffer(probeUV:vec2<f32>) -> RayProbeBuffer {
  var rayProbeBuffer : RayProbeBuffer ;
  var uv:vec2<i32> = vec2<i32>(probeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
  rayProbeBuffer.WPosition = textureLoad(positionMap, uv, 0).xyz ;
  rayProbeBuffer.WNormal = normalize(textureLoad(normalMap, uv, 0).xyz * 2.0 - 1.0);
  rayProbeBuffer.WRadiance = textureLoad(colorMap, uv, 0).xyzw * energyConservation;
  return rayProbeBuffer ;
}

fn getSampleProbeUV(dir0:vec3<f32>) -> vec2<f32> {
   var dir = applyQuaternion(dir0, quaternion);
   let faceId = dir_to_faceId(dir);
   var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
   targetUV.x = 1.0 - targetUV.x;
   let threshould = 0.5 / PROBE_SOURCESIZE;
   targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));

   targetUV.x = f32(faceId) + targetUV.x;

   let aspect:f32 = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
   targetUV = targetUV * aspect ;

   var fullCol = u32(PROBEMAP_SOURCESIZE) / u32(PROBE_SOURCESIZE);
   var offsetSampleUv = vec2<f32>( f32(probeID / fullCol) * 6.0 , f32(probeID % fullCol)) * aspect;
   return targetUV + offsetSampleUv;
}

fn getWriteRayInfoUV() -> vec2<i32> {
  var writeUV = vec2<i32>(i32(workgroup_idy),i32(probeID)) ;
  return writeUV ;
}

fn writeRayHitData( uv:vec2<i32> , data:CacheHitData){
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  irradianceBuffer[index] = data.color ;
  depthBuffer[index] = data.depth ;
}

fn readRayHitData( uv:vec2<i32> ) -> CacheHitData{
  var data:CacheHitData;
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  data.color = irradianceBuffer[index] ;
  data.depth = depthBuffer[index] ;
  return data;
}

fn getCurrentDir() -> vec3<f32> {
  var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
  var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
  var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
  var dir = octDecode(uv) ;
  return normalize(dir) ;
}


`;class Jh{constructor(t){s(this,"irradianceBuffer");s(this,"depthBuffer");s(this,"probeIrradianceMap");s(this,"probeDepthMap");s(this,"volume");s(this,"computeShader");s(this,"depthRaysBuffer");this.volume=t,this.initPipeline()}initPipeline(){this.computeShader=new bt(Wh);let t=C.setting.gi,e=t.octRTMaxSize*t.octRTMaxSize;this.irradianceBuffer=new Xe(e*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("irradianceBuffer",this.irradianceBuffer),this.depthBuffer=new Xe(e*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("depthBuffer",this.depthBuffer),this.depthRaysBuffer=new Xe(4096*4*2*2*2,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC),this.computeShader.setStorageBuffer("depthRaysBuffer",this.depthRaysBuffer),this.computeShader.setStorageBuffer("probes",this.volume.probesBuffer),this.computeShader.setUniformBuffer("uniformData",this.volume.irradianceVolumeBuffer),this.computeShader.setStorageBuffer("models",ce.modelMatrixBindGroup.matrixBufferDst)}setTextures(t,e,r){this.probeIrradianceMap=e,this.probeDepthMap=r;let a=t[0],i=t[1],o=t[2];this.computeShader.setStorageTexture("probeIrradianceMap",this.probeIrradianceMap),this.computeShader.setStorageTexture("probeDepthMap",this.probeDepthMap),this.computeShader.setSamplerTexture("positionMap",a),this.computeShader.setSamplerTexture("normalMap",i),this.computeShader.setSamplerTexture("colorMap",o)}readBuffer(){return this.depthRaysBuffer.readBuffer()}compute(t,e){let r=this.volume.setting,a=S.beginCommandEncoder(),i=P.instance.getProbes(t.scene);this.computeShader.workerSizeX=r.octRTSideSize/8,this.computeShader.workerSizeY=r.octRTSideSize/8,this.computeShader.workerSizeZ=i.length,S.computeCommand(a,[this.computeShader]),S.endCommandEncoder(a)}}let zh=`
  #include "MathShader"
  #include "IrradianceVolumeData_frag"

  struct IrradianceField {
      probeStartPosition: vec4<f32>,
      probeCounts:vec4<f32>,
      probeStep:f32,
      irradianceTextureWidth:f32,
      irradianceTextureHeight:f32,
      irradianceProbeSideLength:f32,
  };

  @group(0) @binding(0) var outputBuffer : texture_storage_2d<rgba16float, write>;
  @group(0) @binding(1) var<uniform> uniformData : IrradianceVolumeData ;

  @group(1) @binding(0) var normalMapSampler : sampler;
  @group(1) @binding(1) var normalMap : texture_2d<f32>;

  @group(1) @binding(2) var colorMapSampler : sampler;
  @group(1) @binding(3) var colorMap : texture_2d<f32>;

  @group(1) @binding(4) var litMapSampler : sampler;
  @group(1) @binding(5) var litMap : texture_2d<f32>;

  @group(1) @binding(6) var irradianceMapSampler : sampler;
  @group(1) @binding(7) var irradianceMap : texture_2d<f32>;

  var<private> wsn:vec3<f32>;
  var<private> ulitColor:vec4<f32>;
  var<private> litColor:vec4<f32>;
  var<private> irradianceFieldSurface : IrradianceField ;
  var<private> probeID:u32;

  var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

  fn getIrradianceFieldSurface() -> IrradianceField{
    let data = uniformData;
    irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
    irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
    irradianceFieldSurface.probeStep = data.ProbeSpace;
    irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
    return irradianceFieldSurface;
  }

  fn rotateDir(n:vec3<f32>) -> vec3<f32>{
     return normalize(applyQuaternion(-n, quaternion));
  }

  fn sampleLitColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(litMap, litMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(litMap, uv, 0);
      return oc;
  }

  fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
      return oc;
  }

  fn sampleColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
      return oc;
  }

  fn sampleProbe(fragCoord:vec2<u32>){
    var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;

    litColor = sampleLitColor(uv);

    var normalMap = sampleNormal(uv);
    wsn = normalMap.xyz * 2.0 - 1.0;

    ulitColor = sampleColor(uv);
  }

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    getIrradianceFieldSurface();
    var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
    probeID = globalInvocation_id.z;
    fragCoord = fragCoord + getCoordOffset(probeID);

    sampleProbe(fragCoord);

    let irradiance = getIrradianceColor();
    let result = blendIrradianceColor(irradiance);
    textureStore(outputBuffer, vec2<i32>(fragCoord), result);
  }

  fn blendIrradianceColor(irradiance:vec4<f32>) -> vec4<f32>{
     var bounceColor = irradiance * ulitColor;
     let bounceIntensity = getBounceIntensity(uniformData.bounceIntensity);
     let conservation1 = 1.0 / sqrt((1.0 + bounceIntensity * 0.55));
     let conservation2 = 1.0 / sqrt((1.0 + bounceIntensity));
     var result = litColor * conservation2 + bounceColor * sqrt(bounceIntensity) * conservation1;
     return vec4<f32>(result.xyz, litColor.w);
  }

  fn getBounceIntensity(intensity:f32) -> f32 {
    var value = clamp(intensity, 0.0, 1.0) * 10.0;
    return value;
  }

  fn getCoordOffset(id:u32) -> vec2<u32>{
      var fullCol = u32(uniformData.ProbeSourceTextureSize / uniformData.ProbeSize);
      var offsetSampleUv = vec2<u32>( (id / fullCol) * 6u , id % fullCol) * u32(uniformData.ProbeSize);
      return offsetSampleUv;
  }

  fn getIrradianceColor() -> vec4<f32>{
     var probeIrradiance: vec4<f32> = vec4<f32>(0.0);
     if(length(wsn) > 0.01){
       probeIrradiance = getIrrdiaceIndex(i32(probeID), wsn);
     }
     return probeIrradiance;
  }

  fn getIrrdiaceIndex(index:i32, wsn:vec3<f32>) -> vec4<f32>{
    var wsN = rotateDir(wsn.xyz);
    var texCoord:vec2<f32> = textureCoordFromDirection(wsN,
      index,
      irradianceFieldSurface.irradianceTextureWidth,
      irradianceFieldSurface.irradianceTextureHeight,
      irradianceFieldSurface.irradianceProbeSideLength);

    var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, texCoord, 0.0).xyz;
    return vec4<f32>(probeIrradiance, 1.0);
  }

  fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
  {
      var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
      uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
      uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
      return uv ;
  }

  fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
  {
      var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
      var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetZ = probeID / blockCount ;

      var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

      var blockOffset = vec2<f32>(0.0);
      blockOffset.x = f32(offsetX) * size;
      blockOffset.y = f32(offsetY) * size + f32(offsetZ) * f32(irradianceFieldSurface.probeCounts.z) * size;

      let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
      var probeCounts:vec3<f32> = vec3<f32>(irradianceFieldSurface.probeCounts.xyz);

      var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
      var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

      pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

      return pixelCoord + 1.0 ;
  }

  fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
  {
    var pixelCoord = pixelCoord0;
    let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
    let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
    let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
    let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
    let col:i32 = pixelCoord.y / pixelCountYMax;

    pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
    pixelCoord.y = pixelCoord.y % pixelCountYMax;

    return pixelCoord;
  }
`;class Zh{constructor(t){s(this,"blendTexture");s(this,"volume");s(this,"computerShader");this.volume=t,this.initPipeline()}initPipeline(){let t=C.setting.gi;this.blendTexture=new tt(t.probeSourceTextureSize,t.probeSourceTextureSize,H.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING),this.computerShader=new bt(zh),this.computerShader.setStorageTexture("outputBuffer",this.blendTexture),this.computerShader.setUniformBuffer("uniformData",this.volume.irradianceVolumeBuffer)}setInputs(t){let e=t[0],r=t[1],a=t[2],i=t[3];this.computerShader.setSamplerTexture("normalMap",e),this.computerShader.setSamplerTexture("colorMap",r),this.computerShader.setSamplerTexture("litMap",a),this.computerShader.setSamplerTexture("irradianceMap",i)}compute(t,e){let r=S.beginCommandEncoder(),a=this.volume.setting,i=a.probeXCount*a.probeYCount*a.probeZCount,o=a.probeSize;this.computerShader.workerSizeX=o*6/8,this.computerShader.workerSizeY=o/8,this.computerShader.workerSizeZ=i,S.computeCommand(r,[this.computerShader]),S.endCommandEncoder(r)}}let Xh=`
var<private> PI: f32 = 3.14159265359;

#include "GlobalUniform"
#include "MathShader"
#include "FastMathShader"
#include "ColorUtil_frag"

struct ConstUniform{
   screenWidth:f32,
   screenHeight:f32
}

struct LightData {
     index:f32,
     lightType:i32,
     radius:f32,
     linear:f32,
     
     position:vec3<f32>,
     lightMatrixIndex:f32,

     direction:vec3<f32>,
     quadratic:f32,

     lightColor:vec3<f32>,
     intensity:f32,

     innerCutOff :f32,
     outerCutOff:f32,
     range :f32,
     castShadow:i32,

     lightTangent:vec3<f32>,
     ies:f32,
};

struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

const PointLightType = 1;
const DirectLightType = 2;
const SpotLightType = 3;

@group(0) @binding(auto) var outputBuffer : texture_storage_2d<rgba16float, write>;
@group(0) @binding(auto) var prefilterMapSampler: sampler;
@group(0) @binding(auto) var prefilterMap: texture_cube<f32>;

@group(1) @binding(auto) var positionMapSampler : sampler;
@group(1) @binding(auto) var positionMap : texture_2d<f32>;

@group(1) @binding(auto) var normalMapSampler : sampler;
@group(1) @binding(auto) var normalMap : texture_2d<f32>;

@group(1) @binding(auto) var colorMapSampler : sampler;
@group(1) @binding(auto) var colorMap : texture_2d<f32>;

@group(1) @binding(auto) var shadowMapSampler : sampler_comparison;
@group(1) @binding(auto) var shadowMap : texture_depth_2d_array;
@group(1) @binding(auto) var pointShadowMapSampler: sampler;
@group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array ;

@group(2) @binding(0)
var<storage,read> lightBuffer: array<LightData>;

@group(2) @binding(1)
var<storage, read> models : Uniforms;

struct ShadowStruct{
 directShadowVisibility:f32,
 pointShadows:array<f32,8>,
}

var<private> shadowStrut: ShadowStruct ;
var<private> ulitColor:vec3<f32>;
var<private> wPosition:vec3<f32>;
var<private> wNormal:vec3<f32>;

const LUMEN = 10.764;

fn samplePosition(uv:vec2<f32>) -> vec4<f32>
{
   return textureSampleLevel(positionMap, positionMapSampler,uv, 0.0);
}

fn sampleNormal(uv:vec2<f32>) -> vec4<f32>
{
  return textureSampleLevel(normalMap, normalMapSampler, uv, 0.0);
}

fn sampleColor(uv:vec2<f32>) -> vec4<f32>
{
   var oc:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, uv, 0.0);
   ulitColor = vec3(oc.xyz);
   return oc;
}

const csmCount:i32 = ${zt.Cascades} ;
fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
  let enableCSM:bool = globalUniform.enableCSM > 0.5;
  var light = lightBuffer[0];
  var visibility = 1.0;
    var shadowIndex = i32(light.castShadow);
    if (shadowIndex >= 0 ) {
      var shadowMatrix:mat4x4<f32>;
      if(enableCSM && csmCount > 1){
        for(var csm:i32 = 0; csm < csmCount; csm ++){
          var csmShadowBias = globalUniform.csmShadowBias[csm];
          shadowMatrix = globalUniform.csmMatrix[csm];
          let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
          if(csmShadowResult.y < 0.5){
            visibility = csmShadowResult.x;
            break;
          }
        }
      }else{
        shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
        visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
      }
    }
  shadowStrut.directShadowVisibility = visibility;
}

fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
{
  var visibility = 1.0;
  var isOutSideArea:f32 = 1.0;
  var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
  var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
  var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
  if (varying_shadowUV.x <= 1.0
    && varying_shadowUV.x >= 0.0
    && varying_shadowUV.y <= 1.0
    && varying_shadowUV.y >= 0.0
    && shadowPosTmp.z <= 1.0
    && shadowPosTmp.z >= 0.0)
  {
    isOutSideArea = 0.0;
    var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
    var NoL = abs(dot(N, normalize(light.direction)));
    var bias = shadowBias / max(NoL, 0.000001);
    visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
    visibility += 0.001;
  }
  return vec2<f32>(visibility, isOutSideArea);
}

fn pointShadowMapCompare(shadowBias:f32){
   for(var i:i32 = i32(0) ; i < i32(8); i = i + 1 )
   { 
       var v = 1.0 ;
       let light = lightBuffer[i] ;
       if(light.castShadow < 0 ){
         shadowStrut.pointShadows[i] = v ;
         continue ;
       }

       let frgToLight = wPosition - light.position.xyz;
       var dir:vec3<f32> = normalize(frgToLight)  ;

       var len = length(frgToLight) ;
       var depth = textureSampleLevel(pointShadowMap,pointShadowMapSampler,dir.xyz,i,0); 
       depth *= globalUniform.far ;
       if((len - shadowBias) > depth){
          v = 0.0 ; 
       }
       shadowStrut.pointShadows[i] = v ;
   }
} 

fn directLighting( albedo:vec3<f32> , WP :vec3<f32>, N:vec3<f32> , V:vec3<f32> , light:LightData , shadowBias:f32  ) -> vec3<f32> {
 var L = -normalize(light.direction.xyz) ;
 var NoL = max(dot(N,L),0.0);
 let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
 var lightColor = getHDRColor( lightCC , light.linear ) ;
 var att = light.intensity / LUMEN ;
 if(light.castShadow>=0){
     lightColor *= shadowStrut.directShadowVisibility ;
 }
 let finalLight = (albedo / PI) * lightColor * NoL * att * 2.0 ;
 return finalLight ;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir);
 var color = vec3<f32>(0.0) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 if( abs(dist) < light.range ){
     var L = dir ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.0001) ;

     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
 }

 return  color *0.0;
}

fn spotLight( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 var color = vec3<f32>(0.0) ;
 if( abs(dist) < light.range * 2.0 ){
     var L = dir ;
     let theta = dot(-L, normalize(light.direction));
     let angle = acos(theta) ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.1) ;
     if(angle < light.outerCutOff){
       if(angle > light.innerCutOff){
         atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
       }
     }else{
       atten = 0.0 ;
     }
     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
   }
 return  color ;
}

fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
{
  let u = (f32(coord.x) + 0.5) / f32(texSize.x);
  let v = (f32(coord.y) + 0.5) / f32(texSize.y);
  return vec2<f32>(u, v);
}

fn coordFun(fragCoord:vec2<i32>)-> vec4<f32>{
 let uv_01 = CalcUV_01(fragCoord, texSize);
 var pos = samplePosition(uv_01);

 var normalMap = sampleNormal(uv_01);
 var normal = normalize( normalMap.xyz * 2.0 - 1.0 );

 var color = sampleColor(uv_01);
 var emissive = vec4<f32>(pos.a,normalMap.a,color.a,0.0) * 1.0 ;
 if(pos.w + 1.0 > 10000.0){
   return vec4<f32>(color);
 }
 var V = normalize(pos.xyz - globalUniform.cameraWorldMatrix[3].xyz);
 var N = normal.xyz ;

 wPosition = pos.xyz;
 wNormal = N;

 directShadowMaping(wPosition, wNormal, globalUniform.shadowBias);
 pointShadowMapCompare(globalUniform.shadowBias);

 var lighting = vec3<f32>(0.0);
 let lightCount = 32 ;
 for(var i:i32 = 0 ; i < lightCount ; i = i + 1 )
 {
     let light = lightBuffer[i];
     switch (light.lightType) {
         case PointLightType: {
             lighting += pointLighting(color.rgb,pos.xyz,N,V,light);
         }
         case DirectLightType: {
             lighting += directLighting(color.rgb,pos.xyz,N,V,light,globalUniform.shadowBias);
         }
         case SpotLightType: {
             lighting += spotLight(color.rgb,pos.xyz,N,V,light);
         }
         default: {
         }
     }
 }

 // lighting = vec3<f32>(1.0) / (vec3<f32>(1.0) + lighting.rgb) * lighting.rgb;

 var skyLight: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, N.xyz, 8.0 ).rgb);
 // skyLight = LinearToGammaSpace(skyLight);
 // skyLight = (color.rgb / 3.1415926 ) * skyLight;
 // skyLight = vec3<f32>(1.0) / (vec3<f32>(1.0) + skyLight.rgb) * skyLight.rgb;

 lighting = lighting.rgb ;//+ skyLight.rgb ;

 return vec4<f32>(lighting.rgb,color.w)+emissive;
}

// fn vertexToCoord(vertexPosition:vec3<f32>) -> vec4<f32>{
//   var worldPos = vec4<f32>(vertexPosition.xyz, 1.0);
//   var fragPosition = globalUniform.viewMat * worldPos ;
//   // var position = globalUniform.projMat * fragPosition ;
//   return fragPosition;
// }

var<private> texSize: vec2<u32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   var fragCoord = vec2<i32>(globalInvocation_id.xy);
   texSize = textureDimensions(colorMap).xy;
   var color = coordFun(fragCoord);
   // color = vec4(pow(color.rgb,vec3<f32>(1.0/2.4)),1.0);
   textureStore(outputBuffer, fragCoord, color);
}

`;class Yh{constructor(){s(this,"computeShader");s(this,"worldPosMap");s(this,"worldNormalMap");s(this,"colorMap");s(this,"shadowMap");s(this,"pointShadowMap");s(this,"lightingTexture");let t=C.setting.gi;this.lightingTexture=new tt(t.probeSourceTextureSize,t.probeSourceTextureSize,H.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING)}create(t){let e=ce.getLightEntries(t.scene);this.computeShader=new bt(Xh);let r=ce.getCameraGroup(t.camera);this.computeShader.setUniformBuffer("globalUniform",r.uniformGPUBuffer),this.computeShader.setStorageTexture("outputBuffer",this.lightingTexture),this.computeShader.setStorageBuffer("lightBuffer",e.storageGPUBuffer),this.computeShader.setStorageBuffer("models",ce.modelMatrixBindGroup.matrixBufferDst),this.computeShader.setSamplerTexture("positionMap",this.worldPosMap),this.computeShader.setSamplerTexture("normalMap",this.worldNormalMap),this.computeShader.setSamplerTexture("colorMap",this.colorMap),this.computeShader.setSamplerTexture("shadowMap",this.shadowMap),this.computeShader.setSamplerTexture("pointShadowMap",this.pointShadowMap),this.computeShader.setSamplerTexture("prefilterMap",C.res.defaultSky)}setInputs(t){this.worldPosMap=t[0],this.worldNormalMap=t[1],this.colorMap=t[2],this.shadowMap=t[3],this.pointShadowMap=t[4]}compute(t,e){this.computeShader||this.create(t);let r=S.beginCommandEncoder(),a=C.setting.gi;this.computeShader.workerSizeX=a.probeSourceTextureSize/8,this.computeShader.workerSizeY=a.probeSourceTextureSize/8,this.computeShader.workerSizeZ=1,S.computeCommand(r,[this.computeShader]),S.endCommandEncoder(r)}}let xs=new pt("GIRenderStartEvent"),Hh=new pt("GIRenderCompleteEvent");class Kh{constructor(){s(this,"count");s(this,"complete")}}class jh extends nr{constructor(e){super();s(this,"cubeCamera");s(this,"volume");s(this,"probeCountPerFrame",1);s(this,"nextProbeIndex",-1);s(this,"tempProbeList",[]);s(this,"isRenderCloudGI");s(this,"probeRenderResult");s(this,"renderStatus","none");s(this,"positionMap");s(this,"normalMap");s(this,"colorMap");s(this,"probeNext",128);s(this,"sizeW");s(this,"sizeH");s(this,"lightingPass");s(this,"bouncePass");s(this,"irradianceComputePass");s(this,"irradianceDepthMap");s(this,"irradianceColorMap");this.passType=W.GI,this.volume=e;let r=e.setting;this.cubeCamera=new ln(.01,5e3),this.sizeW=r.probeSourceTextureSize,this.sizeH=r.probeSourceTextureSize,this.probeNext=r.probeSourceTextureSize/r.probeSize,this.initIrradianceMap(e),this.probeRenderResult=new Kh;let a=new Gh(this.sizeW,this.sizeH,!1);this.positionMap=a.renderTargets[0],this.normalMap=a.renderTargets[1],this.colorMap=a.renderTargets[2],this.setRenderStates(a)}setInputTexture(e){this.lightingPass=new Yh,this.bouncePass=new Zh(this.volume),this.irradianceComputePass=new Jh(this.volume),this.lightingPass.setInputs([this.positionMap,this.normalMap,this.colorMap,e[0],e[1]]),this.bouncePass.setInputs([this.normalMap,this.colorMap,this.lightingPass.lightingTexture,this.irradianceColorMap]),this.irradianceComputePass.setTextures([this.positionMap,this.normalMap,this.bouncePass.blendTexture],this.irradianceColorMap,this.irradianceDepthMap)}setIrradianceData(e,r,a,i){if(a!=this.irradianceColorMap.width||i!=this.irradianceColorMap.height){console.error("irradiance image size not match !");return}this.writeToTexture(this.irradianceColorMap,e,a,i),this.writeToTexture(this.irradianceDepthMap,r,a,i)}updateProbe(e,r,a){let i=P.instance.getLights(e.scene),o=this.volume.setting.probeSize;r.drawCallFrame+=1,this.cubeCamera.x=r.x,this.cubeCamera.y=r.y,this.cubeCamera.z=r.z,this.volume.setting.debugCamera?(this.cubeCamera.x=e.camera.transform.x,this.cubeCamera.y=e.camera.transform.y,this.cubeCamera.z=e.camera.transform.z,this.cubeCamera.rotationX=e.camera.transform.rotationX,this.cubeCamera.rotationY=e.camera.transform.rotationY,this.cubeCamera.rotationZ=e.camera.transform.rotationZ):(this.cubeCamera.rotationX=r.rotationX,this.cubeCamera.rotationY=r.rotationY,this.cubeCamera.rotationZ=r.rotationZ);let l=this.cubeCamera,h=Math.floor(r.index/this.probeNext)*(o*6),c=Math.floor(r.index%this.probeNext)*o;a.setViewport(0+h,c,o,o,0,1),this.renderSceneOnce(e,l.right_camera,a,i),a.setViewport(o+h,c,o,o,0,1),this.renderSceneOnce(e,l.left_camera,a,i),a.setViewport(o*2+h,c,o,o,0,1),this.renderSceneOnce(e,l.up_camera,a,i),a.setViewport(o*3+h,c,o,o,0,1),this.renderSceneOnce(e,l.down_camera,a,i),a.setViewport(o*4+h,c,o,o,0,1),this.renderSceneOnce(e,l.front_camera,a,i),a.setViewport(o*5+h,c,o,o,0,1),this.renderSceneOnce(e,l.back_camera,a,i)}renderSceneOnce(e,r,a,i){this.volume.uploadBuffer();let o=P.instance.getRenderNodes(e.scene,r);S.bindCamera(a,r);let l=Math.max(0,C.setting.render.drawOpMin),h=Math.min(C.setting.render.drawOpMax,o.opaqueList.length),c=P.instance.getRenderShaderCollect(e);for(const u of c){let d=u[1];for(const f of d){let A=f[1];if(!A.isDestroyed&&A.preInit(this.passType)){A.nodeUpdate(e,this.passType,this.rendererPassState,null);break}}}for(let u=l;u<h;++u){let d=o.opaqueList[u];d.enable&&d.transform.enable&&!d.isDestroyed&&(d.preInit(this.passType)||d.nodeUpdate(e,this.passType,this.rendererPassState,null),d.renderPass2(e,this.passType,this.rendererPassState,null,a))}P.instance.sky&&(P.instance.sky.preInit(this.passType)||P.instance.sky.nodeUpdate(e,this.passType,this.rendererPassState,null),P.instance.sky.renderPass2(e,this.passType,this.rendererPassState,null,a)),l=Math.max(0,C.setting.render.drawTrMin),h=Math.min(C.setting.render.drawTrMax,o.transparentList.length);for(let u=l;u<h;++u){let d=o.transparentList[u];d.enable&&d.transform.enable&&!d.isDestroyed&&(d.preInit(this.passType)||d.nodeUpdate(e,this.passType,this.rendererPassState,null),d.renderPass2(e,this.passType,this.rendererPassState,null,a))}}render(e,r){if(!C.setting.gi.enable)return;this.volume.updateOrientation(),this.volume.isVolumeFrameChange=!1,this.volume.uploadBuffer(),this.rendProbe(e);let a=this.probeRenderResult.count>0;(P.instance.state.giLightingChange||a||C.setting.gi.realTimeGI)&&(P.instance.state.giLightingChange=!1,this.lightingPass.compute(e,this.rendererPassState),this.bouncePass.compute(e,this.rendererPassState),this.irradianceComputePass.compute(e,this.rendererPassState)),this.probeRenderResult.complete&&this.dispatchEvent(Hh)}startRenderGI(e=0){this.nextProbeIndex==-1&&e==0&&this.dispatchEvent(xs),this.nextProbeIndex=e,this.renderStatus="rendering"}startRenderCloudGI(){this.dispatchEvent(xs),this.nextProbeIndex=0,this.renderStatus="rendering",this.isRenderCloudGI=!0}rendProbe(e){let r=C.setting.gi.autoRenderProbe,a=!1;if(r?(this.nextProbeIndex==-1&&this.startRenderGI(),a=!0):a=this.renderStatus=="rendering",this.probeRenderResult.count=0,this.probeRenderResult.complete=!1,a){let i=P.instance.getProbes(e.scene);this.renderContext.clean(),this.renderContext.beginOpaqueRenderPass(),this.tempProbeList.length=0;let o=Math.min(this.probeCountPerFrame,i.length);for(this.probeRenderResult.count=o;o>0;){const h=i[this.nextProbeIndex];this.updateProbe(e,h,this.renderContext.encoder),o--,this.nextProbeIndex++,h.drawCallFrame<3&&this.tempProbeList.push(h)}this.tempProbeList.length>0&&this.volume.updateProbes(this.tempProbeList);let l=this.nextProbeIndex>=i.length;this.nextProbeIndex>=i.length&&this.isRenderCloudGI&&this.updateProbe(e,i[0],this.renderContext.encoder),this.renderContext.endRenderPass(),l&&(this.nextProbeIndex=-1,this.renderStatus="complete",this.probeRenderResult.complete=!0)}}initIrradianceMap(e){let r=e.setting,a=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST;this.irradianceDepthMap=new tt(r.octRTMaxSize,r.octRTMaxSize,H.rgba16float,!1,a),this.irradianceDepthMap.name="irradianceDepthMap",this.irradianceColorMap=new tt(r.octRTMaxSize,r.octRTMaxSize,H.rgba16float,!1,a),this.irradianceColorMap.name="irradianceColorMap"}writeToTexture(e,r,a,i){console.log(e.name);const o=R.device.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});R.device.queue.writeBuffer(o,0,r);const l=S.beginCommandEncoder();l.copyBufferToTexture({buffer:o,bytesPerRow:a*16},{texture:e.getGPUTexture()},{width:a,height:i,depthOrArrayLayers:1}),S.endCommandEncoder(l)}}class qh extends nr{constructor(){super(),this.passType=W.UI}compute(t,e){let r=S.beginCommandEncoder(),a=S.lastRenderPassState.getLastRenderTexture(),i=Le.getGUIBufferFrame().getColorTexture();S.copyTexture(r,a,i),S.endCommandEncoder(r)}render(t,e,r,a=!1){this.renderContext.clean();let i=t.scene,o=t.camera;ce.updateCameraGroup(o),this.rendererPassState.camera3D=o;let l=P.instance.getRenderNodes(i,o);{this.renderContext.specialtRenderPass();let h=this.renderContext.encoder;l.opaqueList&&(S.bindCamera(h,o),this.drawNodes(t,this.renderContext,l.opaqueList,e,r))}{let h=this.renderContext.encoder;!a&&l.transparentList&&(S.bindCamera(h,o),this.drawNodes(t,this.renderContext,l.transparentList,e,r)),this.renderContext.endRenderPass()}}drawNodes(t,e,r,a,i){let o=P.instance.getRenderShaderCollect(t);if(o){for(const l of o){let h=l[1];for(const c of h){let u=c[1];if(!u.isDestroyed&&u.preInit(this._rendererType)){u.nodeUpdate(t,this._rendererType,this.rendererPassState,i);break}}}for(let l=C.setting.render.drawOpMin;l<Math.min(r.length,C.setting.render.drawOpMax);++l){let h=r[l];h.transform.enable&&h.enable&&(!h.hasMask(de.UI)||h.isRecievePostEffectUI||h.isDestroyed||(h.preInit(this._rendererType)||h.nodeUpdate(t,this._rendererType,this.rendererPassState,i),h.renderPass(t,this.passType,this.renderContext)))}}}occlusionRenderNodeTest(t,e,r){return r.zDepthRenderNodeTest(e)>0}}class $h extends Oh{constructor(t){super(t)}start(){super.start();{let t=new Rh,e=Le.getGBufferFrame(Le.colorPass_GBuffer);if(C.setting.render.zPrePass&&(e.zPreTexture=this.depthPassRenderer.rendererPassState.depthTexture),t.setRenderStates(e),C.setting.gi.enable){let r=ce.getLightEntries(this.view.scene);this.ddgiProbeRenderer=new jh(r.irradianceVolume),this.ddgiProbeRenderer.setInputTexture([this.shadowMapPassRenderer.depth2DArrayTexture,this.pointLightShadowRenderer.cubeArrayTexture]),t.setIrradiance(this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap),this.rendererMap.addRenderer(this.ddgiProbeRenderer)}this.rendererMap.addRenderer(t)}{let t=Le.getGUIBufferFrame(),e=new qh;e.setRenderStates(t),this.rendererMap.addRenderer(e)}C.setting.render.debug&&this.debug()}debug(){}}class ec{constructor(){s(this,"_factor");s(this,"_doubleFactor");this._factor=1,this._doubleFactor=2}get accelerateInterpolator(){return this._factor}set accelerateInterpolator(t){this._factor=t,this._doubleFactor=2*this._factor}getInterpolation(t){return this._factor==1?t*t:Math.pow(t,this._doubleFactor)}}class tc{constructor(){s(this,"_factor",1)}get decelerateInterpolator(){return this._factor}set decelerateInterpolator(t){this._factor=t}getInterpolation(t){let e;return this._factor==1?e=1-(1-t)*(1-t):e=1-Math.pow(1-t,2*this._factor),e}}class rc{constructor(){s(this,"_factor",1)}getInterpolation(t){return Math.cos((t+1)*Math.PI)/2+.5}}class ac{getInterpolation(t){return t}}class ic{getInterpolation(t){return 4.9*t+4.9*t}}class ft{constructor(){}static bounce(t){return t*t*9.8}getInterpolation(t){return t*=1.1226,t<.3535?ft.bounce(t):t<.7408?ft.bounce(t-.54719)+.7:t<.9644?ft.bounce(t-.8526)+.9:ft.bounce(t-1.0435)+.95}getBounceInterpolation(t){return t<.5?ft.bounce(t):ft.bounce(t-1)}geJumpUp(t,e){return e<.5?(e=e/.5,t*e-ft.bounce(e)):e<.8?(e=(e-.5)/(.8-.5),(t*e-ft.bounce(e))*.3):e<1?(e=(e-.8)/(1-.8),(t*e-ft.bounce(e))*.15):t*e-ft.bounce(e)}}class sc{constructor(){s(this,"_tension");this._tension=2}get anticipateInterpolator(){return this._tension}set anticipateInterpolator(t){this._tension=t}getInterpolation(t){return t*t*((this._tension+1)*t-this._tension)}}class za{constructor(){s(this,"_tension");this._tension=1*1.5}anticipateOvershootInterpolator(t){this._tension=t*1.5}anticipateOvershootInterpolator2(t,e){this._tension=t*e}getInterpolation(t){return t<.5?.5*za.a(t*2,this._tension):.5*(za.o(t*2-2,this._tension)+2)}static a(t,e){return t*t*((e+1)*t-e)}static o(t,e){return t*t*((e+1)*t+e)}}class nc{constructor(t){s(this,"_cycles");this._cycles=t}getInterpolation(t){return Math.sin(2*this._cycles*Math.PI*t)}}class oc{constructor(){s(this,"_tension");this._tension=2}getInterpolation(t){return t-=1,t*t*((this._tension+1)*t+this._tension)+1}}var cn=(n=>(n[n.AccelerateInterpolator=0]="AccelerateInterpolator",n[n.DecelerateInterpolator=1]="DecelerateInterpolator",n[n.AccelerateDecelerateInterpolator=2]="AccelerateDecelerateInterpolator",n[n.LinearInterpolator=3]="LinearInterpolator",n[n.BounceInterpolator=4]="BounceInterpolator",n[n.AnticipateInterpolator=5]="AnticipateInterpolator",n[n.AnticipateOvershootInterpolator=6]="AnticipateOvershootInterpolator",n[n.CycleInterpolator=7]="CycleInterpolator",n[n.OvershootInterpolator=8]="OvershootInterpolator",n[n.JumperInterpolator=9]="JumperInterpolator",n))(cn||{});const ur=class ur{constructor(){s(this,"complete",!1);s(this,"onComplete");s(this,"onProgress");s(this,"target");s(this,"property");s(this,"targetProperty");s(this,"durtion");s(this,"interpolatorEnum");s(this,"delayTime",0);s(this,"_interpolator");s(this,"_ct",0);s(this,"_p",0)}static to(t,e,r,a=0){var i=new ur;return i.target=t,i.property=e,i.durtion=r,i.interpolatorEnum=a,i.start(),i.delayTime=e.delayTime?e.delayTime:0,e.onComplete&&(i.onComplete=e.onComplete),e.onProgress&&(i.onProgress=e.onProgress),this.interpolators.push(i),i}static tick(t){let e=ur.interpolators;for(let r of e)r.complete?ur.remove(r,!0):r.tick(t)}static remove(t,e){let r=ur.interpolators,a=r.indexOf(t);a!=-1&&r.splice(a,1),e&&t.dispose()}static removeList(t,e){t.forEach(r=>{this.remove(r,e)})}start(){window.AccelerateInterpolator=ec,window.DecelerateInterpolator=tc,window.AccelerateDecelerateInterpolator=rc,window.LinearInterpolator=ac,window.BounceInterpolator=ft,window.AnticipateInterpolator=sc,window.AnticipateOvershootInterpolator=za,window.CycleInterpolator=nc,window.OvershootInterpolator=oc,window.JumperInterpolator=ic,this._interpolator=new window[cn[this.interpolatorEnum]],this.targetProperty={};for(let t in this.property)this.targetProperty[t]=this.target[t]}tick(t){if(this.delayTime<=0){this._p=Math.min(this._ct/this.durtion,1);let e=this._interpolator.getInterpolation(this._p),r=this.property,a=this.target,i=this.targetProperty,o,l;for(let h in r)l=r[h],o=i[h],a[h]=o+(l-o)*e;this.onProgress!=null&&this.onProgress(this._p),this._ct>=this.durtion&&(this.complete=!0,this.onComplete!=null&&this.onComplete(this.target)),this._ct+=t}else this.delayTime-=t}dispose(){this.onComplete=null,this.onProgress=null,this.target=null,this.property=null,this.targetProperty=null,this.interpolatorEnum=null,this._interpolator=null,ur.remove(this)}};s(ur,"interpolators",[]);let yi=ur;class et{static hasString(t,e){for(var r=0;r<t.length;++r)if(t[r]==e)return r;return-1}static getEllipsis(t,e=4){let r=t;return r.length>e&&(r=r.slice(0,e)+"..."),r}static getURLName(t){var e;e=t.split("/");let r=e[e.length-1];return r=r.split(".")[0],r}static getFileFormat(t){var e=t.lastIndexOf(".");e++;var r=t.length;t.indexOf("?",e)!==-1&&(r=t.indexOf("?",e));var a=t.substr(e,r-e);return a=a.toLowerCase(),a}static readLineProperty(t,e){t.trim().split(" ").forEach((r,a)=>{let i=r.split("=");if(i.length>1){let o=i[0],l=i[1];Object.prototype.hasOwnProperty.call(e,o)&&(l.indexOf('"')==-1?e[o]=parseFloat(i[1]):e[o]=l.replace('"',"").replace('"',""))}})}static getPath(t){var e=t.lastIndexOf("/");return e++,t.substring(0,e)}static normalizePath(t){var e=t.replaceAll("//","/");return e=e.replaceAll("\\","/"),e}static getStringList(t,e=";"){return t.split(e)}static formatTime(t){let e=t/1e3/60,r=Math.floor(e),a=Math.floor(e-r);return[r.toString(),a.toString()]}static trim(t){return t.replace(/^\s+/g,"").replace(/\s+$/g,"")}static isEmpty(t){return!t||typeof t>"u"||t==null||typeof t=="string"&&this.trim(t)===""||t==="null"}static strCut(t,e){if(t.length*2<=e)return t;for(var r=0,a="",i=0;i<t.length;i++)if(a=a+t.charAt(i),t.charCodeAt(i)>128){if(r=r+2,r>=e)return a.substring(0,a.length-1)+"..."}else if(r=r+1,r>=e)return a.substring(0,a.length-2)+"...";return a}static toQueryPair(t,e,r=!1){return t+"="+(r?encodeURIComponent(e):e)}static stringFormat(t,...e){if(arguments.length===0)throw new Error("please give arg at least one !");if(arguments.length===2&&typeof arguments[1]=="object")for(let r in arguments[1]){let a=new RegExp("({"+r+"})","g");t=t.replace(a,arguments[1][r])}else for(let r=0;r<e.length;r++){if(e[r]==null)return t;{let a=new RegExp("({["+r+"]})","g");t=t.replace(a,e[r])}}return t}static parseJson2String(t,e){let r=null,a="",i=0,o="    ";return e=e||{},e.newlineAfterColonIfBeforeBraceOrBracket=e.newlineAfterColonIfBeforeBraceOrBracket===!0,e.spaceAfterColon=e.spaceAfterColon!==!1,typeof t!="string"||(t=JSON.parse(t)),t=JSON.stringify(t),r=/([\{\}])/g,t=t.replace(r,`\r
$1\r
`),r=/([\[\]])/g,t=t.replace(r,`\r
$1\r
`),r=/(\,)/g,t=t.replace(r,`$1\r
`),r=/(\r\n\r\n)/g,t=t.replace(r,`\r
`),r=/\r\n\,/g,t=t.replace(r,","),e.newlineAfterColonIfBeforeBraceOrBracket||(r=/\:\r\n\{/g,t=t.replace(r,":{"),r=/\:\r\n\[/g,t=t.replace(r,":[")),e.spaceAfterColon&&(r=/\:/g,t=t.replace(r,":")),t.split(`\r
`).forEach(function(l,h){let c=0,u=0,d="";for(l.match(/\{$/)||l.match(/\[$/)?u=1:l.match(/\}/)||l.match(/\]/)?i!==0&&(i-=1):u=0,c=0;c<i;c++)d+=o;a+=d+l+`\r
`,i+=u}),a}static compareVersion(t,e){t=t.split("."),e=e.split(".");let r=Math.max(t.length,e.length);for(;t.length<r;)t.push("0");for(;e.length<r;)e.push("0");for(let a=0;a<r;a++){let i=parseInt(t[a]),o=parseInt(e[a]);if(i>o)return 1;if(i<o)return-1}return 0}static buildRandomCode(){let t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",e=t.length,r="";for(let a=0;a<26;a++){let i=Math.floor(Math.random()*e);r+=t.charAt(i)}return`${new Date().getTime()}-${r}`}static UUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){var e=Math.random()*16|0,r=t=="x"?e:e&3|8;return r.toString(16)})}static stringToHash(t){let e=0;if(t.length==0)return e;for(let r=0;r<t.length;r++){const a=t.charCodeAt(r);e=(e<<5)-e+a,e=e&e}return e}static parseUrl(t,e){return e.match(/^(blob|http|https):/)?e:t+e}}s(et,"_filterChar",[" ","  ",";",`
`,"\r","	",`
`,"\r","	"]);class Br extends rt{constructor(e=!0){super();s(this,"_source");s(this,"premultiplyAlpha","none");s(this,"imageData");this.useMipmap=e,this.lodMinClamp=0,this.lodMaxClamp=4}get source(){return this._source}set source(e){this._source=e,this._source instanceof HTMLImageElement?this._source.decode().then(async()=>{if(this._source instanceof HTMLImageElement){const r=await createImageBitmap(this._source,{imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});this.generate(r)}}):(this._source instanceof HTMLCanvasElement||this._source instanceof ImageBitmap)&&this.generate(this._source)}async load(e,r){if(this.name=et.getURLName(e),e.indexOf(";base64")!=-1){const a=document.createElement("img");let i=e.indexOf("data:image"),o=e.substring(i,e.length);a.src=o,await a.decode(),a.width=Math.max(a.width,32),a.height=Math.max(a.height,32);const l=await createImageBitmap(a,{resizeWidth:a.width,resizeHeight:a.height,imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});this.format=H.rgba8unorm,this.generate(l)}else return new Promise((a,i)=>{fetch(e,{headers:Object.assign({Accept:"image/avif,image/webp,*/*"},r==null?void 0:r.headers)}).then(o=>{Xr.read(e,o,r).then(l=>{let h=new Blob([l],{type:"image/jpeg"});l=null,this.loadFromBlob(h).then(()=>{a(!0)})})})});return!0}async loadFromBlob(e){this.imageData=e;let r=await createImageBitmap(e,{imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});if(r.width<32||r.height<32){let a=Math.max(r.width,32),i=Math.max(r.height,32);r=await createImageBitmap(r,{resizeWidth:a,resizeHeight:i,imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"})}return this.format=H.rgba8unorm,this.generate(r),!0}}class Xr{constructor(){s(this,"baseUrl","");s(this,"initUrl");s(this,"_progress",0)}async loadBinData(t,e){return this.baseUrl=et.getPath(t),this.initUrl=t,new Promise(async(r,a)=>{fetch(t,{headers:e==null?void 0:e.headers}).then(async i=>{if(i.ok){let o=await Xr.read(t,i,e),l=o.buffer;o=null,r(l)}else throw Error("request rejected with status "+i.status)}).catch(i=>{e.onError&&e.onError(i),a(i)})})}async loadAsyncBitmapTexture(t,e){this.baseUrl=et.getPath(t),this.initUrl=t;let r=new Br;return r.url=t,r.name=et.getURLName(t),await r.load(t,e),C.res.addTexture(t,r),r}async loadJson(t,e){return this.baseUrl=et.getPath(t),this.initUrl=t,new Promise(async(r,a)=>{fetch(t,{headers:e==null?void 0:e.headers}).then(async i=>{if(i.ok){let o=await Xr.read(t,i,e);const l=new TextDecoder("utf-8").decode(o);o=null,r(JSON.parse(l))}else throw Error("request rejected with status"+i.status)}).catch(i=>{e.onError&&e.onError(i),a(i)})})}async loadTxt(t,e){return this.baseUrl=et.getPath(t),new Promise(async(r,a)=>{fetch(t).then(async i=>{if(i.ok){let o=await Xr.read(t,i,e);const l=new TextDecoder("utf-8").decode(o);o=null,r({data:l})}else throw Error("request rejected with status"+i.status)}).catch(i=>{e.onError&&e.onError(i),a(i)})})}static async read(t,e,r){const a=e.body.getReader(),i=+e.headers.get("Content-Length");let o=0,l=[],h=[];for(;;){const{done:d,value:f}=await a.read();if(d){i>0&&r&&r.onComplete&&r.onComplete.call(this,t);break}l.push(f),o+=f.length,i>0?r&&r.onProgress&&r.onProgress.call(this,o,i,t):h.push(f.length)}if(h.length>0)for(let d=0;d<l.length;d++)r&&r.onProgress&&r.onProgress.call(this,h[d],o,t),h[d]==o&&r&&r.onComplete&&r.onComplete.call(this,t);let c=new Uint8Array(o),u=0;for(let d of l)c.set(d,u),u+=d.length;return c}}var ke=(n=>(n[n.TEXT=0]="TEXT",n[n.BIN=1]="BIN",n[n.JSON=2]="JSON",n))(ke||{});class st extends Xr{async load(t,e,r,a){switch(e.format){case ke.BIN:return new Promise(async(i,o)=>{this.loadBinData(t,r).then(async l=>{let h=new e;if(h.userData=a,h.baseUrl=this.baseUrl,h.initUrl=t,await h.parseBuffer(l),h.verification())i(h);else throw new Error("parser error")}).catch(l=>{o(l)})});case ke.JSON:return new Promise((i,o)=>{this.loadJson(t,r).then(async l=>{let h=new e;h.userData=a,h.baseUrl=this.baseUrl,h.initUrl=t,h.loaderFunctions=r,await h.parseJson(l),i(h)}).catch(l=>{o(l)})});case ke.TEXT:return new Promise((i,o)=>{this.loadTxt(t,r).then(async l=>{let h=new e;h.userData=a,h.baseUrl=this.baseUrl,h.initUrl=t,h.loaderFunctions=r,l.data?(await h.parseString(l.data),i(h)):o("text load is empty!")}).catch(l=>{o(l)})})}}}class at{constructor(){s(this,"baseUrl");s(this,"initUrl");s(this,"loaderFunctions");s(this,"userData");s(this,"data")}parseString(t){}parseJson(t){}parseBuffer(t){}parseTexture(t){throw this.parserError("Method not implemented.",-1)}parse(t){}verification(t){throw this.parserError("Method not implemented.",-1)}parserError(t,e){console.error(`error id:${e} ${t}`)}}s(at,"format",ke.BIN);class Ii{constructor(){s(this,"asset");s(this,"accessors");s(this,"buffers");s(this,"bufferViews");s(this,"materials");s(this,"meshes");s(this,"nodes");s(this,"scene",0);s(this,"scenes");s(this,"textures");s(this,"cameras");s(this,"skins");s(this,"resources");s(this,"images");s(this,"samplers");s(this,"animations");s(this,"extensions")}}const lc=5120,hc=5121,cc=5122,uc=5123,dc=5124,fc=5125,Ac=5126,gc=32819,pc=32820,mc=33635,Uc=5131,Bc=33640,Fc=35899,Cc=35902,Qc=36269,vc=34042,un={};{const n=un;n[lc]=Int8Array,n[hc]=Uint8Array,n[cc]=Int16Array,n[uc]=Uint16Array,n[dc]=Int32Array,n[fc]=Uint32Array,n[Ac]=Float32Array,n[gc]=Uint16Array,n[pc]=Uint16Array,n[mc]=Uint16Array,n[Uc]=Uint16Array,n[Bc]=Uint32Array,n[Fc]=Uint32Array,n[Cc]=Uint32Array,n[Qc]=Uint32Array,n[vc]=Uint32Array}function bs(n){const t=un[n];if(!t)throw new Error("unkonw gl type");return t}class Za{static async apply(t,e){if(!e.extensions)return;const r=e.extensions.KHR_draco_mesh_compression;if(!r)return;let a=this._workers.get(t.gltf);a||(a=new Worker(await this.initDecoder()),this._workers.set(t.gltf,a)),a.postMessage({type:"init",decoderConfig:{}});let i=t.parseBufferView(r.bufferView);if(!i.result){let o=await new Promise((l,h)=>{a.onmessage=c=>{const u=c.data;u.type=="decode"?l(u.result):u.type=="error"&&h(u.error)},a.postMessage({type:"decoder",buffer:i,attributes:r.attributes},[i])});i.result=o}return i.result}static unload(t){let e=this._workers.get(t);e&&(e.terminate(),this._workers.delete(t))}static async initDecoder(){if(!this._workerCode){let t=await new st().loadTxt("https://cdn.orillusion.com/draco_decoder_gltf.js");const e=new Blob([t.data,"",`(${Sc})()`],{type:"application/javascript"});this._workerCode=URL.createObjectURL(e)}return this._workerCode}}s(Za,"_workerCode"),s(Za,"_workers",new Map);function Sc(){let n,t;onmessage=e=>{const r=e.data;switch(r.type){case"init":n=r.decoderConfig,t=new Promise((o,l)=>{n.onModuleLoaded=h=>{o({draco:h})},DracoDecoderModule(n)});break;case"decoder":const a=r.buffer,i=r.attributes;t.then(o=>{const l=o.draco;let h=new l.Decoder,c=new l.DecoderBuffer;c.Init(new Int8Array(a),a.byteLength);let u,d;try{const f=h.GetEncodedGeometryType(c);f==l.TRIANGULAR_MESH?(d=new l.Mesh,u=h.DecodeBufferToMesh(c,d)):self.postMessage(new Error("INVALID_GEOMETRY_TYPE:"+f)),u.ok()||self.postMessage(new Error("DracoDecode:"+u.error_msg()));let A={};for(const p in i){let B=h.GetAttributeByUniqueId(d,i[p]);const F=B.num_components(),U=d.num_points()*F,Q=U*Float32Array.BYTES_PER_ELEMENT,y=l.DT_FLOAT32,b=l._malloc(Q);h.GetAttributeDataArrayForAllPoints(d,B,y,Q,b);const x=new Float32Array(l.HEAPF32.buffer,b,U).slice();l._free(b),A[p]={data:x,numComponents:F,normalize:!1}}{const p=d.num_faces()*3,B=p*4,F=l._malloc(B);h.GetTrianglesUInt32Array(d,B,F);const U=new Uint32Array(l.HEAPF32.buffer,F,p).slice();l._free(F),A.indices={data:U,numComponents:1,normalize:!1}}self.postMessage({type:"decode",result:A})}catch(f){self.postMessage({type:"error",error:f.message})}finally{l.destroy(d),l.destroy(h),l.destroy(c)}});break}}}class Rc{constructor(t){s(this,"gltf");this.gltf=t}parse(t){const e=this.gltf.cameras[t];if(!e)return this.errorMiss("camera",t);if(e.isParsed)return e.dcamera;e.isParsed=!0,e.dcamera=!1;const{name:r,type:a,perspective:i,orthographic:o}=e;if(a==="perspective"&&i){const{aspectRatio:l,yfov:h,zfar:c,znear:u}=i;e.dcamera=Object.assign({},{name:r,type:a,yfov:h,znear:u,aspectRatio:l,zfar:c})}else if(a==="orthographic"&&o){const{xmag:l,ymag:h,zfar:c,znear:u}=o;e.dcamera=Object.assign({},{name:r,type:a,xmag:l,ymag:h,zfar:c,znear:u})}return e.dcamera}errorMiss(t,e){throw new Error(t+e)}}const Wr=class Wr extends at{constructor(){super(...arguments);s(this,"_gltf")}async parseJson(e){this._gltf=new Ii,this._gltf={...this._gltf,...e},this._gltf.resources={},await Promise.all([this.load_gltf_bin(),this.load_gltf_textures()]);let r=new bi,a=await r.parse(this.initUrl,this._gltf,this._gltf.scene);return r.destroy(),r=null,a?(this.data=a.rootNode,a.rootNode):(this._gltf=null,null)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}static getMeshNameCounter(){return function(){return`GLTF_NO_NAME_PRIMITIVE_${Wr._counter++}`}}static getModelNameCounter(){let e=0;return function(){return`GLTF_NO_NAME_MESH_${e++}`}}static getTexCoordDefine(e){return`UV_NUM ${e}`}static getVertexColorDefine(e){return`HAS_VERTEXCOLOR ${e}`}static getBaseColorTextureDefine(){return"HAS_BASECOLORMAP"}static getMetalRoughnessDefine(){return"HAS_METALROUGHNESSMAP"}static getNormalMapDefine(){return"HAS_NORMALMAP"}static getEmissiveMapDefine(){return"HAS_EMISSIVEMAP"}static getOcclusionMapDefine(){return"HAS_OCCLUSIONMAP"}static getMorphTargetsDefine(e){return`MORPH_TARGET_NUM ${e}`}static getMorphtargetPositionDefine(){return"HAS_MORPH_POSITION"}static getMorphtargetNormalDefine(){return"HAS_MORPH_NORMAL"}static getMorphtargetTangentDefine(){return"HAS_MORPH_TANGENT"}static getJointsNumDefine(e){return`JOINTS_NUM ${e}`}static getJointVec8Define(){return"JOINT_VEC8"}static getHasNormalDefine(){return"HAS_NORMAL"}static getHasTangentDefine(){return"HAS_TANGENT"}static getHasNormalMapDefine(){return"HAS_NORMAL_MAP"}static getAlphaMaskDefine(){return"ALPHA_MASK"}static getAlphaBlendDefine(){return"ALPHA_BLEND"}async load_gltf_bin(){var e;if(this._gltf.buffers&&this._gltf.buffers.length>0){let r=[];for(let a=0;a<this._gltf.buffers.length;a++){const i=this._gltf.buffers[a];if(i.uri.substring(0,5)!=="data:"){let o=et.parseUrl(this.baseUrl,i.uri);(e=this.loaderFunctions)!=null&&e.onUrl&&(o=await this.loaderFunctions.onUrl(o));let l=new st().loadBinData(o,this.loaderFunctions).then(h=>{this._gltf.resources[i.uri]=h});r.push(l)}}await Promise.all(r)}}async load_gltf_textures(){var e;if(this._gltf,this._gltf.images){let r=[];for(let a=0;a<this._gltf.images.length;a++){const i=this._gltf.images[a];if(i.uri){let o=et.parseUrl(this.baseUrl,i.uri);(e=this.loaderFunctions)!=null&&e.onUrl&&(o=await this.loaderFunctions.onUrl(o));let l=new st().loadAsyncBitmapTexture(o,this.loaderFunctions).then(h=>{h.name=et.getURLName(i.uri),this._gltf.resources[h.name]=h});r.push(l)}}await Promise.all(r)}}};s(Wr,"format",ke.JSON),s(Wr,"_counter",0),s(Wr,"defaultMaterial",{name:"GLTF_DEFAULT_MATERIAL",alphaCutoff:.33,alphaMode:"MASK",pbrMetallicRoughness:{name:"GLTF_DEFAULT_MATERIAL",defines:[],doubleSided:!1,baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1,emissiveFactor:[0,0,0]}});let $e=Wr;class Ec{constructor(t){s(this,"gltf");s(this,"subParser");this.gltf=t.gltf,this.subParser=t}async parse(t){const e=this.gltf.meshes[t];if(!e)return this.errorMiss("mesh",t);if(e.isParsed)return e.dprimitives;const r=e.primitives,a=e.extras,i=[];for(let o=0;o<r.length;o++){const l=r[o],{attributes:h,indices:c,material:u,mode:d,name:f,targets:A,morphTargetsRelative:p,extensions:B}=l;let F=e.name;for(let D in h)F+=D;F+=`indices:${c}`,F+=`material:${u}`;const U={attribArrays:{indices:[]},weights:[],defines:[],material:null,drawMode:null,meshName:null,modelName:null,morphTargetsRelative:!1,targetNames:a?a.targetNames:null};let Q=!1,y=0,b=!1,x;B&&B.KHR_draco_mesh_compression&&(x=await Za.apply(this.subParser,l));for(const D in h){const O=x?x[D]:this.parseAccessor(h[D]);if(O){let L;switch(D){case"POSITION":L=k.position;break;case"NORMAL":L=k.normal,Q=!0;break;case"TEXCOORD_0":L=k.uv,y++;break;case"JOINTS_0":L=k.joints0;break;case"JOINTS_1":L=k.joints1,b=!0;break;case"WEIGHTS_0":L=k.weights0;break;case"WEIGHTS_1":L=k.weights1;break;default:L=D}U.attribArrays[L]=O}}if(Q&&U.defines.push($e.getHasNormalDefine()),y&&U.defines.push($e.getTexCoordDefine(y)),b&&U.defines.push($e.getJointVec8Define()),c!==void 0){const D=x?x.indices:this.parseAccessor(c);D&&(U.attribArrays.indices=D)}const w=await this.parseMaterial(u);if(w&&(U.material=w,U.defines=U.defines.concat(w.defines)),U.drawMode=d===void 0?4:d,U.meshName=()=>F,U.modelName=e.name||$e.getModelNameCounter(),A){U.defines.push($e.getMorphTargetsDefine(A.length)),U.morphTargetsRelative=!0;let D=!1,O=!1,L=!1;for(let $=0;$<A.length;$++){const J=A[$];Object.keys(J).forEach(ue=>{const ee=this.parseAccessor(J[ue]);if(ee){let se;switch(ue){case"POSITION":se=le.MORPH_POSITION_PREFIX+$,D=!0;break;case"NORMAL":se=le.MORPH_NORMAL_PREFIX+$,O=!0;break;case"TANGENT":se=le.MORPH_TANGENT_PREFIX+$,L=!0;break;default:se=!1}se?U.attribArrays[se]=ee:console.error(`glTF has unsupported morph target attribute ${ue}`)}})}D&&U.defines.push($e.getMorphtargetPositionDefine()),O&&U.defines.push($e.getMorphtargetNormalDefine()),L&&U.defines.push($e.getMorphtargetTangentDefine()),U.weights=e.weights||new Array(A.length).fill(0)}i.push(U)}return e.dprimitives=i,e.isParsed=!0,e.dprimitives}parseAccessor(t){return this.subParser.parseAccessor(t)}parseMaterial(t){return this.subParser.parseMaterial(t)}errorMiss(t,e){throw new Error(t+e)}}class yc{constructor(t){s(this,"gltf");s(this,"subParser");this.gltf=t.gltf,this.subParser=t}async parse(t){let e;if(t==null?e=$e.defaultMaterial:e=this.gltf.materials[t],!e)return this.errorMiss("material",t);if(e.isParsed)return e.dmaterial;let{name:r,pbrMetallicRoughness:a,normalTexture:i,occlusionTexture:o,emissiveTexture:l,emissiveFactor:h,alphaMode:c,alphaCutoff:u,doubleSided:d,extensions:f}=e;const A={name:r,defines:[],doubleSided:!!d,baseColorFactor:[1,1,1,1],emissiveFactor:null,alphaCutoff:0,enableBlend:!1,baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,emissiveTexture:null,extensions:null,baseMapOffsetSize:null,normalMapOffsetSize:null,emissiveMapOffsetSize:null,roughnessMapOffsetSize:null,metallicMapOffsetSize:null,aoMapOffsetSize:null,metallicFactor:0,roughnessFactor:1};if(a){const{baseColorFactor:p,metallicFactor:B,roughnessFactor:F,baseColorTexture:U,metallicRoughnessTexture:Q}=a;if(Object.assign(A,{baseColorFactor:p||[1,1,1,1],metallicFactor:B===void 0?1:B,roughnessFactor:F===void 0?.5:F}),U){let y=U.extensions;if(y){let x=y.KHR_texture_transform;if(x){let w=new j(x.offset?x.offset[0]:0,x.offset?x.offset[1]:0,x.scale?x.scale[0]:1,x.scale?x.scale[1]:1);A.baseMapOffsetSize=w}}const b=await this.parseTexture(U.index);b?A.baseColorTexture=b:A.baseColorTexture=C.res.redTexture}if(i){let y=i.extensions;if(y){let x=y.KHR_texture_transform;if(x){let w=new j(x.offset?x.offset[0]:0,x.offset?x.offset[1]:0,x.scale?x.scale[0]:1,x.scale?x.scale[1]:1);A.normalMapOffsetSize=w}}const b=await this.parseTexture(i.index);b?A.normalTexture=b:A.normalTexture=C.res.normalTexture}if(Q){let y=Q.extensions;if(y){let x=y.KHR_texture_transform;if(x){let w=new j(x.offset?x.offset[0]:0,x.offset?x.offset[1]:0,x.scale?x.scale[0]:1,x.scale?x.scale[1]:1);A.roughnessMapOffsetSize=w}}const b=await this.parseTexture(Q.index);b?A.metallicRoughnessTexture=b:A.metallicRoughnessTexture=C.res.blackTexture}}else Object.assign(A,{baseColorFactor:[1,1,1,1],metallicFactor:0,roughnessFactor:.5});if(A.baseColorFactor&&A.baseColorFactor[3]<1&&(c=c==="MASK"?"MASK":"BLEND"),c&&c!=="OPAQUE"&&(c==="MASK"&&(A.defines.push($e.getAlphaMaskDefine()),A.alphaCutoff=u===void 0?.5:u),c==="BLEND"&&(A.defines.push($e.getAlphaBlendDefine()),A.enableBlend=!0)),i){const p=await this.parseTexture(i.index);p?A.normalTexture=p:A.normalTexture=C.res.normalTexture}if(o){const p=await this.parseTexture(o.index);p&&(A.occlusionTexture=p)}if(h&&(A.emissiveFactor=h),l){const p=await this.parseTexture(l.index);p?A.emissiveTexture=p:A.emissiveTexture=C.res.blackTexture}return f&&(A.extensions=f),e.isParsed=!0,e.dmaterial=A,A}async parseTexture(t){return this.subParser.parseTexture(t)}errorMiss(t,e){throw new Error(t+e)}}class Ic{constructor(t){s(this,"gltf");s(this,"subParser");this.gltf=t.gltf,this.subParser=t}parse(t){const e=this.gltf.skins[t];if(!e)return this.errorMiss("skin",t);if(e.isParsed)return e.dskin;const{name:r,joints:a,inverseBindMatrices:i,skeleton:o}=e;if(!a)return this.errorMiss("skin.joints",t);e.isParsed=!0,e.dskin=!1;let l={name:r,skeleton:null,inverseBindMatrices:null,joints:a,defines:[$e.getJointsNumDefine(a.length)]};if(o)l.skeleton=o;else{var h=-1;for(let c=0;c<this.gltf.nodes.length;c++)if(this.gltf.nodes[c].name=="root"){h=c;break}if(h==-1){let c=this.gltf.scenes[this.gltf.scene];h=c.nodes[c.nodes.length-1]}l.skeleton=h}if(l.inverseBindMatrices=le.IDENTITY_INVERSE_BIND_MATRICES,i!==void 0){const c=this.parseAccessor(i);if(c){const u=c.data,d=[];for(let f=0;f<u.length;f+=16)d.push(u.slice(f,f+16));l.inverseBindMatrices=d}else l=null}return e.dskin=l,e.dskin}parseAccessor(t){return this.subParser.parseAccessor(t)}errorMiss(t,e){throw new Error(t+e)}}class xc{constructor(t=""){s(this,"name","");s(this,"index",0);s(this,"instanceID","");s(this,"parent",null);s(this,"scale",new g);s(this,"rotation",new X);s(this,"translation",new g);this.name=t}}class _s{constructor(t,e=!1){s(this,"index");s(this,"worldMatrix");this.index=t,this.worldMatrix=new Z(!e)}}class Xa{constructor(t,e=!1){s(this,"time");s(this,"_skeleton");s(this,"_jointsPose");s(this,"mJointMatrixIndexTable");this._skeleton=t,this._jointsPose=new Array(t.numJoint),this.mJointMatrixIndexTable=new Array(t.numJoint);for(let r=0;r<t.numJoint;r++){let a=new _s(r,e);this._jointsPose[r]=a,this.mJointMatrixIndexTable[r]=a.worldMatrix.index}}buildSkeletonPose(t){let e=new g,r=new X,a=new g,i=new Array(this._skeleton.numJoint);this.time=t[11]>0?t[11]:t[24];for(let o=0;o<this._skeleton.numJoint;o++){let l=12*o*4,h=new Float32Array(t.buffer,t.byteOffset+l,12),c=new Z;e.set(h[0],h[1],h[2]),r.set(h[4],h[5],h[6],h[7]),a.set(h[8],h[9],h[10]),Ci(r.getEulerAngles(),a,e,c),i[o]=c;let u=new _s(o);const d=this._skeleton.getJointParentIndex(o);if(d<0)u.worldMatrix.copyFrom(c);else{let f=this._jointsPose[d];xl(f.worldMatrix,c,u.worldMatrix)}this._jointsPose[o]=u}}get numJoint(){return this._skeleton.numJoint}get joints(){return this._jointsPose}get jointMatrixIndexTable(){return this.mJointMatrixIndexTable}lerp(t,e,r){if(t&&e)for(let a=0;a<this._jointsPose.length;a++){let i=t._jointsPose[a],o=e._jointsPose[a];this._jointsPose[a].worldMatrix.lerp(i.worldMatrix,o.worldMatrix,r)}else for(let a=0;a<this._jointsPose.length;a++){let i=t._jointsPose[a];this._jointsPose[a].worldMatrix.copyFrom(i.worldMatrix)}}copyFrom(t){for(let e=0;e<this._jointsPose.length;e++)this._jointsPose[e].worldMatrix.copyFrom(t._jointsPose[e].worldMatrix)}reset(){for(let t=0;t<this._jointsPose.length;t++)this._jointsPose[t].worldMatrix.identity()}}class bc extends pt{constructor(e,r){super();s(this,"skeletonAnimation");this.type=e,this.time=r}}class Yi{constructor(t,e,r,a){s(this,"name","");s(this,"_skeleton");s(this,"_skeletonPoses");s(this,"_animationClipData");s(this,"_events");if(this.name=t,this._skeleton=e,this._animationClipData=a,r>0&&a){this._skeletonPoses=new Array(r);let i=12*e.numJoint;for(let o=0;o<r;o++){let l=i*o*4,h=new Float32Array(a.buffer,l,i),c=new Xa(e);c.buildSkeletonPose(h),this._skeletonPoses[o]=c}}}get totalTime(){return this._skeletonPoses[this._skeletonPoses.length-1].time}get frameRate(){return this.totalTime/this._skeletonPoses.length}get skeleton(){return this._skeleton}get numFrame(){return this._skeletonPoses.length-1}get animationClipData(){return this._animationClipData}getSkeletonPose(t){return this._skeletonPoses[t]}getLerpSkeletonPose(t,e,r,a){let i=this.getSkeletonPose(t),o=this.getSkeletonPose(e);return a.lerp(i,o,r),a}createSubClip(t,e,r){var a=new Yi(t,this._skeleton,0,null);const i=Math.max(Math.floor(e/this.frameRate),0),o=Math.min(Math.floor(r/this.frameRate),this._skeletonPoses.length-1);a._skeletonPoses=this._skeletonPoses.slice(i,o);const l=12*this._skeleton.numJoint*4;return this._animationClipData=new Float32Array(this._animationClipData,i*l,(o-i)*l),a}addEvent(t,e){this._events||(this._events=new Array),this._events.push(new bc(t,e))}removeEvent(t){this._events&&(this._events=this._events.filter(e=>e.type!=t))}getEvents(){return this._events}}class Ts{constructor(t){s(this,"gltf");s(this,"subParser");this.gltf=t.gltf,this.subParser=t}parse(t){let e=new xn;return e.name="Id:"+t,e.count=0,e.boneData=[],e.boneMap=new Map,this.buildSkeleton(e,void 0,t),e}parseSkeletonAnimation(t,e){let r=new Mn;r.clipName=e.name,r.useSkeletonPos=!1,r.useSkeletonScale=!1;for(let a of e.channels){let i=e.samplers[a.sampler];const o=this.subParser.parseAccessor(i.input),l=this.subParser.parseAccessor(i.output);let h=a.target.node,c=a.target.path,u=this.gltf.nodes[h];if(!u||!t.boneMap.has(u.name))continue;let d=t.boneMap.get(u.name);switch(c){case"scale":{let f=new br(l.numComponents);f.path="",f.attribute="",f.propertys=f.attribute.split("."),f.preInfinity=0,f.postInfinity=0,f.rotationOrder=0,r.useSkeletonScale=!0,r.scaleCurves.set(d.bonePath,f);for(let A=0;A<o.data.length;A++){const p=o.data[A],B=A*l.numComponents;let F=new Da(0);F.time=p;const U=new g().set(l.data[B+0],l.data[B+1],l.data[B+2]);F.split(V.vector3,U,"value"),f.addKeyFrame(F)}}break;case"rotation":{let f=new br(l.numComponents);f.path="",f.attribute="",f.propertys=f.attribute.split("."),f.preInfinity=0,f.postInfinity=0,f.rotationOrder=0,r.rotationCurves.set(d.bonePath,f);for(let A=0;A<o.data.length;A++){const p=o.data[A],B=A*l.numComponents;let F=new Da(0);F.time=p;const U=new X().set(l.data[B+0],l.data[B+1],l.data[B+2],l.data[B+3]);F.split(V.quaternion,U,"value"),f.addKeyFrame(F)}}break;case"translation":{let f=new br(l.numComponents);f.path="",f.attribute="",f.propertys=f.attribute.split("."),f.preInfinity=0,f.postInfinity=0,f.rotationOrder=0,r.useSkeletonPos=!0,r.positionCurves.set(d.bonePath,f);for(let A=0;A<o.data.length;A++){const p=o.data[A],B=A*l.numComponents;let F=new Da(0);F.time=p;const U=new g().set(l.data[B+0],l.data[B+1],l.data[B+2]);F.split(V.vector3,U,"value"),f.addKeyFrame(F)}}break}}return r}parseSkeletonAnimationOld(t,e){let r=this.subParser.parseAccessor(e.samplers[0].input),a=r.data.length,i=r.data[1]-r.data[0];r.data[r.data.length-1];let o=12*t.numJoint,l=new Float32Array(o*a);for(var h=0;h<t.numJoint;h++)for(var c=0;c<a;c++){var u=o*c+12*h;l[u+0]=1,l[u+1]=1,l[u+2]=1,l[u+3]=1}for(let p of e.channels){let B=e.samplers[p.sampler];const F=this.subParser.parseAccessor(B.input),U=this.subParser.parseAccessor(B.output);let Q=p.target.node,y=p.target.path,b=this.gltf.nodes[Q];if(!b)continue;let x=t.getJointByName(b.name);if(x)switch(y){case"scale":if(a*U.numComponents==U.data.length)for(var c=0;c<a;c++){var d=c*U.numComponents,u=o*c+12*x.index;l[u+0]=U.data[d+0],l[u+1]=U.data[d+1],l[u+2]=U.data[d+2],l[u+3]=1}else if(F.data.length==2){let w=0;F.data[0];let D=F.data[1];var f=0*U.numComponents;g.HELP_0.set(U.data[f+0],U.data[f+1],U.data[f+2]);var A=1*U.numComponents;g.HELP_1.set(U.data[A+0],U.data[A+1],U.data[A+2]);for(var c=0;c<a;c++){let L=w/D;g.HELP_2.lerp(g.HELP_0,g.HELP_1,L);var u=o*c+12*x.index;l[u+0]=g.HELP_2.x,l[u+1]=g.HELP_2.y,l[u+2]=g.HELP_2.z,l[u+3]=1,w+=i}}else throw new Error("Unsupported animation sampler interpolation.");break;case"rotation":if(a*U.numComponents==U.data.length)for(var c=0;c<a;c++){var d=c*U.numComponents,u=o*c+12*x.index+4;l[u+0]=U.data[d+0],l[u+1]=U.data[d+1],l[u+2]=U.data[d+2],l[u+3]=U.data[d+3]}else if(F.data.length==2){let w=0;F.data[0];let D=F.data[1];var f=0*U.numComponents;g.HELP_0.set(U.data[f+0],U.data[f+1],U.data[f+2],U.data[f+3]);var A=1*U.numComponents;g.HELP_1.set(U.data[A+0],U.data[A+1],U.data[A+2],U.data[A+3]);for(var c=0;c<a;c++){let J=w/D;g.HELP_2.lerp(g.HELP_0,g.HELP_1,J);var u=o*c+12*x.index+4;l[u+0]=g.HELP_2.x,l[u+1]=g.HELP_2.y,l[u+2]=g.HELP_2.z,l[u+3]=g.HELP_2.w,w+=i}}else throw new Error("Unsupported animation sampler interpolation.");break;case"translation":if(a*U.numComponents==U.data.length)for(var c=0;c<a;c++){var d=c*U.numComponents,u=o*c+12*x.index+8;l[u+0]=U.data[d+0],l[u+1]=U.data[d+1],l[u+2]=U.data[d+2],l[u+3]=F.data[c*F.numComponents]}else if(F.data.length==2){let w=0;F.data[0];let D=F.data[1];var f=0*U.numComponents;g.HELP_0.set(U.data[f+0],U.data[f+1],U.data[f+2]);var A=1*U.numComponents;g.HELP_1.set(U.data[A+0],U.data[A+1],U.data[A+2]);for(var c=0;c<a;c++){let J=w/D;g.HELP_2.lerp(g.HELP_0,g.HELP_1,J);var u=o*c+12*x.index+8;l[u+0]=g.HELP_2.x,l[u+1]=g.HELP_2.y,l[u+2]=g.HELP_2.z,l[u+3]=w,w+=i}}else throw new Error("Unsupported animation sampler interpolation.");break}}return new Yi(e.name,t,a,l)}buildSkeleton(t,e,r){let a=this.gltf.nodes[r];a.name||(a.name="Bone"+t.count);let i=new In;if(i.boneName=a.name,i.bonePath=e?e.bonePath+"/"+a.name:a.name,i.parentBoneName=e?e.boneName:"",i.boneID=t.count++,i.parentBoneID=e?e.boneID:-1,i.instanceID="",i.parentInstanceID="",i.s=new g(1,1,1),a.scale&&i.s.set(a.scale[0],a.scale[1],a.scale[2]),i.q=new X,a.rotation&&i.q.set(a.rotation[0],a.rotation[1],a.rotation[2],a.rotation[3]),i.t=new g,a.translation&&i.t.set(a.translation[0],a.translation[1],a.translation[2]),t.boneData.push(i),t.boneMap.set(i.boneName,i),a.children)for(let o of a.children)this.buildSkeleton(t,i,o)}buildSkeletonOld(t,e,r,a=0){let i=this.gltf.nodes[r];i.name||(i.name="Node_"+r);let o=new xc(i.name);if(o.parent=e,i.scale&&o.scale.set(i.scale[0],i.scale[1],i.scale[2]),i.rotation&&o.rotation.set(i.rotation[0],i.rotation[1],i.rotation[2],i.rotation[3]),i.translation&&o.translation.set(i.translation[0],i.translation[1],i.translation[2]),t.addJoint(o),i.children)for(let l of i.children)this.buildSkeletonOld(t,o,l,a+1)}}class xi{static add(t){this.list.indexOf(t)==-1&&this.list.push(t)}static remove(t){let e=this.list.indexOf(t);e!=-1&&this.list.splice(e,1)}}s(xi,"list",[]);class ni extends ut{constructor(){super();s(this,"name");s(this,"size",1);s(this,"lightData");s(this,"dirFix",1);s(this,"bindOnChange");s(this,"needUpdateShadow",!0);s(this,"realTimeShadow",!0);s(this,"_castGI",!1);s(this,"_castShadow",!1);s(this,"_iesProfiles")}init(){this.transform.object3D.bound=new Pe(new g,new g),this.lightData=new Pa,this.lightData.lightMatrixIndex=this.transform.worldMatrix.index}onChange(){this.bindOnChange&&this.bindOnChange(),this.transform.object3D.bound.setFromCenterAndSize(this.transform.worldPosition,new g(this.size,this.size,this.size)),this._castGI&&(P.instance.state.giLightingChange=!0),this._castShadow?(this.needUpdateShadow=!0,mt.addShadowLight(this)):mt.removeShadowLight(this),this.transform.view3D&&C.renderJobs&&C.renderJobs.get(this.transform.view3D).reflectionRenderer&&C.renderJobs.get(this.transform.view3D).reflectionRenderer.forceUpdate()}start(){this.transform.onPositionChange=()=>this.onPositionChange(),this.transform.onRotationChange=()=>this.onRotChange(),this.onPositionChange(),this.onRotChange()}onPositionChange(){this.lightData.lightPosition.copyFrom(this.transform.worldPosition),this.onChange()}onRotChange(){this.dirFix==1?this.lightData.direction.copyFrom(this.transform.forward):this.lightData.direction.copyFrom(this.transform.back),this.lightData.lightTangent.copyFrom(this.transform.up),this.onChange()}onScaleChange(){this.onChange()}onEnable(){this.onChange(),P.instance.addLight(this.transform.scene3D,this)}onDisable(){this.onChange(),P.instance.removeLight(this.transform.scene3D,this),mt.removeShadowLight(this)}set iesProfiles(e){this._iesProfiles=e,this.lightData.iesIndex=e.index,Ua.use=!0,this.onChange()}get iesProfile(){return this._iesProfiles}get r(){return this.lightData.lightColor.r}set r(e){this.lightData.lightColor.r=e,this.onChange()}get g(){return this.lightData.lightColor.g}set g(e){this.lightData.lightColor.g=e,this.onChange()}get b(){return this.lightData.lightColor.b}set b(e){this.lightData.lightColor.b=e,this.onChange()}get lightColor(){return this.lightData.lightColor}set lightColor(e){this.lightData.lightColor=e,this.onChange()}get color(){return this.lightData.lightColor}set color(e){this.lightData.lightColor=e,this.onChange()}get intensity(){return this.lightData.intensity}set intensity(e){this.lightData.intensity=e,this.onChange()}set castShadow(e){e!=this._castShadow&&(this._castShadow=e,this.onChange())}get castShadow(){return this._castShadow}get shadowIndex(){return this.lightData.castShadowIndex}get castGI(){return this._castGI}set castGI(e){e?xi.add(this):xi.remove(this),this._castGI=e,e&&this.onChange()}get direction(){return this.lightData.direction}destroy(e){this.bindOnChange=null,P.instance.removeLight(this.transform.scene3D,this),mt.removeShadowLight(this),this.transform.eventDispatcher.removeEventListener(Jt.ROTATION_ONCHANGE,this.onRotChange,this),this.transform.eventDispatcher.removeEventListener(Jt.SCALE_ONCHANGE,this.onScaleChange,this),super.destroy(e)}}var _c=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let fa=class extends ni{constructor(){super();s(this,"shadowCamera")}init(){super.init(),this.object3D.name==""&&(this.object3D.name="DirectionLight_"+Ft()),this.radius=Number.MAX_SAFE_INTEGER,this.lightData.lightType=De.DirectionLight,this.lightData.linear=0,this.lightData.quadratic=.3}start(){super.start(),this.castGI=!0}get radius(){return this.lightData.range}set radius(t){this.lightData.range=t,this.onChange()}get indirect(){return this.lightData.quadratic}set indirect(t){this.lightData.quadratic=t,this.onChange()}debug(){}};fa=_c([Tt(fa,"DirectLight")],fa);var Tc=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let _a=class extends ni{constructor(){super()}init(){super.init(),this.lightData.lightType=De.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+Ft())}get range(){return this.lightData.range}set range(n){this.lightData.range=n,this.onChange()}get at(){return this.lightData.linear}set at(n){this.lightData.linear=n,this.onChange()}get radius(){return this.lightData.radius}set radius(n){this.lightData.radius=n,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(n){this.lightData.quadratic=n,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(n){}debug(){}debugDraw(n){}};_a=Tc([Tt(_a,"PointLight")],_a);var wc=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let Ta=class extends ni{constructor(){super()}init(){super.init(),this.lightData.lightType=De.SpotLight,this.object3D.name==""&&(this.object3D.name="SpotLight"+Ft())}get innerAngle(){return this.lightData.innerAngle/this.lightData.outerAngle*100}set innerAngle(n){this.lightData.innerAngle=yt(n,0,100)/100*this.lightData.outerAngle,this.onChange()}get outerAngle(){return this.lightData.outerAngle*Ca*2}set outerAngle(n){this.lightData.outerAngle=yt(n,1,179)*Ze*.5,this.onChange()}get radius(){return this.lightData.radius}set radius(n){this.lightData.radius=n,this.onChange()}get range(){return this.lightData.range}set range(n){this.lightData.range=n,this.onChange()}get at(){return this.lightData.linear}set at(n){this.lightData.linear=n,this.onChange()}start(){super.start(),this.lightData.lightType=De.SpotLight}onUpdate(){}onGraphic(n){}debug(){}debugDraw(n){}};Ta=wc([Tt(Ta,"SpotLight")],Ta);class Dc{static apply(t,e,r){let a=e.extensions;if(a&&a.KHR_materials_clearcoat){r.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT",!0);let i=a.KHR_materials_clearcoat;"clearcoatFactor"in i&&(e.clearcoatFactor=i.clearcoatFactor,r.clearcoatFactor=e.clearcoatFactor),"clearcoatRoughnessFactor"in i&&(e.clearcoatRoughnessFactor=i.clearcoatRoughnessFactor,r.clearcoatRoughnessFactor=e.clearcoatRoughnessFactor)}}}class Vc{static apply(t,e,r){let a=e.extensions;a&&a.KHR_materials_emissive_strength?(r.emissiveIntensity=a.KHR_materials_emissive_strength.emissiveStrength,r.emissiveMap==C.res.blackTexture&&(r.emissiveMap=C.res.whiteTexture)):r.emissiveIntensity=1}}class Nc{static apply(t,e,r){let a=e.extensions;a&&a.KHR_materials_unlit?r.supportLight=!0:r.supportLight=!1}}class Mc{constructor(t){s(this,"gltf");s(this,"subParser");s(this,"_testCount",8);s(this,"_hasCastShadow",!1);this.gltf=t.gltf,this.subParser=t}async convertNodeToObject3D(t,e){const r=new ie;if(r.name=t.name,r[le.GLTF_NODE_INDEX_PROPERTY]=t.nodeId,t.nodeObj=r,t.matrix&&(t.translation=[0,0,0],t.rotation=[0,0,0,1],t.scale=[1,1,1]),t.translation&&(r.transform.x=t.translation[0],r.transform.y=t.translation[1],r.transform.z=t.translation[2]),t.rotation){let a=new X;a.setFromArray(t.rotation),r.transform.localRotQuat=a}return t.scale&&(r.transform.scaleX=t.scale[0],r.transform.scaleY=t.scale[1],r.transform.scaleZ=t.scale[2]),e.addChild(r),t.light&&this.convertLight(t,r),t.primitives&&this.convertprimitives(t,r),t.skeleton&&this.convertSkeletonAnim(r,t.skeleton),r}convertSkeletonAnim(t,e){let r=this.subParser.parseSkeleton(e.skeleton);C.res.addObj(r.name,r);let a=[];for(let o=0;o<this.gltf.animations.length;o++){let l=this.gltf.animations[o];l.name||(l.name=o.toString());let h=this.subParser.parseSkeletonAnimation(r,l);a.push(h)}let i=t.addComponent(gr);i.avatar=r.name,i.clips=a}convertLight(t,e){switch(t.light.type){case"directional":let r=e.addComponent(fa);e.name=t.light.name,r.intensity=t.light.intensity*.1,r.radius=Number.MAX_SAFE_INTEGER,r.dirFix=-1,this._hasCastShadow||(this._hasCastShadow=!0,r.castShadow=this._hasCastShadow),r.lightColor=t.light.color?new Y(t.light.color[0],t.light.color[1],t.light.color[2]):new Y(1,1,1,1),r.debug();break;case"point":if(this._testCount>0){let i=e.addComponent(_a);i.name=t.light.name,i.intensity=t.light.intensity?t.light.intensity*8*2:1,i.radius=8,i.at=2,i.range=t.light.range?t.light.range:8,i.lightColor=t.light.color?new Y(t.light.color[0],t.light.color[1],t.light.color[2]):new Y(1,1,1,1)}this._testCount--;break;case"spot":let a=e.addComponent(Ta);a.name=t.light.name,a.intensity=t.light.intensity*5,a.radius=1,a.dirFix=-1,a.at=2,a.range=t.light.range?t.light.range:8,a.outerAngle=t.light.spot.outerConeAngle*Ca,a.lightColor=t.light.color?new Y(t.light.color[0],t.light.color[1],t.light.color[2]):new Y(1,1,1,1);break}}convertprimitives(t,e){var r;for(let a=0;a<t.primitives.length;a++){const i=t.primitives[a];i.modelName;let o=i.material;o.name==null&&(o.name=Ft());let l,h=`matkey_${o.name}`;if(o&&this.gltf.resources[h])l=this.gltf.resources[h];else{let A=l=new Vr;this.gltf.resources[h]=A,A.name=o.name;let p=o;if(p){const{baseColorTexture:B,baseColorFactor:F,metallicFactor:U,roughnessFactor:Q,doubleSided:y,metallicRoughnessTexture:b,normalTexture:x,occlusionTexture:w,emissiveTexture:D,emissiveFactor:O,enableBlend:L,alphaCutoff:$}=p;let J=A=this.applyMaterialExtensions(p,A);if("enableBlend"in p&&(p.enableBlend?((r=p.defines)!=null&&r.includes("ALPHA_BLEND")?J.blendMode=q.ALPHA:J.blendMode=q.NORMAL,J.castShadow=!1):J.blendMode=q.NONE),"alphaCutoff"in p&&$>0&&$<1&&(J.setUniformFloat("alphaCutoff",$),J.blendMode=q.NORMAL,J.transparent=!0),p.baseMapOffsetSize&&J.setUniformVector4("baseMapOffsetSize",p.baseMapOffsetSize),p.normalMapOffsetSize&&J.setUniformVector4("normalMapOffsetSize",p.normalMapOffsetSize),p.emissiveMapOffsetSize&&J.setUniformVector4("emissiveMapOffsetSize",p.emissiveMapOffsetSize),p.roughnessMapOffsetSize&&J.setUniformVector4("roughnessMapOffsetSize",p.roughnessMapOffsetSize),p.metallicMapOffsetSize&&J.setUniformVector4("metallicMapOffsetSize",p.metallicMapOffsetSize),p.aoMapOffsetSize&&J.setUniformVector4("aoMapOffsetSize",p.aoMapOffsetSize),J.setUniformColor("baseColor",new Y(F[0],F[1],F[2],F[3])),J.setUniformFloat("roughness",Q),J.setUniformFloat("metallic",U),J.setUniformFloat("ao",1),J.doubleSide=y,B&&J.setTexture("baseMap",B),x&&J.setTexture("normalMap",x),b&&J.setTexture("maskMap",b),D&&J.setTexture("emissiveMap",D),O&&(O[0]>0||O[1]>0||O[2]>0)){J.shader.getTexture("emissiveMap")||J.shader.setTexture("emissiveMap",C.res.whiteTexture),J.shader.setDefine("USE_EMISSIVEMAP",!0),J.setUniformColor("emissiveColor",new Y(O[0],O[1],O[2],O[3])),J.blendMode!=q.NONE&&(J.blendMode=q.ADD);let ue=l.getUniformFloat("emissiveIntensity");(!ue||ue<=0)&&l.setUniformFloat("emissiveIntensity",1)}}}const{attribArrays:c,modelName:u,drawMode:d}=i;let f;if(!c.indices.data){let A=[],p=c.position.data.length/3/3;for(let B=0;B<p;B++){let F=B*3;A.push(F+2),A.push(F+0),A.push(F+1)}c.indices={data:new Uint8Array(A),normalize:!1,numComponents:1}}if(!c.normal){let A=[],p=c.position.data.length/3;for(let B=0;B<p;B++)A.push(0),A.push(0),A.push(0);c.normal={data:new Float32Array(A),normalize:!1,numComponents:3}}if(c.indices.data&&c.indices.data.length>3){let A=i.meshName();this.gltf.resources[A]&&(f=this.gltf.resources[A]);const p=new ie;if(p.name=u+a,this.gltf.animations&&c[k.joints0]!=null){f||(f=this.createGeometryBase(u,c,i,t.skin)),this.gltf.resources[A]=f;let B=this.gltf.nodes[t.skin.skeleton];B.dnode&&B.dnode.nodeObj?this.convertSkeletonAnim(e,t.skin):B.dnode.skeleton=t.skin;let F=p.addComponent(Yr);F.geometry=f,F.material=l}else{f||(f=this.createGeometryBase(u,c,i)),this.gltf.resources[A]=f,f.hasAttribute(k.joints0)&&f.vertexAttributeMap.delete(k.joints0);let B=p.addComponent(Be);B.castShadow=!0,B.castGI=!0,B.geometry=f,B.material=l}t.skin&&t.skin.defines,e.addChild(p)}}}createGeometryBase(t,e,r,a){"indices"in e&&(e.indices.data.length>65534?e.indices.data=new Uint32Array(e.indices.data):e.indices.data=new Uint16Array(e.indices.data));let i=new ar;if(i.name=t,"indices"in e&&(e.indices.data.length>65535?e.indices.data=new Uint32Array(e.indices.data):e.indices.data=new Uint16Array(e.indices.data)),r.morphTargetsRelative){let h=new Dn,c=r.targetNames;if(c&&c.length>0){h.shapeNames=[],h.shapeIndexs=[];for(let u=0;u<c.length;u++)h.shapeNames.push(c[u]),h.shapeIndexs.push(u)}h.vertexCount=e.position.data.length/3,h.blendCount=h.shapeNames.length,h.blendShapePropertyDatas=[],h.blendShapeMap=new Map;for(let u=0;u<h.blendCount;u++){let d=new wn;d.shapeName=h.shapeNames[u],d.shapeIndex=h.shapeIndexs[u],d.frameCount=1,d.blendPositionList=e[le.MORPH_POSITION_PREFIX+u].data,d.blendNormalList=e[le.MORPH_NORMAL_PREFIX+u].data,h.blendShapePropertyDatas.push(d),h.blendShapeMap.set(d.shapeName,d)}i.blendShapeData=h}i.morphTargetsRelative=r.morphTargetsRelative;let o=r.targetNames;if(o&&o.length>0){let h=i.morphTargetDictionary={};for(let c=0;c<o.length;c++)h[o[c]]=c}if(i.morphTargetDictionary){let h=e.position.data.length/3,c=new Float32Array(h);for(let u=0;u<h;u++)c[u]=u;e.vIndex={data:c,normalize:!1,numComponents:1}}for(const h in e){let c=e[h];i.setAttribute(h,c.data)}if(a){i.skinNames=new Array(a.joints.length);for(let h=0;h<a.joints.length;h++){const c=a.joints[h],u=this.gltf.nodes[c];i.skinNames[h]=u.name}i.bindPose=new Array(a.inverseBindMatrices.length);for(let h=0;h<a.inverseBindMatrices.length;h++){const c=a.inverseBindMatrices[h];let u=new Z;u.rawData.set(c),i.bindPose[h]=u}}let l=i.getAttribute(k.indices);return i.addSubGeometry({indexStart:0,indexCount:l.data.length,vertexStart:0,index:0,vertexCount:0,firstStart:0,topology:0}),i}applyMaterialExtensions(t,e){return t.extensions&&(Dc.apply(this.gltf,t,e),Nc.apply(this.gltf,t,e),Vc.apply(this.gltf,t,e)),e}parseSkinJoints(t){let e=[];for(let r of t.joints){let a=this.gltf.nodes[r];e.push(a.name)}return e}}class bi{constructor(){s(this,"currentSceneName");s(this,"gltf");s(this,"initUrl");s(this,"_generator");s(this,"_version");s(this,"_BASE64_MARKER",";base64,");s(this,"_cameraParser",null);s(this,"_meshParser",null);s(this,"_materialParser",null);s(this,"_skinParser",null);s(this,"_skeletonParser",null);s(this,"_converter",null)}get version(){return this.version?this.version:this.gltf?this.gltf.asset?(this._version=this.gltf.asset.version,this.gltf.asset.minVersion&&(this._version+=`\r minVersion${this.gltf.asset.minVersion}`),this.version):this.errorMiss("asset"):(console.warn("glTF not loaded."),null)}async parse(t,e,r){this.gltf=e,this.initUrl=t;const{version:a,generator:i}=this.gltf.asset;if(this._generator=i,a!=="2.0")return console.error(`GLTFParser only support glTF 2.0 for now! Received glTF version: ${this.version}`),!1;const o={nodes:await this.parseScene(r),animations:this.parseAnimations(),name:this.currentSceneName};return await this.convertToNode(o)}destroy(){Za.unload(this.gltf),this.gltf=null}async parseScene(t){const e=t||this.gltf.scene||0,r=this.gltf.scenes[e];if(typeof r>"u")return this.errorMiss("scene",e);this.currentSceneName=r.name||"GLTF_NO_NAME_SCENE";const a=[],i=r.nodes;for(let o=0;o<i.length;o++){const l=await this.parseNode(i[o]);l&&a.push(l)}return a}async parseNode(t){const e=this.gltf.nodes[t];if(!e)return this.errorMiss("node",t);if(e.isParsed)return e.dnode;const{name:r,matrix:a,translation:i,rotation:o,scale:l}=e,h={name:r,matrix:a,translation:i,rotation:o,scale:l,nodeId:t,camera:null,primitives:null,skin:null,children:null,light:null};if(e.camera!==void 0&&(h.camera=this.parseCamera(e.camera)),e.mesh!==void 0&&(h.primitives=await this.parseMesh(e.mesh)),e.extensions!==void 0&&this.applyNodeExtensions(e,h),e.skin!==void 0){const c=this.parseSkin(e.skin);c&&(h.skin=c)}if(h.children=[],e.children)for(let c=0;c<e.children.length;c++)h.children.push(await this.parseNode(e.children[c]));return e.dnode=h,e.isParsed=!0,e.dnode}errorMiss(t,e){throw new Error(t+e)}parseCamera(t){return this._cameraParser||(this._cameraParser=new Rc(this.gltf)),this._cameraParser.parse(t)}async parseMesh(t){return this._meshParser||(this._meshParser=new Ec(this)),this._meshParser.parse(t)}async parseTexture(t){let e=this.gltf.textures[t];if(e&&!e.dtexture){if(e&&e.source!=null){let r=this.gltf.images[e.source];if(r.uri){let a=r.uri;a=et.getURLName(a),e.dtexture=this.gltf.resources[a]}else if(r.bufferView){let a=this.parseBufferView(r.bufferView),i=new Br,o=new Blob([a],{type:r.mimeType});await i.loadFromBlob(o),e.dtexture=i}else e.dtexture=this.gltf.resources[r.name]}else if(e.name){let r=et.getURLName(e.name);e.dtexture=this.gltf.resources[r]}}return e.dtexture||console.log("miss texture , please check texture!",t,e),e.dtexture}async parseMaterial(t){return this._materialParser||(this._materialParser=new yc(this)),this._materialParser.parse(t)}parseAnimations(){return[]}async parseObject3D(t,e){return this._converter||(this._converter=new Mc(this)),this._converter.convertNodeToObject3D(t,e)}parseSkeleton(t){return this._skeletonParser||(this._skeletonParser=new Ts(this)),this._skeletonParser.parse(t)}parseSkeletonAnimation(t,e){return this._skeletonParser||(this._skeletonParser=new Ts(this)),this._skeletonParser.parseSkeletonAnimation(t,e)}async traverse(t,e){for(let r=0;r<e.length;r++){const a=await this.parseObject3D(e[r],t);await this.traverse(a,e[r].children)}}async convertToNode(t){const e=new ie;e.name=t.name;const r=t.nodes;t.animations;const a=[],i=[];return await this.traverse(e,r),{rootNode:e,textures:a,animations:void 0,cameras:i}}parseSkin(t){return this._skinParser||(this._skinParser=new Ic(this)),this._skinParser.parse(t)}parseAccessor(t){const e=this.gltf.accessors[t];if(!e)return this.errorMiss("accessor",t);if(e.isParsed)return e.daccessor;e.isParsed=!0,e.daccessor=!1;const r=!!e.normalized,a=this.gltf.bufferViews[e.bufferView],i=a&&a.byteStride,o=bs(e.componentType);let l=1;switch(e.type){case"SCALAR":l=1;break;case"VEC2":l=2;break;case"VEC3":l=3;break;case"VEC4":case"MAT2":l=4;break;case"MAT3":l=9;break;case"MAT4":l=16;break;default:l=0;break}if(l===0)return console.error(`glTF has unknown data type in accessor: ${e.type}`),!1;const h=l*o.BYTES_PER_ELEMENT;let c;if(a!==void 0){if(c=this.parseBufferView(e.bufferView),!c)return e.daccessor}else c=new Uint8Array(h*e.count).buffer;let u=this.getTypedArrayFromArrayBuffer(c,i,e.byteOffset||0,o,l,e.count);if(e.sparse){const{count:d,indices:f,values:A}=e.sparse;u=new o(u);const p=f.byteOffset||0,B=this.gltf.bufferViews[f.bufferView],F=bs(f.componentType),U=this.parseBufferView(f.bufferView),Q=this.getTypedArrayFromArrayBuffer(U,B.byteStride,p,F,1,d),y=A.byteOffset||0,b=this.gltf.bufferViews[A.bufferView],x=this.parseBufferView(A.bufferView),w=this.getTypedArrayFromArrayBuffer(x,b.byteStride,y,o,l,d);for(let D=0;D<Q.length;D++)u.set(w.slice(D*l,D*l+l),Q[D]*l)}return e.computeResult={typedArray:u,arrayType:o,numComponents:l},e.daccessor={data:u,numComponents:l,normalize:r},e.daccessor}getTypedArrayFromArrayBuffer(t,e,r,a,i,o){let l;const h=i*a.BYTES_PER_ELEMENT;if(e&&h!==e){const c=i*o;l=new a(c);for(let u=0;u<o;u++){const d=new a(t,r+u*e,i);for(let f=0;f<i;f++)l[u*i+f]=d[f]}}else l=new a(t,r,o*i);return l}parseBufferView(t){const e=this.gltf.bufferViews[t];if(!e)return this.errorMiss("bufferView",t);if(e.isParsed)return e.dbufferView;e.isParsed=!0,e.dbufferView=!1;const r=this.parseBuffer(e.buffer);if(r){const{byteOffset:a,byteLength:i}=e,o=new Uint8Array(r,a||0,i);e.dbufferView=new Uint8Array(o).buffer}return e.dbufferView}parseBuffer(t){const e=this.gltf.buffers[t];if(!e)return this.errorMiss("buffer",t);if(e.isParsed)return e.dbuffer;if(e.isParsed=!0,e.dbuffer=!1,e.uri.substring(0,5)!=="data:"){const r=e.uri,a=this.gltf.resources[r];a?a.byteLength===e.byteLength?e.dbuffer=this.gltf.resources[r]:console.error(`load gltf resource "${r}" at buffers[${t} failed, ArrayBuffer.byteLength not equals buffer's byteLength]`):console.error(`load gltf resource "${r}" at buffers[${t}] failed`)}else{const r=e.uri.indexOf(this._BASE64_MARKER)+this._BASE64_MARKER.length,a=window.atob(e.uri.substring(r)),i=new Uint8Array(a.length);for(let o=0;o<a.length;o++)i[o]=a.charCodeAt(o);e.dbuffer=i.buffer}return e.dbuffer}getLight(t){return this.gltf.extensions.KHR_lights_punctual.lights[t]}applyNodeExtensions(t,e){let r=t.extensions;r.KHR_lights_punctual&&this.gltf.extensions.KHR_lights_punctual&&(e.light=this.getLight(r.KHR_lights_punctual.light))}}class kc{constructor(){s(this,"magic");s(this,"version");s(this,"length")}}class Pc{constructor(){s(this,"chunkLength");s(this,"chunkType");s(this,"chunkData")}}class Hi extends at{constructor(){super(...arguments);s(this,"_gltf")}async parseBuffer(e){let r=new Uint8Array(e);r.pos=0;const a=this.parseHeader(r);if(a.magic!=1179937895)return console.error("invalid GLB file"),!1;if(a.version!==2)return console.error(`GLBParser only support glTF 2.0 for now! Received glTF version: ${a.version}`),!1;let i=[];for(;r.pos<r.length;){let d=this.parseChunk(r);i.push(d)}if(i[0].chunkType!=1313821514)return console.error("invalid GLBChunk"),!1;let o="",l=65535,h=i[0].chunkData;for(let d=0;d<h.length;d+=l){let f=h.length-d;f=Math.min(f,l);let A=h.subarray(d,d+f);o+=String.fromCharCode(...A)}let c=JSON.parse(o);this._gltf=new Ii,this._gltf={...this._gltf,...c},this._gltf.resources={};for(let d=0;d<this._gltf.buffers.length;d++){let f=this._gltf.buffers[d];f.isParsed=!0,f.dbuffer=i[d+1].chunkData.buffer}if(this._gltf.images)for(let d=0;d<this._gltf.images.length;d++){let f=this._gltf.images[d];f.name=f.name||"bufferView_"+f.bufferView.toString();const A=this._gltf.bufferViews[f.bufferView],p=this._gltf.buffers[A.buffer];let B=new Uint8Array(p.dbuffer,A.byteOffset,A.byteLength),F=new Blob([B],{type:f.mimeType}),U=new Br;await U.loadFromBlob(F),U.name=f.name,this._gltf.resources[f.name]=U}let u=await new bi().parse(this.initUrl,this._gltf,this._gltf.scene);return u?(this.data=u.rootNode,u.rootNode):null}async parseJsonAndBuffer(e,r){this._gltf=new Ii,this._gltf={...this._gltf,...e},this._gltf.resources={};let a=this._gltf.buffers[0];if(a.isParsed=!0,a.dbuffer=r,this._gltf.images)for(let o=0;o<this._gltf.images.length;o++){let l=this._gltf.images[o];l.name=l.name||"bufferView_"+l.bufferView.toString();const h=this._gltf.bufferViews[l.bufferView],c=this._gltf.buffers[h.buffer];let u=new Uint8Array(c.dbuffer,h.byteOffset,h.byteLength),d=new Blob([u],{type:l.mimeType}),f=new Br;await f.loadFromBlob(d),f.name=l.name,this._gltf.resources[l.name]=f}let i=await new bi().parse(this.initUrl,this._gltf,this._gltf.scene);return i?(this.data=i.rootNode,i.rootNode):null}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}parseHeader(e){let r=e.pos,a=new kc,i=new Uint32Array(e.buffer,r,3);return e.pos+=i.byteLength,a.magic=i[0],a.version=i[1],a.length=i[2],a}parseChunk(e){let r=e.pos,a=new Pc,i=new Uint32Array(e.buffer,r,2);r=e.pos+=i.byteLength,a.chunkLength=i[0],a.chunkType=i[1],a.chunkData=new Uint8Array(e.buffer,r,a.chunkLength);const o=new Uint8Array(a.chunkLength);for(let l=0;l<a.chunkLength;l++)o[l]=a.chunkData[l];return a.chunkData=o,e.pos+=a.chunkLength,a}}s(Hi,"format",ke.BIN);class Lc extends Ct{constructor(){super();let t=new _e("PBRLItShader","PBRLItShader");t.setShaderEntry("VertMain","FragMain"),t.passType=W.COLOR,this.addRenderPass(t);let e=t.shaderState;e.acceptShadow=!0,e.castShadow=!0,e.receiveEnv=!0,e.acceptGI=!0,e.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformColor("baseColor",new Y(.75,.75,.75,1)),this.setUniformColor("emissiveColor",new Y(0,0,0)),this.setUniformVector4("materialF0",new j(.04,.04,.04,1)),this.setUniformColor("specularColor",new Y(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",1),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new Y(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this.setUniformFloat("clearcoatIor",1.5),this.setUniformVector4("baseMapOffsetSize",new j(0,0,1,1)),this.setUniformVector4("normalMapOffsetSize",new j(0,0,1,1)),this.setUniformVector4("emissiveMapOffsetSize",new j(0,0,1,1)),this.setUniformVector4("roughnessMapOffsetSize",new j(0,0,1,1)),this.setUniformVector4("metallicMapOffsetSize",new j(0,0,1,1)),this.setUniformVector4("aoMapOffsetSize",new j(0,0,1,1)),this.baseMap=C.res.whiteTexture,this.normalMap=C.res.normalTexture,this.maskMap=C.res.maskTexture}get baseMap(){return this.getDefaultColorShader().getTexture("baseMap")}set baseMap(t){this.getDefaultColorShader().setTexture("baseMap",t)}get baseColor(){return this.getDefaultColorShader().getUniform("baseColor")}set baseColor(t){this.getDefaultColorShader().setUniformColor("baseColor",t)}get normalMap(){return this.getDefaultColorShader().getTexture("normalMap")}set normalMap(t){this.getDefaultColorShader().setTexture("normalMap",t)}get doubleSide(){return this.getDefaultColorShader().doubleSide}set doubleSide(t){this.getDefaultColorShader().doubleSide=t}get alphaCutoff(){return this.getDefaultColorShader().shaderState.alphaCutoff}set alphaCutoff(t){this.getDefaultColorShader().setDefine("USE_ALPHACUT",!0),this.getDefaultColorShader().shaderState.alphaCutoff=t,this.getDefaultColorShader().setUniform("alphaCutoff",t)}get emissiveColor(){return this.getDefaultColorShader().getUniform("emissiveColor")}set emissiveColor(t){this.getDefaultColorShader().setUniform("emissiveColor",t)}get emissiveIntensity(){return this.getDefaultColorShader().getUniform("emissiveIntensity")}set emissiveIntensity(t){this.getDefaultColorShader().setUniform("emissiveIntensity",t)}get transformUV1(){return this.getDefaultColorShader().uniforms.transformUV1.vector4}set transformUV1(t){this.getDefaultColorShader().setUniform("transformUV1",t)}get uvTransform_2(){return this.getDefaultColorShader().uniforms.transformUV2.vector4}set uvTransform_2(t){this.getDefaultColorShader().setUniform("transformUV2",t)}get depthWriteEnabled(){return this.getDefaultColorShader().shaderState.depthWriteEnabled}set depthWriteEnabled(t){this.getDefaultColorShader().shaderState.depthWriteEnabled=t}get materialF0(){return this.getDefaultColorShader().uniforms.materialF0.vector4}set materialF0(t){this.getDefaultColorShader().setUniform("materialF0",t)}get specularColor(){return this.getDefaultColorShader().uniforms.specularColor.color}set specularColor(t){this.getDefaultColorShader().setUniform("specularColor",t)}get roughness(){return this.getDefaultColorShader().uniforms.roughness.value}set roughness(t){this.getDefaultColorShader().setUniform("roughness",t)}get metallic(){return this.getDefaultColorShader().uniforms.metallic.value}set metallic(t){this.getDefaultColorShader().setUniform("metallic",t)}get ao(){return this.getDefaultColorShader().uniforms.ao.value}set ao(t){this.getDefaultColorShader().setUniform("ao",t)}get metallic_min(){return this.getDefaultColorShader().uniforms.metallic_min.value}set metallic_min(t){this.getDefaultColorShader().setUniform("metallic_min",t)}get metallic_max(){return this.getDefaultColorShader().uniforms.metallic_max.value}set metallic_max(t){this.getDefaultColorShader().setUniform("metallic_max",t)}get roughness_min(){return this.getDefaultColorShader().uniforms.roughness_min.value}set roughness_min(t){this.getDefaultColorShader().setUniform("roughness_min",t)}get roughness_max(){return this.getDefaultColorShader().uniforms.roughness_max.value}set roughness_max(t){this.getDefaultColorShader().setUniform("roughness_max",t)}get normalScale(){return this.getDefaultColorShader().uniforms.normalScale.value}set normalScale(t){this.getDefaultColorShader().setUniform("normalScale",t)}get maskMap(){return this.getDefaultColorShader().textures.maskMap}set maskMap(t){this.getDefaultColorShader().setDefine("USE_MR",!0),this.getDefaultColorShader().setTexture("maskMap",t)}set aoMap(t){t&&(this.getDefaultColorShader().setTexture("aoMap",t),t!=C.res.whiteTexture&&this.getDefaultColorShader().setDefine("USE_AOTEX",!0))}get aoMap(){return this.getDefaultColorShader().textures.aoMap}set clearCoatRoughnessMap(t){t&&(console.log("USE_CLEARCOAT_ROUGHNESS"),this.getDefaultColorShader().setTexture("clearCoatRoughnessMap",t),this.getDefaultColorShader().setDefine("USE_CLEARCOAT_ROUGHNESS",!0))}get clearCoatRoughnessMap(){return this.getDefaultColorShader().textures.clearCoatRoughnessMap}get brdfLUT(){return this.getDefaultColorShader().textures.brdfLUT}set brdfLUT(t){this.getDefaultColorShader().setTexture("brdfLUT",t),this.getDefaultColorShader().setTexture("brdflutMap",t)}get emissiveMap(){return this.getDefaultColorShader().textures.emissiveMap}set emissiveMap(t){this.getDefaultColorShader().setTexture("emissiveMap",t)}set envIntensity(t){this.getDefaultColorShader().setUniformFloat("envIntensity",t)}get envIntensity(){return this.getDefaultColorShader().uniforms.envIntensity.value}set ior(t){this.getDefaultColorShader().setUniformFloat("ior",t)}get ior(){return this.getDefaultColorShader().uniforms.ior.value}useCleanCoat(){this.getDefaultColorShader().setDefine("USE_CLEARCOAT",!0)}set clearcoatFactor(t){this.getDefaultColorShader().setUniformFloat("clearcoatFactor",t),this.useCleanCoat()}get clearcoatFactor(){return this.getDefaultColorShader().uniforms.clearcoatFactor.value}set clearcoatRoughnessFactor(t){this.getDefaultColorShader().setUniformFloat("clearcoatRoughnessFactor",t),this.useCleanCoat()}get clearcoatRoughnessFactor(){return this.getDefaultColorShader().uniforms.clearcoatRoughnessFactor.value}set clearcoatWeight(t){this.getDefaultColorShader().setUniformFloat("clearcoatWeight",t),this.useCleanCoat()}get clearcoatWeight(){return this.getDefaultColorShader().uniforms.clearcoatWeight.value}set clearcoatColor(t){this.getDefaultColorShader().setUniformColor("clearcoatColor",t),this.useCleanCoat()}get clearcoatColor(){return this.getDefaultColorShader().uniforms.clearcoatColor.color}}class Vr extends Fr{constructor(){super();let t=new Lc;this.shader=t}clone(){let t=new Vr,e=t.shader.getDefaultColorShader(),r=this.shader.getDefaultColorShader();return e.defineValue={...r.defineValue},e.setUniform("shadowBias",r.getUniform("shadowBias")),e.setUniform("baseColor",r.getUniform("baseColor")),e.setUniform("specularColor",r.getUniform("specularColor")),e.setUniform("emissiveColor",r.getUniform("emissiveColor")),e.setUniform("materialF0",r.getUniform("materialF0")),e.setUniform("envIntensity",r.getUniform("envIntensity")),e.setUniform("normalScale",r.getUniform("normalScale")),e.setUniform("roughness",r.getUniform("roughness")),e.setUniform("metallic",r.getUniform("metallic")),e.setUniform("ao",r.getUniform("ao")),e.setUniform("roughness_min",r.getUniform("roughness_min")),e.setUniform("roughness_max",r.getUniform("roughness_max")),e.setUniform("metallic_min",r.getUniform("metallic_min")),e.setUniform("metallic_max",r.getUniform("metallic_max")),e.setUniform("emissiveIntensity",r.getUniform("emissiveIntensity")),e.setUniform("alphaCutoff",r.getUniform("alphaCutoff")),e.setUniform("ior",r.getUniform("ior")),e.setUniform("clearcoatFactor",r.getUniform("clearcoatFactor")),e.setUniform("clearcoatRoughnessFactor",r.getUniform("clearcoatRoughnessFactor")),e.setUniform("clearcoatColor",r.getUniform("clearcoatColor")),e.setUniform("clearcoatWeight",r.getUniform("clearcoatWeight")),e.setUniform("clearcoatIor",r.getUniform("clearcoatIor")),e.setTexture("baseMap",r.getTexture("baseMap")),e.setTexture("normalMap",r.getTexture("normalMap")),e.setTexture("emissiveMap",r.getTexture("emissiveMap")),e.setTexture("aoMap",r.getTexture("aoMap")),e.setTexture("maskMap",r.getTexture("maskMap")),e.setTexture("empty",r.getTexture("empty")),e.setUniform("baseMapOffsetSize",r.getUniform("baseMapOffsetSize")),e.setUniform("normalMapOffsetSize",r.getUniform("normalMapOffsetSize")),e.setUniform("emissiveMapOffsetSize",r.getUniform("emissiveMapOffsetSize")),e.setUniform("roughnessMapOffsetSize",r.getUniform("roughnessMapOffsetSize")),e.setUniform("metallicMapOffsetSize",r.getUniform("metallicMapOffsetSize")),e.setUniform("aoMapOffsetSize",r.getUniform("aoMapOffsetSize")),t}set baseMap(t){this.shader.setTexture("baseMap",t)}get baseMap(){return this.shader.getTexture("baseMap")}set maskMap(t){this.shader.setTexture("maskMap",t)}get maskMap(){return this.shader.getTexture("maskMap")}set normalMap(t){this.shader.setTexture("normalMap",t)}get normalMap(){return this.shader.getTexture("normalMap")}set emissiveMap(t){this.shader.setTexture("emissiveMap",t)}get emissiveMap(){return this.shader.getTexture("emissiveMap")}set aoMap(t){this.shader.setTexture("aoMap",t)}get aoMap(){return this.shader.getTexture("aoMap")}set clearCoatRoughnessMap(t){this.shader.setTexture("clearCoatRoughnessMap",t),this.shader.setDefine("USE_CLEARCOAT",!0),this.shader.setDefine("USE_CLEARCOAT_ROUGHNESS",!0)}get clearCoatRoughnessMap(){return this.shader.getTexture("clearCoatRoughnessMap")}set clearcoatColor(t){this.shader.setUniformColor("clearcoatColor",t),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatColor(){return this.shader.getUniformColor("clearcoatColor")}set clearcoatWeight(t){this.shader.setUniformFloat("clearcoatWeight",t),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatWeight(){return this.shader.getUniformFloat("clearcoatWeight")}set clearcoatFactor(t){this.shader.setUniformFloat("clearcoatFactor",t),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatFactor(){return this.shader.getUniformFloat("clearcoatFactor")}set clearcoatRoughnessFactor(t){this.shader.setUniformFloat("clearcoatRoughnessFactor",t),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatRoughnessFactor(){return this.shader.getUniformFloat("clearcoatRoughnessFactor")}set ior(t){this.shader.setUniformFloat("clearcoatIor",t)}get ior(){return this.shader.getUniformFloat("clearcoatIor")}set alphaCutoff(t){this.shader.setUniform("alphaCutoff",t)}get alphaCutoff(){return this.shader.getUniform("alphaCutoff")}set baseColor(t){this.shader.setUniformColor("baseColor",t)}get baseColor(){return this.shader.getUniformColor("baseColor")}get roughness(){return this.shader.getUniformFloat("roughness")}set roughness(t){this.shader.setUniformFloat("roughness",t)}get metallic(){return this.shader.getUniformFloat("metallic")}set metallic(t){this.shader.setUniformFloat("metallic",t)}get emissiveColor(){return this.shader.getUniformColor("emissiveColor")}set emissiveColor(t){this.shader.setUniformColor("emissiveColor",t)}get emissiveIntensity(){return this.shader.getUniformFloat("emissiveIntensity")}set emissiveIntensity(t){this.shader.setUniformFloat("emissiveIntensity",t)}get ao(){return this.shader.getUniform("ao")}set ao(t){this.shader.setUniform("ao",t)}}class dn extends at{constructor(){super(...arguments);s(this,"textData","");s(this,"source_vertices");s(this,"source_normals");s(this,"source_tangents");s(this,"source_textureCoords");s(this,"matLibs");s(this,"geometrys");s(this,"activeGeo");s(this,"facesMaterialsIndex");s(this,"mtl");s(this,"mtlUrl")}async parseString(e){return this.source_vertices=[],this.source_normals=[],this.source_tangents=[],this.source_textureCoords=[],this.matLibs={},this.geometrys={},this.textData=e,await Promise.all([this.parserOBJ(),this.loadMTL()]),this.parser_mesh(),"null"}applyVector2(e,r,a){r[e]&&r[e].length>0?(a.push(r[e][0]),a.push(r[e][1])):(a.push(0),a.push(0))}applyVector3(e,r,a){a.push(r[e][0]),a.push(r[e][1]),a.push(r[e][2])}applyVector4(e,r,a){a.push(r[e][0]),a.push(r[e][1]),a.push(r[e][2]),a.push(r[e][3])}async loadMTL(){let e=await new st().loadTxt(this.baseUrl+this.mtlUrl),r=e.data,a,i=r.split(`\r
`);for(let h=0;h<i.length;h++){let c=i[h];var o=c.indexOf("#");o!=-1&&(c=c.substring(0,o)),c=c.trim();var l=c.split(/\s+/);l[0]==="newmtl"?(a={name:l[1]},this.matLibs[l[1]]=a):l[0].indexOf("map_")!=-1?(a[l[0]]=l[1],a.textures||(a.textures=[l[l.length-1]]),a.textures.push(l[l.length-1])):l.length==2?a[l[0]]=Number(l[1]):l.length==3?a[l[0]]=[Number(l[1]),Number(l[2])]:l.length==4&&(a[l[0]]=[Number(l[1]),Number(l[2]),Number(l[3])])}for(const h in this.matLibs){const c=this.matLibs[h];if(c.textures&&c.textures.length>0)for(let u=0;u<c.textures.length;u++){const d=et.normalizePath(this.baseUrl+c.textures[u]);await C.res.loadTexture(d)}}return e=null,!0}async load_textures(){}parserLine(e){var r=e.indexOf("#");if(r!=-1){if(e.indexOf("# object")!=-1){var a=e.split(/\s+/);let A=a[1],p=a[2];this.activeGeo={type:A,name:p[1],source_mat:"",source_faces:[]},this.geometrys[p]=this.activeGeo}e=e.substring(0,r)}e=e.trim();var a=e.split(/\s+/);if(a[0]==="v"){var i=[Number(a[1]),Number(a[2]),Number(a[3]),a[4]?1:Number(a[4])];this.source_vertices.push(i)}else if(a[0]==="vt"){var o=[Number(a[1]),Number(a[2]),a[3]?1:Number(a[3])];this.source_textureCoords.push(o)}else if(a[0]==="vn"){var l=[Number(a[1]),Number(a[2]),Number(a[3])];this.source_normals.push(l)}else if(a[0]==="f"){for(var h={indices:[],texture:[],normal:[]},c=1;c<a.length;++c){var u=a[c].indexOf("//"),d=a[c].split(/\W+/);u>0?(h.indices.push(d[0]),h.normal.push(d[1])):d.length===1?h.indices.push(d[0]):d.length===2?(h.indices.push(d[0]),h.texture.push(d[1])):d.length===3&&(h.indices.push(d[0]),h.texture.push(d[1]),h.normal.push(d[2]))}this.activeGeo.source_faces.push(h)}else a[0]==="usemtl"?this.activeGeo.source_mat=a[1]:a[0]==="mtllib"&&(this.mtlUrl=a[1])}async parserOBJ(){let e=this.textData.split(`\r
`);for(let r=0;r<e.length;r++){const a=e[r];this.parserLine(a)}return this.textData="",!0}async parser_mesh(){let e=new ie;for(const r in this.geometrys){const a=this.geometrys[r];a.vertex_arr=[],a.normal_arr=[],a.uv_arr=[],a.indeice_arr=[];let i=0;for(let d=0;d<a.source_faces.length;d++){const f=a.source_faces[d];let A=parseInt(f.indices[0])-1,p=parseInt(f.indices[1])-1,B=parseInt(f.indices[2])-1,F=parseInt(f.normal[0])-1,U=parseInt(f.normal[1])-1,Q=parseInt(f.normal[2])-1,y=parseInt(f.texture[0])-1,b=parseInt(f.texture[1])-1,x=parseInt(f.texture[2])-1;if(this.applyVector3(A,this.source_vertices,a.vertex_arr),this.applyVector3(F,this.source_normals,a.normal_arr),this.applyVector2(y,this.source_textureCoords,a.uv_arr),a.indeice_arr[i]=i++,this.applyVector3(p,this.source_vertices,a.vertex_arr),this.applyVector3(U,this.source_normals,a.normal_arr),this.applyVector2(b,this.source_textureCoords,a.uv_arr),a.indeice_arr[i]=i++,this.applyVector3(B,this.source_vertices,a.vertex_arr),this.applyVector3(Q,this.source_normals,a.normal_arr),this.applyVector2(x,this.source_textureCoords,a.uv_arr),a.indeice_arr[i]=i++,f.indices.length>3){let w=parseInt(f.indices[3])-1,D=parseInt(f.normal[3])-1,O=parseInt(f.texture[3])-1;this.applyVector3(A,this.source_vertices,a.vertex_arr),this.applyVector3(F,this.source_normals,a.normal_arr),this.applyVector2(y,this.source_textureCoords,a.uv_arr),a.indeice_arr[i]=i++,this.applyVector3(B,this.source_vertices,a.vertex_arr),this.applyVector3(Q,this.source_normals,a.normal_arr),this.applyVector2(x,this.source_textureCoords,a.uv_arr),a.indeice_arr[i]=i++,this.applyVector3(w,this.source_vertices,a.vertex_arr),this.applyVector3(D,this.source_normals,a.normal_arr),this.applyVector2(O,this.source_textureCoords,a.uv_arr),a.indeice_arr[i]=i++}}let o=new ar;o.setIndices(new Uint32Array(a.indeice_arr)),o.setAttribute(k.position,new Float32Array(a.vertex_arr)),o.setAttribute(k.normal,new Float32Array(a.normal_arr)),o.setAttribute(k.uv,new Float32Array(a.uv_arr)),o.setAttribute(k.TEXCOORD_1,new Float32Array(a.uv_arr)),o.addSubGeometry({indexStart:0,indexCount:a.indeice_arr.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0});let l=new Vr,h=this.matLibs[a.source_mat];l.baseMap=C.res.getTexture(et.normalizePath(this.baseUrl+h.map_Kd));let c=new ie,u=c.addComponent(Be);u.geometry=o,u.material=l,e.addChild(c)}this.data=e}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}s(dn,"format",ke.TEXT);let Oc=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        var srcId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x * 2u), i32(GlobalInvocationID.y * 2u));
        textureStore(outputTexture, dstId, textureLoad(inputTexture, srcId, 0));
    }
`,Gc=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    fn repeat_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = max + id;
        }
        if (id >= max) {
            ret = id - max;
        }
        return ret;
    }

    fn clamp_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = 0;
        }
        if (id >= max) {
            ret = max - 1;
        }
        return ret;
    }

    fn blur(idx: u32) -> vec4 < f32 > {
        var id: vec2<i32>;
        id.y = i32(idx) / size.srcWidth;
        id.x = i32(idx) - i32(id.y) * size.srcWidth;
        var _BlurSpread: i32 = 1;
        var result = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        let g: array < f32, 3u > = array<f32, 3u > (0.4026, 0.2442, 0.0545);
        var uv: vec2<i32>;
        for(var h: i32 = 0; h< 5; h = h + 1) {
        let offsetU: i32 = (h - 2) * _BlurSpread;
        uv.x = id.x + offsetU;
        uv.x = clamp_i32(uv.x, size.srcWidth);
        for (var v: i32 = 0; v < 5; v = v + 1) {
            let offsetV: i32 = (v - 2) * _BlurSpread;
            uv.y = id.y + offsetV;
            uv.y = clamp(uv.y, 0, size.srcHeight);
            let weightU: i32 = abs(h - 2);
            let weightV: i32 = abs(v - 2);
            let resultWeight: f32 = g[weightU] * g[weightV];
            var colorf32: vec4<f32> = textureLoad(inputTexture, uv, 0);
            let sampleColor: vec4<f32> = vec4<f32>(colorf32 * resultWeight);
            result = result + sampleColor;
        }
    }

    return result;
    }

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        let srcIdx = i32(uv.y) * size.srcWidth + i32(uv.x);
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        textureStore(outputTexture, dstId, blur(u32(srcIdx)));
    }
`;class Wc{static blurImageFromTexture(t,e,r,a){const i=R.device;let o=a?Gc:Oc;const l=i.createComputePipeline({layout:"auto",compute:{module:i.createShaderModule({code:o}),entryPoint:"main"}}),h=4*4,c=i.createBuffer({size:h,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});i.queue.writeBuffer(c,0,new Uint32Array([t.width,t.height,e,r]));const u=i.createTexture({size:[e,r,1],mipLevelCount:1,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,label:"blurImageFromTexture"});let d=[{binding:0,resource:{buffer:c,size:4*4}},{binding:1,resource:t.gpuTexture.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})},{binding:2,resource:u.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})}];const f=i.createBindGroup({layout:l.getBindGroupLayout(0),entries:d}),A=S.beginCommandEncoder(),p=A.beginComputePass();return p.setPipeline(l),p.setBindGroup(0,f),p.dispatchWorkgroups(Math.floor(e/8),Math.floor(r/8)),p.end(),S.endCommandEncoder(A),c.destroy(),u}}class Ki extends rt{constructor(){super(4,4);s(this,"width",4);s(this,"height",4);s(this,"depthOrArrayLayers",6);s(this,"visibility",GPUShaderStage.FRAGMENT);s(this,"textureBindingLayout",{viewDimension:"cube",multisampled:!1});s(this,"samplerBindingLayout",{type:"filtering"});this.addressModeU=Bt.clamp_to_edge,this.addressModeV=Bt.clamp_to_edge,this.addressModeW=Bt.clamp_to_edge,this.magFilter=this.minFilter="linear",this.mipmapFilter="linear",this.visibility=GPUShaderStage.FRAGMENT}createTextureDescriptor(e,r,a,i,o=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,l=1){this.width=e,this.height=r,this.format=i,this.usage=o,this.textureDescriptor={size:{width:e,height:r,depthOrArrayLayers:6},mipLevelCount:a,format:i,usage:o,dimension:"2d"},l>1?this.viewDescriptor={dimension:"cube-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension}}}const yr=class yr{static createFace(t,e,r,a){const i=R.device;this.pipeline==null&&(this.pipeline=i.createComputePipeline({layout:"auto",compute:{module:i.createShaderModule({code:yr.createCube}),entryPoint:"main"}}));const o=this.pipeline,l=4*4;this.configBuffer||(this.configBuffer=i.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),i.queue.writeBuffer(this.configBuffer,0,new Uint32Array([t,0,0,0])),this.blurSettingBuffer||(this.blurSettingBuffer=i.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),i.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([0,0,0,0]));let h=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:r.getGPUView()},{binding:2,resource:a.getGPUView()}];const c=i.createBindGroup({layout:o.getBindGroupLayout(0),entries:h}),u=S.beginCommandEncoder(),d=u.beginComputePass();d.setPipeline(o),d.setBindGroup(0,c),d.dispatchWorkgroups(e/8,e/8),d.end(),S.endCommandEncoder(u)}};s(yr,"createCube",`

struct SettingUniform {
  faceIndex : i32,
  srcHeight : i32,
  dstWidth : i32,
  dstHeight : i32
};

@group(0) @binding(0) var<uniform> settingUniform : SettingUniform;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let coord = vec2<i32>(GlobalInvocationID.xy);
  
  let outTexSize = textureDimensions(outTex).xy;
  let outTexel = 1.0 / vec2<f32>(outTexSize - 1);
  
  let uv_0 = vec2<f32>(coord) * outTexel;
  var oc = samplePixel(settingUniform.faceIndex, uv_0);
  textureStore(outTex, coord, oc);
}

fn samplePixel(face:i32, uv01:vec2<f32>) -> vec4<f32> {
    let rectangle_v2_f32 = round(vec2<f32>(0.25, 0.33333) * vec2<f32>(textureDimensions(inputTex).xy));
    let rectangle = vec2<i32>(rectangle_v2_f32);
    
    var offsetIndex = vec2<i32>(0);
    if(face == 0){
        offsetIndex.x = 2;
        offsetIndex.y = 1;
    }else if(face == 1){
        offsetIndex.x = 0;
        offsetIndex.y = 1;
    }else if(face == 2){
        offsetIndex.x = 1;
        offsetIndex.y = 0;
    }else if(face == 3){
        offsetIndex.x = 1;
        offsetIndex.y = 2;
    }else if(face == 4){
        offsetIndex.x = 1;
        offsetIndex.y = 1;
    }else if(face == 5){
        offsetIndex.x = 3;
        offsetIndex.y = 1;
    }
    
    let coordOffset = rectangle * offsetIndex;
    let coordIndex = vec2<i32>(vec2<f32>(rectangle - 1) * uv01);
    var oc = textureLoad(inputTex, coordOffset + coordIndex, 0);
    return oc;
}
`),s(yr,"configBuffer",null),s(yr,"blurSettingBuffer",null),s(yr,"pipeline");let _i=yr;class ws extends Ki{constructor(){super();s(this,"_images");s(this,"_url");this.useMipmap=!0}generateImages(e){let r=R.device;this.width=this.height=32,"width"in e[0]&&(this.width=this.height=e[0].width);let a=Math.min(this.width,this.height);for(this.mipmapCount=1;a>16;)a/=2,this.mipmapCount++;this.textureBindingLayout.viewDimension="cube",this.samplerBindingLayout.type="filtering",this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format),this.textureDescriptor.size={width:this.width,height:this.height,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuTexture=this.getGPUTexture();let i=[],o=i,l=this.width,h=this.height;if(e[0]instanceof rt){for(let c=0;c<6;c++){let u=e[c];i[c]=u.getGPUTexture()}this.uploadMipmapGPUTexture(0,this.width,this.width,i)}else{this.uploadBaseImages(this.width,e);for(let c=0;c<6;c++){let u=new Br(!1);u.format=this.format,u.source=e[c],i[c]=u.getGPUTexture()}}for(let c=1;c<this.mipmapCount;c++){o=i,i=[];let u={width:l,height:h,gpuTexture:null};l=l/2,h=h/2;for(let d=0;d<6;d++)u.gpuTexture=o[d],i[d]=Wc.blurImageFromTexture(u,l,h,!1);this.uploadMipmapGPUTexture(c,l,h,i)}this.gpuSampler=r.createSampler(this)}uploadBaseImages(e,r){let a=R.device;const i=S.beginCommandEncoder();for(let o=0;o<6;o++)a.queue.copyExternalImageToTexture({source:r[o]},{texture:this.gpuTexture,mipLevel:0,origin:{x:0,y:0,z:o}},{width:e,height:e,depthOrArrayLayers:1});S.endCommandEncoder(i)}uploadMipmapGPUTexture(e,r,a,i){const o=S.beginCommandEncoder();for(let l=0;l<6;l++)o.copyTextureToTexture({texture:i[l],mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.gpuTexture,mipLevel:e,origin:{x:0,y:0,z:l}},{width:r,height:a,depthOrArrayLayers:1});S.endCommandEncoder(o)}get images(){return this._images}set images(e){if(this._images=e,this._images[0]instanceof HTMLImageElement){let r=function(l,h){h.decode().then(async()=>{a[l]=await createImageBitmap(h),i--,i==0&&o.generateImages(a)})},a=[],i=6,o=this;for(let l=0;l<6;l++)r(l,this._images[l])}else(this._images instanceof HTMLCanvasElement||this._images instanceof ImageBitmap)&&this.generateImages(this._images)}async load(e){this._url=e;let r=6,a=[];this.format=H.rgba8unorm;let i=this;async function o(l,h){const c=document.createElement("img");if(c.src=h,c.setAttribute("crossOrigin",""),await c.decode(),a[l]=await createImageBitmap(c),r--,r==0)return i.generateImages(a),!0}for(let l=0;l<6;l++)await o(l,e[l]);return!0}async loadStd(e){this._url=e,this.format=H.rgba8unorm;const r=document.createElement("img");r.src=e,r.setAttribute("crossOrigin",""),await r.decode();let a=new Br(!1);a.name=et.getURLName(e),a.format="rgba8unorm",a.source=await createImageBitmap(r);let i=Math.round(Math.log2(a.width/4));i=Math.pow(2,i),this.width=this.height=i;let o=[];for(let l=0;l<6;l++){let h=new _t(i,i,this.format,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING);h.name="face "+l,o.push(h),_i.createFace(l,this.width,a,h)}return this.generateImages(o),!0}}var Jc=(n=>(n[n.Left=0]="Left",n[n.Right=1]="Right",n[n.Bottom=2]="Bottom",n[n.Top=3]="Top",n[n.Back=4]="Back",n[n.Front=5]="Front",n))(Jc||{});class fn{static getRotationToFace(t){let e=X.identity().clone(),r=new g,a=new Z().identity(),i=new g;switch(t){case 3:r.set(0,-1,0),i.set(0,0,-1);break;case 2:r.set(0,1,0),i.set(0,0,1);break;case 1:r.set(1,0,0),i.set(0,1,0);break;case 0:r.set(-1,0,0),i.set(0,1,0);break;case 4:r.set(0,0,-1),i.set(0,1,0);break;case 5:return X.identity()}return a.lookAt(new g,r,i),e.setFromRotationMatrix(a),e}}let zc=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
  @group(0) @binding(2) var inputTexSampler : sampler;
  @group(0) @binding(3) var inputTex : texture_2d<f32>;

  @group(1) @binding(0) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;

  fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
      var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
      //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
      uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
      uv = uv + vec2<f32>(0.5);
      uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
      return uv;
  }


  fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
      let x:f32 = position.x;
      let y:f32 = position.y;
      let z:f32 = position.z;

      let qx:f32 = q.x;
      let qy:f32 = q.y;
      let qz:f32 = q.z;
      let qw:f32 = q.w;

      let ix:f32 = qw * x + qy * z - qz * y;
      let iy:f32 = qw * y + qz * x - qx * z;
      let iz:f32 = qw * z + qx * y - qy * x;
      let iw:f32 = -qx * x - qy * y - qz * z;

      var ret: vec3<f32>;
      ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

      return ret;
  }

  fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
      var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
      var halfSize:f32 = f32(size.dstWidth / 2) - 0.5;
      var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
      worldDirection = normalize(worldDirection);
      worldDirection = applyQuaternion(worldDirection, quaternion);
      return worldDirection;
  }

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let coord = vec2<i32>(GlobalInvocationID.xy);
    let quaternion = faceRotation[GlobalInvocationID.z];
    var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
    let uv_f32:vec2<f32> = SampleSphericalMap(worldDirection);
    let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
    textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
  }
`,Zc=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage, read> tex_in: array<vec4<f32>>;
  @group(0) @binding(2) var outputBuffer : texture_storage_2d<rgba16float, write>;

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let fragCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
    var oc:vec4<f32> = tex_in[fragCoord.y * size.srcWidth + fragCoord.x] / 256.0;
    var e = pow(2.0, oc.w * 255.0 - 128.0);
    oc = oc * e;
    oc = scaleByThreshold(oc, 40.0);
    textureStore(outputBuffer, fragCoord , vec4<f32>(oc.xyz, 1.0) );
  }

  fn scaleByThreshold(color:vec4<f32>, threshold:f32) -> vec4<f32>{
    var oc = color;
    let brightness = length(vec3<f32>(oc.xyz));
    var scale = brightness / threshold;
    if(scale > 1.0){
        scale = 1.0 / pow(scale, 0.7);
        oc = oc * scale;
    }
    oc.a = 1.0;
    return oc;
  }
`;const Te=class Te{static convertRGBE2RGBA(t,e){const r=R.device,a=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:Zc}),entryPoint:"main"}}),i=r.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});r.queue.writeBuffer(i,0,new Uint32Array([t.width,t.height,t.width,t.height]));const o=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});r.queue.writeBuffer(o,0,e);let l=[{binding:0,resource:{buffer:i,size:4*4}},{binding:1,resource:{buffer:o,size:e.byteLength}},{binding:2,resource:t.getGPUView()}];const h=r.createBindGroup({layout:a.getBindGroupLayout(0),entries:l}),c=S.beginCommandEncoder(),u=c.beginComputePass();u.setPipeline(a),u.setBindGroup(0,h),u.dispatchWorkgroups(Math.floor(t.width/8),Math.floor(t.height/8)),u.end(),S.endCommandEncoder(c),i.destroy()}static makeTextureCube(t,e,r){const a=R.device;Te.makeFaceTexturePipeline||(Te.makeFaceTexturePipeline=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:zc}),entryPoint:"main"}}));const i=Te.makeFaceTexturePipeline,o=4*4;Te.configBuffer||(Te.configBuffer=a.createBuffer({size:o,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(Te.configBuffer,0,new Uint32Array([t.width,t.height,e,e]));const l=4*6;if(!Te.quaternionBuffer){Te.quaternionBuffer=a.createBuffer({size:l*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let p=new Float32Array(4*6);for(let B=0;B<6;B++){let F=fn.getRotationToFace(B);p[B*4+0]=F.x,p[B*4+1]=F.y,p[B*4+2]=F.z,p[B*4+3]=F.w}a.queue.writeBuffer(Te.quaternionBuffer,0,p)}let h=[{binding:0,resource:{buffer:Te.configBuffer,size:4*4}},{binding:1,resource:{buffer:Te.quaternionBuffer,size:l*4}},{binding:2,resource:t.gpuSampler},{binding:3,resource:t.getGPUView()}],c=[{binding:0,resource:r}];const u=a.createBindGroup({layout:i.getBindGroupLayout(0),entries:h}),d=a.createBindGroup({layout:i.getBindGroupLayout(1),entries:c}),f=S.beginCommandEncoder(),A=f.beginComputePass();A.setPipeline(i),A.setBindGroup(0,u),A.setBindGroup(1,d),A.dispatchWorkgroups(e/8,e/8,6),A.end(),S.endCommandEncoder(f)}};s(Te,"makeFaceTexturePipeline"),s(Te,"configBuffer"),s(Te,"quaternionBuffer");let Ba=Te;class An extends rt{constructor(){super(32,32,null),this.isHDRTexture=!0}create(t=32,e=32,r=null,a=!0){this.width=t,this.height=e;let i=R.device;const o=t*4*2;let l=r;this.format=H.rgba16float,this.useMipmap=a,this.updateTextureDescription(),this.updateGPUTexture();const h=i.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});i.queue.writeBuffer(h,0,l);const c=S.beginCommandEncoder();return c.copyBufferToTexture({buffer:h,bytesPerRow:o},{texture:this.getGPUTexture()},{width:t,height:e,depthOrArrayLayers:1}),S.endCommandEncoder(c),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),this.gpuSampler=i.createSampler(this),this}async load(t,e){return(await new st().load(t,pn,e)).getHDRTexture()}}const gn=new Float32Array(1),Xc=new Int32Array(gn.buffer);let Ia=function(n){gn[0]=n;const t=Xc[0];let e=t>>16&32768,r=t>>12&2047;const a=t>>23&255;return a<103?e:a>142?(e|=31744,e|=(a==255?1:0)&&t&8388607,e):a<114?(r|=2048,e|=(r>>114-a)+(r>>113-a&1),e):(e|=a-112<<10|r>>1,e+=r&1,e)};var Yc=(n=>(n[n.RGBE_RETURN_FAILURE=-1]="RGBE_RETURN_FAILURE",n[n.rgbe_read_error=1]="rgbe_read_error",n[n.rgbe_write_error=2]="rgbe_write_error",n[n.rgbe_format_error=3]="rgbe_format_error",n[n.rgbe_memory_error=4]="rgbe_memory_error",n))(Yc||{});class Ds{constructor(){s(this,"valid");s(this,"string");s(this,"comments");s(this,"programtype");s(this,"format");s(this,"gamma");s(this,"exposure");s(this,"width");s(this,"height")}}class pn extends at{constructor(){super(...arguments);s(this,"_rgbeArray");s(this,"_width");s(this,"_height");s(this,"_RGBE_RETURN_FAILURE",-1);s(this,"_parserType",H.rgba8uint)}parseBuffer(e){let r,a=new Uint8Array(e);a.pos=0;const i=this.paserHeader(a);if(i instanceof Ds){const o=this._width=i.width,l=this._height=i.height;let h=this.parserPixel(a.subarray(a.pos),o,l);if(h instanceof Uint8Array)return this._rgbeArray=h,this._parserType,this.data=r,r}return null}verification(){if(this.data&&this.data instanceof rt||this._rgbeArray)return!0;throw new Error("Method not implemented.")}getTexture(){return this.data}getCubeTexture(){let e=this._width/4;return new Ti().createFromHDRData(e,{width:this._width,height:this._height,array:this._rgbeArray})}getHDRTexture(){return new An().create(this._width,this._height,this._rgbeArray)}parseError(e,r){switch(e){case 1:console.error("Read Error: "+(r||""));break;case 2:console.error("Write Error: "+(r||""));break;case 3:console.error("Bad File Format: "+(r||""));break;default:case 4:console.error("Error: "+(r||""))}return-1}parserBlock(e,r,a){r=r||1024;let i=e.pos,o=-1,l=0,h="",c=String.fromCharCode.apply(null,new Uint16Array(e.subarray(i,i+128)));const u=`
`;for(;0>(o=c.indexOf(u))&&l<r&&i<e.byteLength;)h+=c,l+=c.length,i+=128,c+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(i,i+128)));return-1<o?(a!==!1&&(e.pos+=l+o+1),h+c.slice(0,o)):!1}paserHeader(e){const r=/^#\?(\S+)/,a=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,o=/^\s*FORMAT=(\S+)\s*$/,l=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,h=new Ds;let c,u;if(e.pos>=e.byteLength||!(c=this.parserBlock(e)))return this.parseError(1,"no header found");if(!(u=c.match(r)))return this.parseError(3,"bad initial token");const d=1,f=2,A=4;for(h.valid|=d,h.programtype=u[1],h.string+=c+`
`;c=this.parserBlock(e),c!==!1;){if(h.string+=c+`
`,c.charAt(0)==="#"){h.comments+=c+`
`;continue}if((u=c.match(a))&&(h.gamma=Math.floor(parseFloat(u[1])*10)/10),(u=c.match(i))&&(h.exposure=Math.floor(parseFloat(u[1])*10)/10),(u=c.match(o))&&(h.valid|=f,h.format=u[1]),(u=c.match(l))&&(h.valid|=A,h.height=parseInt(u[1],10),h.width=parseInt(u[2],10)),h.valid&f&&h.valid&A)break}return h.valid&f?h.valid&A?h:(this.parseError(3,"missing image size specifier"),null):(this.parseError(3,"missing format specifier"),null)}parserPixel(e,r,a){const i=r;if(i<8||i>32767||e[0]!==2||e[1]!==2||e[2]&128)return new Uint8Array(e);if(i!==(e[2]<<8|e[3]))return this.parseError(3,"wrong scanline width");const o=new Uint8Array(4*r*a);if(!o.length)return this.parseError(4,"unable to allocate buffer space");let l=0,h=0;const c=4*i,u=new Uint8Array(4),d=new Uint8Array(c);let f=a;for(;f>0&&h<e.byteLength;){if(h+4>e.byteLength)return this.parseError(1,"");if(u[0]=e[h++],u[1]=e[h++],u[2]=e[h++],u[3]=e[h++],u[0]!=2||u[1]!=2||(u[2]<<8|u[3])!=i)return this.parseError(3,"bad rgbe scanline format");let A=0,p;for(;A<c&&h<e.byteLength;){p=e[h++];const F=p>128;if(F&&(p-=128),p===0||A+p>c)return this.parseError(3,"bad scanline data");if(F){const U=e[h++];for(let Q=0;Q<p;Q++)d[A++]=U}else d.set(e.subarray(h,h+p),A),A+=p,h+=p}const B=i;for(let F=0;F<B;F++){let U=0;o[l]=d[F+U],U+=i,o[l+1]=d[F+U],U+=i,o[l+2]=d[F+U],U+=i,o[l+3]=d[F+U],l+=4}f--}return o}rbgeToFloat(e,r,a,i){const o=e[r+3],l=Math.pow(2,o-128)/255;a[i+0]=e[r+0]*l,a[i+1]=e[r+1]*l,a[i+2]=e[r+2]*l,a[i+3]=1}rbgeToHalfFloat(e,r,a,i){const o=e[r+3],l=Math.pow(2,o-128)/255;a[i+0]=Ia(e[r+0]*l),a[i+1]=Ia(e[r+1]*l),a[i+2]=Ia(e[r+2]*l),a[i+3]=Ia(1)}}let Hc=`
    struct ImageSize {
        srcWidth : i32,
        srcHeight : i32,
        dstWidth : i32,
        dstHeight : i32
    };
    
    @group(0) @binding(0) var<uniform> size : ImageSize;
    @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
    @group(0) @binding(2) var inputTexSampler : sampler;
    @group(0) @binding(3) var inputTex : texture_2d<f32>;
    
    @group(1) @binding(0) var<uniform> blurSetting : vec4<f32>;
    @group(1) @binding(1) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;
    
    var<private> PI: f32 = 3.14159265359;
    
    fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
        let x:f32 = position.x;
        let y:f32 = position.y;
        let z:f32 = position.z;
    
        let qx:f32 = q.x;
        let qy:f32 = q.y;
        let qz:f32 = q.z;
        let qw:f32 = q.w;
    
        let ix:f32 = qw * x + qy * z - qz * y;
        let iy:f32 = qw * y + qz * x - qx * z;
        let iz:f32 = qw * z + qx * y - qy * x;
        let iw:f32 = -qx * x - qy * y - qz * z;
    
        var ret: vec3<f32>;
        ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    
        return ret;
    }
    
    fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
        var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
        var halfSize:f32 = f32(size.dstWidth / 2);
        var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
        worldDirection = normalize(worldDirection);
        worldDirection = applyQuaternion(worldDirection, quaternion);
        return worldDirection;
    }
    
    fn VanDerCorpus(n0:u32, base0:u32) -> f32
    {
        var n = n0;
        var base = base0;
        var invBase:f32 = 1.0 / f32(base);
        var denom:f32   = 1.0;
        var result:f32  = 0.0;
    
        for(var i:u32 = 0u; i < 32u; i = i + 1u)
        {
            if(n > 0u)
            {
                denom   = f32(n) % 2.0;
                result = result + denom * invBase;
                invBase = invBase / 2.0;
                n       = u32(f32(n) / 2.0);
            }
        }
    
        return result;
    }
    
    fn HammersleyNoBitOps(i:u32, N:u32) -> vec2<f32>
    {
        return vec2(f32(i)/f32(N), VanDerCorpus(i, 2u));
    }
    
    fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
    {
        // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
        var bits = (i << 16u) | (i >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        var rdi = f32(bits) * 2.3283064365386963e-10;
        return vec2<f32>(f32(i) /f32(N), rdi);
    }
    
    fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
    {
        var a = roughness*roughness;
    
        var phi = 2.0 * PI * Xi.x;
        var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
        var sinTheta = sqrt(1.0 - cosTheta*cosTheta);
    
        // from spherical coordinates to cartesian coordinates
        var H:vec3<f32>;
        H.x = cos(phi) * sinTheta;
        H.y = sin(phi) * sinTheta;
        H.z = cosTheta;
    
        // from tangent-space vector to world-space sample vector
        var up:vec3<f32>;
        if(abs(N.z) < 0.999)
        {
            up = vec3<f32>(0.0, 0.0, 1.0);
        }
        else
        {
            up = vec3<f32>(1.0, 0.0, 0.0);
        }
        var tangent:vec3<f32>  = normalize(cross(up, N));
        var bitangent:vec3<f32> = cross(N, tangent);
        var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
        return normalize(sampleVec);
    }
    
    fn multiSample(normal:vec3<f32>, roughness:f32) -> vec4<f32>
    {
        var N: vec3<f32> = normalize(normal);
        var R: vec3<f32> = N;
        var V: vec3<f32> = R;
    
        let SAMPLE_COUNT:u32 = 1024u;
        var totalWeight:f32 = 0.0;
        var prefilteredColor:vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
        for(var i:u32 = 0u; i < SAMPLE_COUNT; i = i + 1u)
        {
            var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
            var H :vec3<f32> = ImportanceSampleGGX(Xi, N, roughness);
            var L :vec3<f32> = normalize(2.0 * dot(V, H) * H - V);
    
            var NdotL:f32 = max(dot(N, L), 0.0);
            if(NdotL > 0.0)
            {
                var att = 1.0 ;//( f32(SAMPLE_COUNT - i) / f32(SAMPLE_COUNT)) ;
    
                prefilteredColor = prefilteredColor + sampleColor(L).rgb * NdotL;
                prefilteredColor = prefilteredColor * att ;
                totalWeight      = totalWeight + NdotL;
            }
        }
        prefilteredColor = prefilteredColor / totalWeight;
    
        return vec4<f32>(prefilteredColor, 1.0);
    }
    
    fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
        var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
        //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
        uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
        uv = uv + vec2<f32>(0.5);
        uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
        return uv;
    }
    
    fn sampleColor(d:vec3<f32>) -> vec4<f32>
    {
        let uv_f32:vec2<f32> = SampleSphericalMap(d);
        let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
        //let dir = vec3<f32>(-d.x, -d.y, d.z);
        //var oc:vec4<f32> = textureSampleLevel(cubeMap, cubeMapSampler, dir, 0.0);
        return oc;
    }
    
    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let coord = vec2<i32>(GlobalInvocationID.xy);
        let quaternion = faceRotation[GlobalInvocationID.z];
        var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
        var oc:vec4<f32> = multiSample(worldDirection, blurSetting.x);
        textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
    }

`;class la{static importantSample(t,e,r,a){const i=R.device;this.pipeline==null&&(this.pipeline=i.createComputePipeline({layout:"auto",compute:{module:i.createShaderModule({code:Hc}),entryPoint:"main"}}));const o=this.pipeline,l=4*4;this.configBuffer||(this.configBuffer=i.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),i.queue.writeBuffer(this.configBuffer,0,new Uint32Array([t.width,t.height,e,e]));const h=4*6;if(!this.quaternionBuffer){this.quaternionBuffer=i.createBuffer({size:h*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let F=new Float32Array(4*6);for(let U=0;U<6;U++){let Q=fn.getRotationToFace(U);F[U*4+0]=Q.x,F[U*4+1]=Q.y,F[U*4+2]=Q.z,F[U*4+3]=Q.w}i.queue.writeBuffer(this.quaternionBuffer,0,F)}this.blurSettingBuffer||(this.blurSettingBuffer=i.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),i.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([r,0,0,0]));const c=t.erpTexture;let u=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:{buffer:this.quaternionBuffer,size:h*4}},{binding:2,resource:c.gpuSampler},{binding:3,resource:c.getGPUView()}],d=[{binding:0,resource:{buffer:this.blurSettingBuffer,size:4*4}},{binding:1,resource:a}];const f=i.createBindGroup({layout:o.getBindGroupLayout(0),entries:u}),A=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:d}),p=S.beginCommandEncoder(),B=p.beginComputePass();B.setPipeline(o),B.setBindGroup(0,f),B.setBindGroup(1,A),B.dispatchWorkgroups(e/8,e/8,6),B.end(),S.endCommandEncoder(p)}}s(la,"configBuffer",null),s(la,"quaternionBuffer",null),s(la,"blurSettingBuffer",null),s(la,"pipeline");class mn{constructor(t){s(this,"faceTextureRef");s(this,"_texture");this._texture=t,this.faceTextureRef={}}uploadTexture(t,e){let r=this.getGpuSource(t);return Ba.makeTextureCube(e,this._texture.width,r.v),this}uploadErpTexture(t){let e=this.getGpuSource(0);return Ba.makeTextureCube(t,this._texture.width,e.v),this.generateMipmap(t),this}getGpuSource(t){let e=this.faceTextureRef[t];return e||(e={t:this._texture.getGPUTexture(),v:this._texture.getGPUTexture().createView({format:this._texture.format,dimension:"2d-array",baseMipLevel:t,mipLevelCount:1,arrayLayerCount:6})},this.faceTextureRef[t]=e),e}generateMipmap(t){let e=1;for(;e<this._texture.mipmapCount;)this.generateMipmapAtLevel(e,t),e++}generateMipmapAtLevel(t,e,r=3){let a=this._texture.width/Math.pow(2,t),i={width:a,height:a,erpTexture:e},o=(t+1)/this._texture.mipmapCount;o=Math.pow(o,r);let l=this.getGpuSource(t);la.importantSample(i,a,o,l.v)}}class Ti extends Ki{constructor(){super();s(this,"_url");s(this,"_faceData");this.useMipmap=!0,this.format=H.rgba16float,this.isHDRTexture=!0,this._faceData=new mn(this)}createFromHDRData(e,r){let a=new _t(r.width,r.height,H.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),i=new Float32Array(r.array);return Ba.convertRGBE2RGBA(a,i),this.createFromTexture(e,a),this}createFromTexture(e,r){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let a=this.width;for(this.mipmapCount=1;a>16;)a/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=R.device.createSampler(this),this._faceData.uploadErpTexture(r),this}async load(e,r){return this._url=e,(await new st().load(e,pn,r)).getCubeTexture()}}function Kc(n){return new TextDecoder().decode(n)}class ji{constructor(t,e,r,a){s(this,"buffer");s(this,"binOffset");s(this,"binLength");s(this,"header");this.buffer=t,this.binOffset=e+r,this.binLength=a;let i=null;if(r!==0){const o=new Uint8Array(t,e,r);i=JSON.parse(Kc(o))}else i={};this.header=i}getKeys(){return Object.keys(this.header)}getData(t,e,r=null,a=null){const i=this.header;if(!(t in i))return null;const o=i[t];if(o instanceof Object){if(Array.isArray(o))return o;{const{buffer:l,binOffset:h,binLength:c}=this,u=o.byteOffset||0,d=o.type||a,f=o.componentType||r;if("type"in o&&a&&o.type!==a)throw new Error("FeatureTable: Specified type does not match expected type.");let A;switch(d){case"SCALAR":A=1;break;case"VEC2":A=2;break;case"VEC3":A=3;break;case"VEC4":A=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${t}".`)}let p;const B=h+u,F=e*A;switch(f){case"BYTE":p=new Int8Array(l,B,F);break;case"UNSIGNED_BYTE":p=new Uint8Array(l,B,F);break;case"SHORT":p=new Int16Array(l,B,F);break;case"UNSIGNED_SHORT":p=new Uint16Array(l,B,F);break;case"INT":p=new Int32Array(l,B,F);break;case"UNSIGNED_INT":p=new Uint32Array(l,B,F);break;case"FLOAT":p=new Float32Array(l,B,F);break;case"DOUBLE":p=new Float64Array(l,B,F);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${t}".`)}if(B+F*p.BYTES_PER_ELEMENT>h+c)throw new Error("FeatureTable: Feature data read outside binary body length.");return p}}else return o}}class Un extends ji{constructor(e,r,a,i,o){super(e,a,i,o);s(this,"batchSize");this.batchSize=r}getData(e,r=null,a=null){return super.getData(e,this.batchSize,r,a)}}function Bn(n){let t;if(n instanceof DataView?t=n:t=new DataView(n),String.fromCharCode(t.getUint8(0))==="{")return null;let e="";for(let r=0;r<4;r++)e+=String.fromCharCode(t.getUint8(r));return e}class jc{async parse(t){const e=new DataView(t),r=Bn(e);console.assert(r==="b3dm");const a=e.getUint32(4,!0);console.assert(a===1);const i=e.getUint32(8,!0);console.assert(i===t.byteLength);const o=e.getUint32(12,!0),l=e.getUint32(16,!0),h=e.getUint32(20,!0),c=e.getUint32(24,!0),u=28,d=new ji(t,u,o,l),f=u+o+l,A=new Un(t,d.getData("BATCH_LENGTH"),f,h,c),p=f+h+c,B=new Uint8Array(t,p,i-p);return{version:a,featureTable:d,batchTable:A,glbBytes:B}}}const Ir=class Ir extends jc{constructor(){super();s(this,"adjustmentTransform");s(this,"gltfBuffer");this.adjustmentTransform=new Z().identity(),Ir.tempMatrix||(Ir.tempMatrix=new Z().identity())}async parse(e){const r=await super.parse(e);this.gltfBuffer=r.glbBytes.slice().buffer;let a=await new Qn().parseBinary(this.gltfBuffer),{batchTable:i,featureTable:o}=r;const l=o.getData("RTC_CENTER");l&&(a.x+=l[0],a.y+=l[1],a.z+=l[2]);let h=a.getComponent(Jt);h.updateWorldMatrix();let c=Ir.tempMatrix;c.compose(h.localPosition,h.localRotQuat,h.localScale),c.multiply(this.adjustmentTransform);let u=c.decompose(Wt.QUATERNION);return h.localRotQuat.copyFrom(u[1]),h.localRotQuat=h.localRotQuat,h.localPosition.copyFrom(u[0]),h.localPosition=h.localPosition,h.localScale.copyFrom(u[2]),h.localScale=h.localScale,h.updateWorldMatrix(),a.batchTable=i,a.featureTable=o,a}static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let r="";for(let a=0,i=e.length;a<i;a++)r+=String.fromCharCode(e[a]);try{return decodeURIComponent(escape(r))}catch{return r}}};s(Ir,"tempMatrix");let Nr=Ir;class Fn extends at{async parseBuffer(t){let e=new Nr;e.adjustmentTransform=this.userData,this.data=await e.parse(t)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}s(Fn,"format",ke.JSON);const Cn="glTF",sa=12,Vs={JSON:1313821514,BIN:5130562},wi={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class qc{constructor(t){s(this,"name");s(this,"content");s(this,"body");s(this,"header");this.name=wi.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,sa);if(this.header={magic:Nr.decodeText(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==Cn)throw new Error("GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("GLTFLoader: Legacy binary file detected.");const r=this.header.length-sa,a=new DataView(t,sa);let i=0;for(;i<r;){const o=a.getUint32(i,!0);i+=4;const l=a.getUint32(i,!0);if(i+=4,l===Vs.JSON){const h=new Uint8Array(t,sa+i,o);this.content=Nr.decodeText(h)}else if(l===Vs.BIN){const h=sa+i;this.body=t.slice(h,h+o)}i+=o}if(this.content===null)throw new Error("GLTFLoader: JSON content not found.")}}class Qn{constructor(){s(this,"_binary")}async parseBinary(t){this._binary=t;const e=Nr.decodeText(new Uint8Array(this._binary,0,4)),r={};let a,i;if(e===Cn){try{i=r[wi.KHR_BINARY_GLTF]=new qc(this._binary)}catch{return}a=r[wi.KHR_BINARY_GLTF].content}else a=Nr.decodeText(new Uint8Array(this._binary));const o=JSON.parse(a);return await this.parseGLB(o,i.body)}async parseGLB(t,e){return await new Hi().parseJsonAndBuffer(t,e)}}class $c{async parse(t){const e=new DataView(t),r=Bn(e);console.assert(r==="i3dm");const a=e.getUint32(4,!0);console.assert(a===1);const i=e.getUint32(8,!0);console.assert(i===t.byteLength);const o=e.getUint32(12,!0),l=e.getUint32(16,!0),h=e.getUint32(20,!0),c=e.getUint32(24,!0);e.getUint32(28,!0);const u=32,d=new ji(t,u,o,l),f=u+o+l,A=new Un(t,d.getData("INSTANCES_LENGTH"),f,h,c),p=f+h+c,B=new Uint8Array(t,p,i-p);return{version:a,featureTable:d,batchTable:A,glbBytes:B}}}class eu extends ie{constructor(e,r,a){super();s(this,"_geometry");s(this,"_material");s(this,"_instanceList");this._geometry=e,this._material=r,this._instanceList=[];for(let i=0;i<a;i++){let o,l=new ie;o=l.addComponent(Be),o.geometry=this._geometry,o.material=this._material,this.addChild(l),this._instanceList.push(l)}}setMatrixAt(e,r){let a=this._instanceList[e],i=r.decompose(Wt.QUATERNION),o=a.transform;return o.localRotQuat.copyFrom(i[1]),o.localRotQuat=o.localRotQuat,o.localPosition.copyFrom(i[0]),o.localPosition=o.localPosition,o.localScale.copyFrom(i[2]),o.localScale=o.localScale,this}}const oe=class oe extends $c{constructor(){super();s(this,"adjustmentTransform");s(this,"_gltfBuffer");oe.tempFwd||(oe.tempFwd=new g),oe.tempUp||(oe.tempUp=new g),oe.tempRight||(oe.tempRight=new g),oe.tempPos||(oe.tempPos=new g),oe.tempQuat||(oe.tempQuat=new X),oe.tempSca||(oe.tempSca=new g),oe.tempMat||(oe.tempMat=new Z),this.adjustmentTransform=new Z().identity()}async parse(e){const r=await super.parse(e);this._gltfBuffer=r.glbBytes.slice().buffer;let a=await new Qn().parseBinary(this._gltfBuffer),{batchTable:i,featureTable:o}=r;const l=this.adjustmentTransform,h=o.getData("INSTANCES_LENGTH"),c=o.getData("POSITION",h,"FLOAT","VEC3"),u=o.getData("NORMAL_UP",h,"FLOAT","VEC3"),d=o.getData("NORMAL_RIGHT",h,"FLOAT","VEC3"),f=o.getData("SCALE_NON_UNIFORM",h,"FLOAT","VEC3"),A=o.getData("SCALE",h,"FLOAT","SCALAR"),p=new Map,B=[];a.traverse(Q=>{let y;if(y=Q?Q.getComponent(Be):null,y){const{geometry:b,material:x}=y,w=new eu(b,x,h);w.localPosition=w.localPosition.copy(Q.localPosition),w.localRotation=w.localRotation.copy(Q.localRotation),w.localScale=w.localScale.copy(Q.localScale),B.push(w),p.set(Q,w)}});const F=new g;for(let Q=0;Q<h;Q++)F.x+=c[Q*3+0]/h,F.y+=c[Q*3+1]/h,F.z+=c[Q*3+2]/h;p.forEach((Q,y)=>{const b=y.parent?y.parentObject:null;b&&(b.removeChild(y),b.addChild(Q),Q.transform.updateWorldMatrix(),Q.transform.worldMatrix.transformVector4(F,Q.localPosition))});const U=oe;for(let Q=0;Q<h;Q++){U.tempMat.identity(),U.tempPos.set(c[Q*3+0]-F.x,c[Q*3+1]-F.y,c[Q*3+2]-F.z),u?(U.tempUp.set(u[Q*3+0],u[Q*3+1],u[Q*3+2]),U.tempRight.set(d[Q*3+0],d[Q*3+1],d[Q*3+2]),U.tempRight.crossProduct(U.tempUp,U.tempFwd).normalize(),U.tempMat.makeBasis(U.tempRight,U.tempUp,U.tempFwd),U.tempQuat.setFromRotationMatrix(U.tempMat)):U.tempQuat.set(0,0,0,1),A?U.tempSca.setScalar(A[Q]):f?U.tempSca.set(f[Q*3+0],f[Q*3+1],f[Q*3+2]):U.tempSca.set(1,1,1),U.tempMat.compose(U.tempPos,U.tempQuat,U.tempSca),U.tempMat.multiplyMatrices(U.tempMat,l);for(let y=0,b=B.length;y<b;y++)B[y].setMatrixAt(Q,U.tempMat)}return a.batchTable=i,a.featureTable=o,a}};s(oe,"tempFwd"),s(oe,"tempUp"),s(oe,"tempRight"),s(oe,"tempPos"),s(oe,"tempQuat"),s(oe,"tempSca"),s(oe,"tempMat");let Di=oe;class vn extends at{async parseBuffer(t){let e=new Di;e.adjustmentTransform=this.userData,this.data=await e.parse(t)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}s(vn,"format",ke.BIN);class Sn extends Ki{constructor(){super();s(this,"_faceData");s(this,"_url");this.useMipmap=!0,this.format=H.rgba16float,this._faceData=new mn(this)}get ldrImageUrl(){return this._url}async load(e,r){this._url=e;let a=new Br(!1);return await a.load(e,r),this.createFromLDRTexture(a),this}createFromLDRTexture(e){let r=Math.log2(e.width/4);return r=Math.pow(2,Math.round(r)),this.createFromTexture(r,e),this}createFromTexture(e,r){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let a=this.width;for(this.mipmapCount=1;a>16;)a/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=R.device.createSampler(this),this._faceData.uploadErpTexture(r),this}}let tu=`
var<private>PI: f32 = 3.141592653589793;

// fn saturate( x : f32 ) -> f32 {
//     return clamp(x, 0.0, 1.0);
// }

fn hammersley(i : u32, N : u32) -> vec2<f32>
{
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) / f32(N), rdi);
}

fn G_Smith(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var k = (roughness * roughness) / 2.0;
    var GGXL = NoL / (NoL * (1.0 - k) + k);
    var GGXV = NoV / (NoV * (1.0 - k) + k);
    return GGXL * GGXV;
}

fn V_SmithGGXCorrelated(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var a2 = pow(roughness, 4.0);
    var GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
    var GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
    return 0.5 / (GGXV + GGXL);
}


// Based on Karis 2014
fn importanceSampleGGX(Xi: vec2<f32>, roughness: f32, N: vec3<f32>) -> vec3<f32>
{
    var a = roughness * roughness;
    // Sample in spherical coordinates
    var Phi = 2.0 * PI * Xi.x;
    var CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
    var SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    // Construct tangent space vector
    var H: vec3<f32>;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    // Tangent to world space
    var UpVector = vec3<f32>(1.0, 0.0, 0.0);
    if (abs(N.z) < 0.999) {
        UpVector = vec3<f32>(0.0, 0.0, 1.0);
    }
    var TangentX = normalize(cross(UpVector, N));
    var TangentY = cross(N, TangentX);
    return TangentX * H.x + TangentY * H.y + N * H.z;
}


// Karis 2014
fn integrateBRDF(roughness: f32, NoV: f32) -> vec2<f32>
{
    var V: vec3<f32>;
    V.x = sqrt(1.0 - NoV * NoV); // sin
    V.y = 0.0;
    V.z = NoV; // cos

    // N points straight upwards for this integration
    var N = vec3<f32>(0.0, 0.0, 1.0);

    var A = 0.0;
    var B = 0.0;
    var numSamples = 1024u;

    for (var i = 0u; i < numSamples; i += 1u) {
        var Xi = hammersley(i, numSamples);
        // Sample microfacet direction
        var H = importanceSampleGGX(Xi, roughness, N);

        // Get the light direction
        var L = 2.0 * dot(V, H) * H - V;

        var NoL = saturate(dot(N, L));
        var NoH = saturate(dot(N, H));
        var VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            var V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
            var Fc = pow(1.0 - VoH, 5.0);
            A += (1.0 - Fc) * V_pdf;
            B += Fc * V_pdf;
        }
    }

    return 4.0 * vec2<f32>(A, B) / f32(numSamples);
}

@group(0) @binding(0) var brdflutTexture: texture_storage_2d<rgba8unorm, write>;
@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(0.0);
    // Output to screen
    var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    textureStore(brdflutTexture, vec2<i32>(fragCoord.xy), fragColor);
}
`;class ru{constructor(){s(this,"compute");this.compute=new bt(tu)}generateBRDFLUTTexture(){let t=new _t(256,256,H.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);this.compute.setStorageTexture("brdflutTexture",t),this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let e=S.beginCommandEncoder();return S.computeCommand(e,[this.compute]),S.endCommandEncoder(e),t}}class au extends rt{constructor(){super(...arguments);s(this,"_dataBuffer")}create(e,r,a,i=!1){let o=R.device;const l=Math.ceil(e*4/256)*256;this.format=H.rgba8unorm,this.mipmapCount=Math.floor(i?Math.log2(e):1),this.createTextureDescriptor(e,r,this.mipmapCount,this.format);const h=this._dataBuffer=o.createBuffer({size:a.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});o.queue.writeBuffer(h,0,a);const c=S.beginCommandEncoder();return c.copyBufferToTexture({buffer:h,bytesPerRow:l},{texture:this.getGPUTexture()},{width:e,height:r,depthOrArrayLayers:1}),S.endCommandEncoder(c),i&&jr.webGPUGenerateMipmap(this),this}updateTexture(e,r,a){let i=R.device;const o=Math.ceil(e*4/256)*256;this.mipmapCount=Math.floor(Math.log2(e)),this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null;const l=this._dataBuffer=i.createBuffer({size:a.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});i.queue.writeBuffer(l,0,a);const h=S.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:r,depthOrArrayLayers:1}),S.endCommandEncoder(h),this.gpuSampler=i.createSampler(this),this.mipmapCount>1&&jr.webGPUGenerateMipmap(this)}}class Ya{constructor(t){s(this,"id");s(this,"guiTexture");s(this,"uvRec",new j(0,0,1,1));s(this,"uvBorder",new j(0,0,0,0));s(this,"offsetSize",new j(0,0,4,4));s(this,"borderSize",new j(0,0,0,0));s(this,"trimSize",new Ie);s(this,"isSliced",!1);s(this,"height",4);s(this,"width",4);s(this,"xadvance",0);s(this,"xoffset",0);s(this,"yoffset",0);this.guiTexture=t||C.res.defaultGUITexture}}const ga=class ga{constructor(t){s(this,"_staticId",-1);s(this,"dynamicId",-1);s(this,"texture");s(this,"width",1);s(this,"height",1);t||(t=C.res.whiteTexture),t.addressModeU="clamp-to-edge",t.addressModeV="clamp-to-edge",this.texture=t,ga._maxUid++,this._staticId=ga._maxUid,this.init()}get staticId(){return this._staticId}init(){this.dynamicId=-1,this.width=this.texture.width,this.height=this.texture.height}};s(ga,"_maxUid",-1);let Fa=ga;class iu{constructor(){s(this,"fntCache",{});s(this,"fntData",{})}addFontData(t,e,r){this.fntData[`${t}${e}`]=r}getFontData(t,e){return this.fntData[`${t}${e}`]}addFnt(t,e,r,a){let i=`${t}${e}`;this.fntCache[i]||(this.fntCache[i]={}),this.fntCache[i][r]=a}getFnt(t,e,r){let a=`${t}${e}`,i=this.fntCache[a];return i?i[r]:this.fntCache[" "]}}let Vi=new iu;class su{constructor(){s(this,"face","");s(this,"size",0);s(this,"bold",!1);s(this,"italic",!1);s(this,"stretchH",0);s(this,"spacing","");s(this,"outline",0);s(this,"lineHeight",0);s(this,"base",0);s(this,"scaleW",0);s(this,"scaleH",0);s(this,"pages",0);s(this,"packed",0);s(this,"alphaChnl",0);s(this,"redChnl",0);s(this,"greenChnl",0);s(this,"blueChnl",0);s(this,"count",0);s(this,"fontPage",[]);s(this,"fontChar",{})}}class nu{constructor(){s(this,"id",0);s(this,"file","")}}class ou{constructor(){s(this,"id",-1);s(this,"x",0);s(this,"y",0);s(this,"width",0);s(this,"height",0);s(this,"xoffset",0);s(this,"yoffset",0);s(this,"xadvance",0);s(this,"page",0);s(this,"chnl",0)}}const Kt=class Kt extends at{static parseSprite(t,e){for(const r in e.fontChar)if(Object.prototype.hasOwnProperty.call(e.fontChar,r)){const a=e.fontChar[r];let i=new Ya;i.id=a.id.toString(),i.offsetSize.set(0,0,a.width,a.height),i.trimSize.set(a.width,a.height),i.width=a.width,i.height=a.height,i.xadvance=a.xadvance,i.xoffset=a.xoffset,i.yoffset=a.yoffset,i.guiTexture=t[a.page],i.uvRec.set(a.x/e.scaleW,(e.scaleH-(a.y+a.height))/e.scaleH,a.width/e.scaleW,a.height/e.scaleH),Vi.addFnt(e.face,e.size,i.id,i)}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}async parseString(t){let e=this.getNewLine(t),r=t,a=new su;r.trim().split(e).forEach((i,o)=>{if(o<2)Kt.readLineProperty(i,a);else if(o<a.pages+2){let l=new nu;Kt.readLineProperty(i,l),a.fontPage.push(l)}else if(o<a.pages+3)Kt.readLineProperty(i,a);else if(a.count>0){let l=new ou;Kt.readLineProperty(i,l),a.fontChar[l.id]=l,a.count--}}),r="",this.data=a,await this.loadFontTextures()}getNewLine(t){return t.indexOf(`\r
`)!=-1?`\r
`:t.indexOf("\r")!=-1?"\r":`
`}async loadFontTextures(){let t=[],e=this.data;for(const r of e.fontPage){let a=this.baseUrl+r.file;await C.res.loadTexture(a,null,!0);let i=C.res.getTexture(a),o=new Fa(i);t.push(o)}Kt.parseSprite(t,e),e.fontChar[" "]||Kt.insertSpaceChar(e,t[0])}static insertSpaceChar(t,e){let r=new Ya,a=t.size*.5,i=t.lineHeight*.5;r.id=" ",r.offsetSize.set(0,0,t.size,t.size),r.trimSize.set(a,i),r.width=a,r.height=i,r.xadvance=0,r.xoffset=0,r.yoffset=0,r.guiTexture=e,r.uvRec.set(0,0,1e-6,1e-6),Vi.addFnt(t.face,t.size,r.id,r)}static readLineProperty(t,e){t.trim().split(" ").forEach((r,a)=>{let i=r.split("=");if(i.length>1){let o=i[0],l=i[1];Object.prototype.hasOwnProperty.call(e,o)&&(l.indexOf('"')==-1?e[o]=parseFloat(i[1]):e[o]=l.replace('"',"").replace('"',""))}})}};s(Kt,"format",ke.TEXT);let Ni=Kt;function lu(n,t,e){let r=new Ya;r.guiTexture=n,r.id=t,r.uvRec.copyFrom(e.textureRect),r.trimSize.x=e.textureRect.z,r.trimSize.y=e.textureRect.w,r.offsetSize.x=e.textureRectOffset.x,r.offsetSize.y=e.textureRectOffset.y,r.offsetSize.z=e.size.x,r.offsetSize.w=e.size.y,r.width=e.size.x,r.height=e.size.y;let a=1/n.width,i=1/n.height;r.uvRec.set(r.uvRec.x*a,r.uvRec.y*i,r.uvRec.z*a,r.uvRec.w*i);let o=.1;return e.border.x<=o&&e.border.y<=o&&e.border.z<=o&&e.border.x<=o?r.isSliced=!1:(r.borderSize.copyFrom(e.border),r.uvBorder.copyFrom(e.border),r.uvBorder.x-=e.textureRectOffset.x,r.uvBorder.y-=e.textureRectOffset.y,r.uvBorder.z=e.border.z-(e.size.x-e.textureRect.z-e.textureRectOffset.x),r.uvBorder.w=e.border.w-(e.size.y-e.textureRect.w-e.textureRectOffset.y),r.uvBorder.x/=e.textureRect.z,r.uvBorder.z/=e.textureRect.z,r.uvBorder.y/=e.textureRect.w,r.uvBorder.w/=e.textureRect.w,r.isSliced=!0),r}class hu{constructor(t){s(this,"_spriteMap",new Map);s(this,"_spriteList",[]);s(this,"textureSize",new Ie);s(this,"name");this.textureSize.set(t.x,t.y)}setTexture(t,e,r){let a=lu(t,e,r);return this._spriteMap.set(a.id,a),this._spriteList.push(a),a}getSprite(t){return this._spriteMap.get(t)}get spriteList(){return this._spriteList}}class Rn extends at{constructor(){super(...arguments);s(this,"_json");s(this,"_texture")}async parseString(e){this._json=JSON.parse(e);let r=this.userData.replace(".json",".png");this._texture=await C.res.loadTexture(r,null,!0),this.data={json:this._json,texture:this._texture},this.parseAtlas()}verification(){if(this.data)return!0;throw new Error("verify failed.")}parseAtlas(){let e=new hu(this._json.size),r=new Fa(this._texture),a=this._json.atlas;for(const i in a)e.setTexture(r,i,a[i]);C.res.addAtlas(this.baseUrl,e),this.data=e}}s(Rn,"format",ke.TEXT);class cu{constructor(){s(this,"_texturePool");s(this,"_materialPool");s(this,"_prefabPool");s(this,"_gltfPool");s(this,"_geometryPool");s(this,"_atlasList");s(this,"_obj");s(this,"normalTexture");s(this,"maskTexture");s(this,"whiteTexture");s(this,"blackTexture");s(this,"redTexture");s(this,"blueTexture");s(this,"greenTexture");s(this,"yellowTexture");s(this,"grayTexture");s(this,"defaultSky");s(this,"defaultGUITexture");s(this,"defaultGUISprite");s(this,"defaultMaterial");this._texturePool=new Map,this._materialPool=new Map,this._prefabPool=new Map,this._geometryPool=new Map,this._gltfPool=new Map,this._atlasList=new Map,this._obj=new Map}getGltf(t){return this._gltfPool.get(t)}addObj(t,e){this._obj.set(t,e)}getObj(t){return this._obj.get(t)}addTexture(t,e){this._texturePool.set(t,e)}getTexture(t){return this._texturePool.get(t)}addGeometry(t,e){this._geometryPool.set(t,e)}getGeometry(t){return this._geometryPool.get(t)}addMat(t,e){return this._materialPool.set(t,e)}getMat(t){return this._materialPool.get(t)}addPrefab(t,e){this._prefabPool.set(t,e)}getPrefab(t){return this._prefabPool.get(t).instantiate()}addAtlas(t,e){e.name=t,this._atlasList.set(t,e)}getAtlas(t){return this._atlasList.get(t)}getGUISprite(t){for(let e of this._atlasList.values()){let r=e.getSprite(t);if(r)return r}return null}async load(t,e,r){return(await new st().load(t,e,r)).data}async loadGltf(t,e){if(this._prefabPool.has(t))return this._prefabPool.get(t);let r,a=t.substring(t.lastIndexOf(".")).toLowerCase(),i=new st;a==".gltf"?r=await i.load(t,$e,e):r=await i.load(t,Hi,e);let o=r.data;return this._prefabPool.set(t,o),this._gltfPool.set(t,r.gltf),o}async loadObj(t,e){if(this._prefabPool.has(t))return this._prefabPool.get(t);let r,a=t.substring(t.lastIndexOf(".")).toLowerCase(),i=new st;a==".obj"&&(r=await i.load(t,dn,e));let o=r.data;return this._prefabPool.set(t,o),o}async loadB3DM(t,e,r){if(this._prefabPool.has(t))return this._prefabPool.get(t);let a=(await new st().load(t,Fn,e,r)).data;return this._prefabPool.set(t,a),a}async loadI3DM(t,e,r){if(this._prefabPool.has(t))return this._prefabPool.get(t);let a=(await new st().load(t,vn,e,r)).data;return this._prefabPool.set(t,a),a}async loadTexture(t,e,r){if(this._texturePool.has(t))return this._texturePool.get(t);let a=new Br;return a.flipY=r,await a.load(t,e),this._texturePool.set(t,a),a}async loadTextureCount(t,e,r,a){return new Promise(async(i,o)=>{let l=0,h=[];e==0&&i(h);for(let c=0;c<e;c++){const u=t.shift();this.loadTexture(u,r,a).then(d=>{h.push(d),l++,l==e&&i(h)})}})}async loadBitmapTextures(t,e=5,r,a){let i=[],o=Math.floor(t.length/e)+1,l=Math.floor(t.length%e);for(let h=0;h<o;h++){let c=await this.loadTextureCount(t,h==o-1?l:e,r,a);i.push(...c)}return i}async loadHDRTexture(t,e){if(this._texturePool.has(t))return this._texturePool.get(t);let r=new An;return r=await r.load(t,e),this._texturePool.set(t,r),r}async loadHDRTextureCube(t,e){if(this._texturePool.has(t))return this._texturePool.get(t);let r=new Ti;return r=await r.load(t,e),this._texturePool.set(t,r),r}async loadLDRTextureCube(t,e){if(this._texturePool.has(t))return this._texturePool.get(t);let r=new Sn;return r=await r.load(t,e),this._texturePool.set(t,r),r}async loadTextureCubeMaps(t){let e=t[0];if(this._texturePool.has(e))return this._texturePool.get(e);let r=new ws;return await r.load(t),this._texturePool.set(t[0],r),r}async loadTextureCubeStd(t,e){if(this._texturePool.has(t))return this._texturePool.get(t);let r=new ws;return await r.loadStd(t),r}async loadJSON(t,e){return await new st().loadJson(t,e).then(async r=>r).catch(r=>{console.log(r)})}async loadFont(t,e,r){let a=await new st().load(t,Ni,e,r),i=a.data;return Vi.addFontData(i.face,i.size,i),a.data}async loadAtlas(t,e){return(await new st().load(t,Rn,e,t)).data}createTexture(t,e,r,a,i,o,l){let h=32,c=32,u=new Uint8Array(h*c*4);this.fillColor(u,t,e,r,a,i,o);let d=new au;return d.name=l,d.create(16,16,u,!0),l&&this.addTexture(l,d),d}fillColor(t,e,r,a,i,o,l){for(let h=0;h<e;h++)for(let c=0;c<r;c++){let u=c*e+h;t[u*4+0]=a,t[u*4+1]=i,t[u*4+2]=o,t[u*4+3]=l}}initDefault(){this.normalTexture=this.createTexture(32,32,255*.5,255*.5,255,255,"default-normalTexture"),this.maskTexture=this.createTexture(32,32,255,255*.5,255,255,"default-maskTexture"),this.whiteTexture=this.createTexture(32,32,255,255,255,255,"default-whiteTexture"),this.blackTexture=this.createTexture(32,32,0,0,0,255,"default-blackTexture"),this.redTexture=this.createTexture(32,32,255,0,0,255,"default-redTexture"),this.blueTexture=this.createTexture(32,32,0,0,255,255,"default-blueTexture"),this.greenTexture=this.createTexture(32,32,0,255,0,255,"default-greenTexture"),this.yellowTexture=this.createTexture(32,32,0,255,255,255,"default-yellowTexture"),this.grayTexture=this.createTexture(32,32,128,128,128,255,"default-grayTexture");let t=new ru().generateBRDFLUTTexture(),e=t.name="BRDFLUT";this.addTexture(e,t),this.defaultSky=new Ti,this.defaultSky.createFromTexture(128,this.blackTexture),ae.getInstance().attached(this.defaultSky,this),ae.getInstance().attached(t,this),ae.getInstance().attached(this.normalTexture,this),ae.getInstance().attached(this.maskTexture,this),ae.getInstance().attached(this.whiteTexture,this),ae.getInstance().attached(this.blackTexture,this),ae.getInstance().attached(this.redTexture,this),ae.getInstance().attached(this.blueTexture,this),ae.getInstance().attached(this.greenTexture,this),ae.getInstance().attached(this.yellowTexture,this),ae.getInstance().attached(this.grayTexture,this),this.defaultGUITexture=new Fa(this.whiteTexture),this.defaultGUISprite=new Ya(this.defaultGUITexture),this.defaultGUISprite.trimSize.set(4,4),this.defaultMaterial=new Vr}}class uu extends ut{constructor(){super(...arguments);s(this,"_postList")}init(e){this._postList=new Map}start(){}stop(){}onEnable(){this.activePost()}onDisable(){this.unActivePost()}activePost(){let e=this.transform.view3D,r=C.getRenderJob(e);this._postList.forEach(a=>{r.addPost(a)})}unActivePost(){let e=this.transform.view3D,r=C.getRenderJob(e);this._postList.forEach(a=>{r.removePost(a)})}addPost(e){if(this._postList.has(e))return;let r=new e;return this._postList.set(e,r),this._enable&&this.activePost(),r}removePost(e){if(!this._postList.has(e))return;let r=this._postList.get(e);this._postList.delete(e);let a=this.transform.view3D;C.getRenderJob(a).removePost(r)}getPost(e){return this._postList.has(e)?this._postList.get(e):null}}class C{static get frameRate(){return this._frameRate}static set frameRate(t){this._frameRate=t,this._frameRateValue=1e3/t,t>=360&&(this._frameRateValue=0)}static get size(){return R.presentationSize}static get aspect(){return R.aspect}static get width(){return R.windowWidth}static get height(){return R.windowHeight}static async init(t={}){console.log("Engine Version",mo),window.isSecureContext||console.warn("WebGPU is only supported in secure contexts (HTTPS or localhost)"),this.setting={...this.setting,...t.engineSetting},await he.init(Z.allocCount,this.setting.doublePrecision),await R.init(t.canvasConfig),this.setting.reflectionSetting.width=this.setting.reflectionSetting.reflectionProbeSize*6,this.setting.reflectionSetting.height=this.setting.reflectionSetting.reflectionProbeSize*this.setting.reflectionSetting.reflectionProbeMaxCount,Le.getGBufferFrame(Le.reflections_GBuffer,this.setting.reflectionSetting.width,this.setting.reflectionSetting.height,!1),N.init(),Nt.init(),ce.init(),xt.init(),mt.init(),this.res=new cu,this.res.initDefault(),this._beforeRender=t.beforeRender,this._renderLoop=t.renderLoop,this._lateRender=t.lateRender,this.inputSystem=new po,this.inputSystem.initCanvas(R.canvas)}static startRenderJob(t){let e=new $h(t);return this.renderJobs.set(t,e),this.setting.pick.mode=="pixel"&&t.scene.getOrAddComponent(uu).addPost(hn),(this.setting.pick.mode=="pixel"||this.setting.pick.mode=="bound")&&(t.enablePick=!0),e}static startRenderView(t){this.renderJobs||(this.renderJobs=new Map),this.views=[t];let e=this.startRenderJob(t);return this.resume(),e}static startRenderViews(t){this.renderJobs||(this.renderJobs=new Map),this.views=t;for(let e=0;e<t.length;e++)this.startRenderJob(t[e]);this.resume()}static getRenderJob(t){return this.renderJobs.get(t)}static pause(){this._requestAnimationFrameID!==0&&(cancelAnimationFrame(this._requestAnimationFrameID),this._requestAnimationFrameID=0)}static resume(){this._requestAnimationFrameID===0&&(this._requestAnimationFrameID=requestAnimationFrame(t=>this.render(t)))}static async render(t){if(this._frameRateValue>0){let e=t-this._time;if(e<this._frameRateValue){let r=performance.now();await new Promise(a=>{setTimeout(()=>{t+=performance.now()-r,a(!0)},this._frameRateValue-e)})}this._time=t}await this.updateFrame(t),this._requestAnimationFrameID=0,this.resume()}static async updateFrame(t){Ae.delta=t-Ae.time,Ae.time=t,Ae.frame+=1,yi.tick(Ae.delta);let e=this.views,r=0;for(r=0;r<e.length;r++){const i=e[r];i.scene.waitUpdate();let[o,l]=R.presentationSize;i.camera.viewPort.setTo(0,0,o,l)}this._beforeRender&&await this._beforeRender();for(const i of Ue.componentsBeforeUpdateList){let o=i[0],l=i[1];for(const h of l){let c=h[0],u=h[1];c.enable&&u(o)}}let a=R.device.createCommandEncoder();for(const i of Ue.componentsComputeList){let o=i[0],l=i[1];for(const h of l){let c=h[0],u=h[1];c.enable&&u(o,a)}}R.device.queue.submit([a.finish()]);for(const i of Ue.componentsUpdateList){let o=i[0],l=i[1];for(const h of l){let c=h[0],u=h[1];c.enable&&u(o)}}for(const i of Ue.graphicComponent){let o=i[0],l=i[1];for(const h of l){let c=h[0],u=h[1];o&&c.enable&&u(o)}}this._renderLoop&&await this._renderLoop(),he.updateAllContinueTransform(0,Z.useCount,16),ce.modelMatrixBindGroup.writeBuffer(Z.useCount*16),this.renderJobs.forEach((i,o)=>{i.renderState||i.start(),i.renderFrame()});for(const i of Ue.componentsLateUpdateList){let o=i[0],l=i[1];for(const h of l){let c=h[0],u=h[1];c.enable&&u(o)}}this._lateRender&&await this._lateRender()}}s(C,"res"),s(C,"inputSystem"),s(C,"views"),s(C,"_frameRateValue",0),s(C,"_frameRate",360),s(C,"_time",0),s(C,"_beforeRender"),s(C,"_renderLoop"),s(C,"_lateRender"),s(C,"_requestAnimationFrameID",0),s(C,"setting",{doublePrecision:!1,occlusionQuery:{enable:!0,debug:!1},pick:{enable:!0,mode:"bound",detail:"mesh"},render:{debug:!1,renderPassState:4,renderState_left:5,renderState_right:5,renderState_split:.5,quadScale:1,hdrExposure:1.5,debugQuad:-1,maxPointLight:1e3,maxDirectLight:4,maxSportLight:1e3,drawOpMin:0,drawOpMax:Number.MAX_SAFE_INTEGER,drawTrMin:0,drawTrMax:Number.MAX_SAFE_INTEGER,zPrePass:!1,useLogDepth:!1,useCompressGBuffer:!1,gi:!1,postProcessing:{bloom:{downSampleStep:3,downSampleBlurSize:9,downSampleBlurSigma:1,upSampleBlurSize:9,upSampleBlurSigma:1,luminanceThreshole:1,bloomIntensity:1,hdr:1},globalFog:{debug:!1,enable:!1,fogType:0,fogHeightScale:.1,start:400,end:10,density:.02,ins:.5,skyFactor:.5,skyRoughness:.4,overrideSkyFactor:.8,fogColor:new Y(96/255,117/255,133/255,1),falloff:.7,rayLength:200,scatteringExponent:2.7,dirHeightLine:10},godRay:{blendColor:!0,rayMarchCount:16,scatteringExponent:5,intensity:.5},ssao:{enable:!1,radius:.15,bias:-.1,aoPower:2,debug:!0},outline:{enable:!1,strength:1,groupCount:4,outlinePixel:2,fadeOutlinePixel:4,textureScale:1,useAddMode:!1,debug:!0},taa:{enable:!1,jitterSeedCount:8,blendFactor:.1,sharpFactor:.6,sharpPreBlurFactor:.5,temporalJitterScale:.13,debug:!0},gtao:{enable:!1,darkFactor:1,maxDistance:5,maxPixel:50,rayMarchSegment:6,multiBounce:!1,usePosFloat32:!0,blendColor:!0,debug:!0},ssr:{enable:!1,pixelRatio:1,fadeEdgeRatio:.2,rayMarchRatio:.5,fadeDistanceMin:600,fadeDistanceMax:2e3,roughnessThreshold:.5,powDotRN:.2,mixThreshold:.1,debug:!0},fxaa:{enable:!1},depthOfView:{enable:!1,iterationCount:3,pixelOffset:1,near:150,far:300}}},shadow:{enable:!0,type:"HARD",pointShadowBias:5e-4,shadowSize:2048,pointShadowSize:1024,shadowSoft:.005,shadowBound:100,shadowBias:.05,needUpdate:!0,autoUpdate:!0,updateFrameRate:2,csmMargin:.1,csmScatteringExp:.7,csmAreaScale:.4,debug:!1},gi:{enable:!1,offsetX:0,offsetY:0,offsetZ:0,probeSpace:64,probeXCount:4,probeYCount:2,probeZCount:4,probeSize:32,probeSourceTextureSize:2048,octRTMaxSize:2048,octRTSideSize:16,maxDistance:64*1.73,normalBias:.25,depthSharpness:1,hysteresis:.98,lerpHysteresis:.01,irradianceChebyshevBias:.01,rayNumber:144,irradianceDistanceBias:32,indirectIntensity:1,ddgiGamma:2.2,bounceIntensity:.025,probeRoughness:1,realTimeGI:!1,debug:!1,autoRenderProbe:!1},sky:{type:"HDRSKY",sky:null,skyExposure:1,defaultFar:65536,defaultNear:1},light:{maxLight:4096},material:{materialChannelDebug:!1,materialDebug:!1},loader:{numConcurrent:20},reflectionSetting:{reflectionProbeMaxCount:8,reflectionProbeSize:256,width:256*6,height:8*256,enable:!0}}),s(C,"renderJobs");let du=`

    #include "GlobalUniform"
    #include "GBufferStand"

    struct PickResult{
        pick_meshID:f32,
        pick_meshID2:f32,
        pick_UV:vec2<f32>,

        pick_Position:vec4<f32>,
        pick_Normal:vec4<f32>,
        pick_Tangent:vec4<f32>,

        v4:vec4<f32>,
        v5:vec4<f32>,
        v6:vec4<f32>,
        v7:vec4<f32>
    }

    @group(0) @binding(2) var<storage,read_write> outBuffer: PickResult;
    const PI = 3.1415926 ;

    @compute @workgroup_size( 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
    var result:PickResult ;
    let texSize = textureDimensions(gBufferTexture).xy;
    let screenPoint = vec2<f32>(globalUniform.mouseX/globalUniform.windowWidth,globalUniform.mouseY/globalUniform.windowHeight);

    let mouseUV = screenPoint * vec2<f32>(texSize.xy);
    let fragCoord =  vec2<i32>(i32(mouseUV.x), i32(mouseUV.y));
    var gBuffer = getGBuffer( fragCoord ) ;
    let pick_meshID = getIDFromGBuffer_i32(gBuffer);
    outBuffer.pick_meshID = f32(pick_meshID) ;
    outBuffer.pick_meshID2 = f32(pick_meshID) ;
    outBuffer.pick_Tangent = vec4<f32>(2.0,2.0,2.0,2.0) ;
    outBuffer.pick_UV = vec2<f32>(globalUniform.mouseX,globalUniform.mouseY) ;
    let wPosition = getWorldPositionFromGBuffer(gBuffer,screenPoint);
    let wNormal = getWorldNormalFromGBuffer(gBuffer);
    outBuffer.pick_Position = vec4<f32>(wPosition, 1.0) ;
    outBuffer.pick_Normal = vec4<f32>(wNormal, 1.0) ;
    }
`,fu=`
var<private>PI: f32 = 3.141592653589793;

fn Scatter( r:f32) -> vec3f
{
    return Gaussian(0.0064 * 1.414, r) * vec3f(0.233, 0.455, 0.649)
           + Gaussian(0.0484 * 1.414, r) * vec3f(0.100, 0.336, 0.344)
           + Gaussian(0.1870 * 1.414, r) * vec3f(0.118, 0.198, 0.000)
           + Gaussian(0.5670 * 1.414, r) * vec3f(0.113, 0.007, 0.007)
           + Gaussian(1.9900 * 1.414, r) * vec3f(0.358, 0.004, 0.00001)
           + Gaussian(7.4100 * 1.414, r) * vec3f(0.078, 0.00001, 0.00001);
}

fn Gaussian( v:f32 , r:f32 ) -> f32
{
    return 1.0 / sqrt(2.0 * PI * v) * exp(-(r * r) / (2.0 * v));
}

fn Integrate( cosTheta : f32 ,  skinRadius: f32 ) -> vec3f
{
    var theta = acos(cosTheta);  // theta -> the angle from lighting direction
    var totalWeights = vec3f(0.0);
    var totalLight = vec3f(0.0);

    var a = -(PI / 2.0);
    let inc = 0.05;

    while ( a <= (PI / 2.0) ) {
        var sampleAngle = theta + a;
        var diffuse = clamp(cos(sampleAngle),0.0,1.0);

        // calc distance
        var sampleDist = abs(2.0 * skinRadius * sin(a * 0.5));

        // estimated by Gaussian pdf
        var weights = Scatter(sampleDist);

        totalWeights += weights;
        totalLight += diffuse * weights;
        a += inc;
    }

    var result = vec3f(totalLight.x / totalWeights.x, totalLight.y / totalWeights.y, totalLight.z / totalWeights.z);
    return result;
}

@group(0) @binding(0) var sssMap: texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(1.0,1.0,0.0,1.0);
    // // Output to screen
    // var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    // fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    var NDotL = mix(-1.0, 1.0, f32(fragCoord.x) / 256.0) ; 
    var oneOverR = 2.0 * 1.0 / (f32((fragCoord.y + 1u)) / 256.0);  

    //Integrate Diffuse Scattering
    var diff = Integrate(NDotL, oneOverR);
    // fragColor = vec4f(diff,1.0);
    fragColor = vec4f(vec3f(diff),1.0);
    textureStore(sssMap, vec2<i32>(fragCoord.xy), fragColor);
}
`,Au=`
    #include "WorldMatrixUniform"
    struct VertexAttributes{
        @builtin(instance_index) index : u32,

        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,
        @location(auto) vIndex: f32,
        @location(auto) index2: f32,
        
    }

    struct VertexOutput {
        @location(auto) index: f32,
        @location(auto) varying_UV0: vec2<f32>,
        @location(auto) varying_UV1: vec2<f32>,
        @location(auto) varying_ViewPos: vec4<f32>,
        @location(auto) varying_Clip: vec4<f32>,
        @location(auto) varying_WPos: vec4<f32>,
        @location(auto) varying_WNormal: vec3<f32>,
        @location(auto) varying_Color: vec4<f32>,
        #if USE_SHADOWMAPING
            @location(auto) varying_ShadowPos: vec4<f32>,
        #endif
        @builtin(position) member: vec4<f32>
    };

    struct TransformVertex{
        position:vec3<f32>,
        normal:vec3<f32>,
    }

    struct GraphicNodeStruct{
        matrixIndex:f32,
        texIndex:f32,
        tex2Index:f32,
        tex3Index:f32,

        fillRotation:f32,
        empty0:f32,
        empty1:f32,
        empty2:f32,

        baseColor:vec4f,
        lineColor:vec4f,
        emissiveColor:vec4f,
        uvRect:vec4f,
        uvRect2:vec4f,
        uvSpeed:vec4f,
    }

    var<private> ORI_VertexOut: VertexOutput ;
    var<private> worldMatrix: mat4x4<f32> ;
    var<private> graphicNode: GraphicNodeStruct ;

    fn ORI_Vert(vertex:VertexAttributes){
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

        ORI_VertexOut.index = f32(vertex.vIndex) ;
        graphicNode = graphicBuffer[u32(round(vertex.vIndex))];
        let node_Matrix_M = models.matrix[u32(round(graphicNode.matrixIndex))];

        #if USE_TANGENT
            ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
        #endif

        ORI_MATRIX_M = node_Matrix_M * ORI_MATRIX_M ;

        #if USE_BILLBOARD
            let billboardMatrix: mat3x3<f32> = calculateBillboardMatrix2(globalUniform.CameraPos.xyz,ORI_MATRIX_M[3].xyz,globalUniform.cameraWorldMatrix[1].xyz);
            vertexPosition = billboardMatrix * vertexPosition.xyz;
        #endif

        worldMatrix = ORI_MATRIX_M ;

        let nMat = mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ;
        ORI_NORMALMATRIX = transpose(inverse( nMat ));

        var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));

        #if TRANSFORMVERTEX
            var transformVertex = transformVertex(worldPos.xyz,vertexNormal,vertex);
            worldPos = vec4<f32>(transformVertex.position ,worldPos.w);
            vertexNormal = transformVertex.normal ;
        #endif

        var viewPosition = ORI_MATRIX_V * worldPos;
        var clipPosition = ORI_MATRIX_P * viewPosition ;

        ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
        ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
        ORI_VertexOut.varying_ViewPos = viewPosition ;
        ORI_VertexOut.varying_Clip = clipPosition;
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_WNormal = normalize( vertexNormal.xyz);
        ORI_VertexOut.member = clipPosition ;
    }
`,gu=`
    #include "Common_vert"
    #include "Common_frag"
    #include "Hair_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var idMapSampler: sampler;
    @group(1) @binding(auto)
    var idMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var depthMapSampler: sampler;
    @group(1) @binding(auto)
    var depthMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var rootMapSampler: sampler;
    @group(1) @binding(auto)
    var rootMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var alphaMapSampler: sampler;
    @group(1) @binding(auto)
    var alphaMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,

      baseColor0: vec4<f32>,
      baseColor1: vec4<f32>,
      emissiveColor: vec4<f32>,
      materialF0: vec4<f32>,
      specularColor: vec4<f32>,
      envIntensity: f32,
      normalScale: f32,
      roughness: f32,
      metallic: f32,

      ao: f32,
      roughness_min: f32,
      roughness_max: f32,
      metallic_min: f32,

      metallic_max: f32,
      emissiveIntensity: f32,
      alphaCutoff: f32,
      ior: f32,

      backlit: f32,
      area: f32,
    };
#endif
    
    var<private> debugOut : vec4f = vec4f(0.0) ;
    var<private> uv : vec2f = vec2f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;
        uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        ORI_ShadingInput.Roughness = materialUniform.roughness;
        ORI_ShadingInput.Metallic = materialUniform.metallic;
        

        #if USE_HAIRCOLOR
            let root = textureSample(rootMap, rootMapSampler, uv ).r ;
            ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
        #else
            #if USE_SRGB_ALBEDO
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #else 
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #endif
        #endif

        fragData.Alpha = 1.0 ;
        #if USE_ALPHA_A
        // fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
            // let shake = (globalUniform.frame % 5.0) / 5.0 * 2.0 ;
            fragData.Alpha =  textureSample(alphaMap, alphaMapSampler, uv ).r ;
        #endif

        #if USE_ALPHACUT 
            if( (fragData.Alpha - materialUniform.alphaCutoff) < 0.0 ){
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif
                discard;
            }
        #endif

        useShadow();

        ORI_ShadingInput.Specular = 1.0 ;

        let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
        var hairNormal = HairNormal(idMap.r).rgb ;
        hairNormal = transformHairNormal( hairNormal) ;  
        ORI_ShadingInput.HairNormal = hairNormal ;

        ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

        ORI_ShadingInput.BaseColor.a = fragData.Alpha;
        
        BSSSRDFShading();
    }
`,pu=`
#include "Common_vert"
#include "Common_frag"
#include "Hair_frag"

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var idMapSampler: sampler;
@group(1) @binding(auto)
var idMap: texture_2d<f32>;

@group(1) @binding(auto)
var depthMapSampler: sampler;
@group(1) @binding(auto)
var depthMap: texture_2d<f32>;

@group(1) @binding(auto)
var rootMapSampler: sampler;
@group(1) @binding(auto)
var rootMap: texture_2d<f32>;

@group(1) @binding(auto)
var alphaMapSampler: sampler;
@group(1) @binding(auto)
var alphaMap: texture_2d<f32>;

#if USE_CUSTOMUNIFORM
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,

  baseColor0: vec4<f32>,
  baseColor1: vec4<f32>,
  emissiveColor: vec4<f32>,
  materialF0: vec4<f32>,
  specularColor: vec4<f32>,
  envIntensity: f32,
  normalScale: f32,
  roughness: f32,
  metallic: f32,

  ao: f32,
  roughness_min: f32,
  roughness_max: f32,
  metallic_min: f32,

  metallic_max: f32,
  emissiveIntensity: f32,
  alphaCutoff: f32,
  ior: f32,

  backlit: f32,
  area: f32,
};
#endif

var<private> debugOut : vec4f = vec4f(0.0) ;
var<private> uv : vec2f = vec2f(0.0) ;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

fn frag(){
    var transformUV1 = materialUniform.transformUV1;
    var transformUV2 = materialUniform.transformUV2;
    uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

    ORI_ShadingInput.Roughness = materialUniform.roughness;
    ORI_ShadingInput.Metallic = materialUniform.metallic;

    #if USE_HAIRCOLOR
        let root = textureSample(rootMap, rootMapSampler, uv ).r ;
        ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
    #else
        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #else 
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #endif
    #endif

    fragData.Alpha = 1.0 ;
    #if USE_ALPHA_A
        fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
    #endif

    #if USE_ALPHACUT 
        if( (((1.0 - fragData.Alpha) - (1.0 - materialUniform.alphaCutoff))) < 0.0 ){
            #if USEGBUFFER
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
            #endif
            discard;
        }
    #endif

    #if USE_SHADOWMAPING
        useShadow();
    #endif

    ORI_ShadingInput.Specular = 1.0 ;

    let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
    var hairNormal = HairNormal(idMap.r).rgb ;
    hairNormal = transformHairNormal( hairNormal) ;  
    ORI_ShadingInput.HairNormal = hairNormal ;

    ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

    ORI_ShadingInput.BaseColor.a = fragData.Alpha;
    
    BSSSRDFShading();
}
`,mu=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BsDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
          transformUV1:vec4<f32>,
          transformUV2:vec4<f32>,

          baseColor: vec4<f32>,
          emissiveColor: vec4<f32>,
          materialF0: vec4<f32>,
          specularColor: vec4<f32>,
          envIntensity: f32,
          normalScale: f32,
          roughness: f32,
          metallic: f32,

          ao: f32,
          roughness_min: f32,
          roughness_max: f32,
          metallic_min: f32,

          metallic_max: f32,
          emissiveIntensity: f32,
          alphaCutoff: f32,
          ior: f32,

          clearcoatColor: vec4<f32>,

          clearcoatWeight: f32,
          clearcoatFactor: f32,
          clearcoatRoughnessFactor: f32,
          skinPower: f32,
          
          skinColor: vec4<f32>,
          skinColorIns: f32,
          curveFactor: f32,
        };
    #endif
    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var sssMapSampler: sampler;
    @group(1) @binding(auto)
    var sssMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var lutMapSampler: sampler;
    @group(1) @binding(auto)
    var lutMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #endif

        var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
            ORI_ShadingInput.BaseColor =  vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                discard;
            }
        #endif

        useShadow();

        // maskTex =vec4f( gammaToLiner(maskTex.rgb), maskTex.a );

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    
        ORI_ShadingInput.Metallic = metallicChannel * metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            var aoMap = textureSample(aoMap, aoMapSampler, uv );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        // ORI_ShadingInput.BaseColor.a = maskTex.a ;

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;

        ORI_ShadingInput.Specular = 1.0 ;

        var emissiveColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;

        emissiveColor = vec4<f32>(gammaToLiner(emissiveColor.rgb),emissiveColor.w);

        ORI_ShadingInput.EmissiveColor = vec4<f32>(materialUniform.emissiveColor.rgb * emissiveColor.rgb * materialUniform.emissiveIntensity,1.0);

     

        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;

        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        
        ORI_ShadingInput.Normal = normal ;

        var sssColor = vec3f(pow(textureSample(sssMap, sssMapSampler, uv ).r,materialUniform.skinPower)) * materialUniform.skinColor.rgb ;
        let sunLight = lightBuffer[0] ;
        let sunLightIntensity = (sunLight.intensity )  ;
        let ndl = 1.0 - clamp(dot(normalize(normal),-normalize(sunLight.direction)),0.0,1.0) * 0.5 + 0.5 ;//1.0 - saturate( dot(normalize(normal),normalize(sunLight.direction)) ) * 0.5 + 0.5 ;
        ORI_ShadingInput.SSS += 0.5 * vec3f(sssColor * sunLightIntensity * materialUniform.skinColorIns * ndl * sunLight.lightColor.rgb ) ;
     
        var curve = clamp(materialUniform.curveFactor * (length(fwidth(ORI_ShadingInput.Normal.xyz)) / length(fwidth(ORI_VertexVarying.vWorldPos.xyz*100.0))),0.0,1.0);
        var NDotL = dot(ORI_ShadingInput.Normal, -sunLight.direction );
        var sssColor2 = textureSample(lutMap, lutMapSampler ,vec2f(NDotL * 0.5 + 0.5, materialUniform.curveFactor * sssColor.r)).rgb * sunLight.lightColor.rgb * sunLightIntensity ;
        ORI_ShadingInput.SSS = sssColor2.rgb * ORI_ShadingInput.BaseColor.rgb ;
     
        BsDFShading();

        // ORI_FragmentOutput.color = vec4f(vec3f(0.5*ORI_ShadingInput.SSS),1.0)  ;
    }
`,Uu=`
    // #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #include "WorldMatrixUniform"
    #include "VertexAttributeIndexShader"
    #include "GlobalUniform"
    #include "Inline_vert"
    #include "EnvMap_frag"
    #include "ColorUtil_frag"

    const DEGREES_TO_RADIANS : f32 = 3.1415926 / 180.0 ;
    const PI : f32 = 3.1415926 ;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array<f32>;

    @group(2) @binding(5)
    var<storage,read> graphicBuffer : array<GraphicNodeStruct>;
    
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        // var irradiance = vec3<f32>(0.0) ;
        // let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, ORI_VertexVarying.vWorldNormal.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);

        graphicNode = graphicBuffer[u32(round(ORI_VertexVarying.index))];
        
        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy;
        //The fragUV1.x is 1.0 when the vertex belongs to line.
        if(ORI_VertexVarying.fragUV1.x > 0.5){
            uv = graphicNode.uvRect2.zw * uv.xy + graphicNode.uvRect2.xy;
            uv += graphicNode.uvSpeed.zw * globalUniform.time;
        }else{
            uv = graphicNode.uvRect.zw * uv.xy + graphicNode.uvRect.xy;
            uv += graphicNode.uvSpeed.xy * globalUniform.time;
            let rad = graphicNode.fillRotation;
            if(rad != 0.0){
                let zrot = mat3x3<f32>(
                    cos(rad),-sin(rad),0.0,
                    sin(rad), cos(rad),0.0,
                    0.0,0.0,1.0
                );
                uv = (zrot * vec3f(uv, 0.0)).xy;
            }
        }
        var graphicTextureID = graphicNode.texIndex;
        var graphicNodeColor = graphicNode.baseColor;
        if(ORI_VertexVarying.fragUV1.x > 0.5){
            graphicTextureID = graphicNode.tex2Index;
            graphicNodeColor = graphicNode.lineColor;
        }
        var color = textureSample(baseMap,baseMapSampler,uv, u32(round(graphicTextureID)) ) * materialUniform.baseColor * graphicNodeColor ;
        // let color = textureSample(baseMap,baseMapSampler,uv, u32(round(ORI_VertexVarying.index)));

        // ORI_ViewDir = normalize( globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz);
        // let att = dot( ORI_ViewDir , ORI_VertexVarying.vWorldNormal.xyz );

        // irradiance = LinearToGammaSpace(irradiance.rgb) * color.rgb ;//* att ;

        color += graphicNode.emissiveColor ;
        if(color.w < materialUniform.alphaCutoff){
            discard ;
        }

        // let outColor = vec4f( color.rgb * (att * 0.5 + 0.5 ) , 1.0 ) * materialUniform.baseColor ;
        let outColor = vec4f( color.rgb , 1.0 ) * materialUniform.baseColor ;
        
        // ORI_ShadingInput.BaseColor = color  ;
        ORI_ShadingInput.BaseColor = vec4f(outColor.xyz,1.0)  ;
        UnLit();
    }
`;class En{}s(En,"cs",`
    #include 'ColorUtil_frag'
    struct UniformData {
        width: f32,
        height: f32,
        sunU: f32,
        sunV: f32,
        eyePos: f32,
        sunRadius: f32,         // = 500.0;
        sunRadiance: f32,       // = 20.0;
        mieG: f32,              // = 0.76;
        mieHeight: f32,         // = 1200;
        sunBrightness: f32,     // = 1.0;
        displaySun: f32,        // > 0.5: true
        skyColor: vec4<f32>,        // sky color
      };

      @group(0) @binding(0) var<uniform> uniformBuffer: UniformData;
      @group(0) @binding(1) var outTexture : texture_storage_2d<rgba16float, write>;

      var<private> uv01: vec2<f32>;
      var<private> fragCoord: vec2<i32>;
      var<private> texSizeF32: vec2<f32>;

      var<private> PI:f32 = 3.1415926535;
      var<private> PI_2:f32 = 0.0;
      var<private> EPSILON:f32 = 0.0000001;
      var<private> SAMPLES_NUMS:i32 = 16;

      var<private> transmittance:vec3<f32>;
      var<private> insctrMie:vec3<f32>;
      var<private> insctrRayleigh:vec3<f32>;

      @compute @workgroup_size( 8 , 8 , 1 )
      fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
      {
        fragCoord = vec2<i32>(globalInvocation_id.xy);
        texSizeF32 = vec2<f32>( uniformBuffer.width, uniformBuffer.height);
        uv01 = vec2<f32>(globalInvocation_id.xy) / texSizeF32;
        uv01.y = 1.0 - uv01.y - EPSILON;
        PI_2 = PI * 2.0;
        textureStore(outTexture, fragCoord , mainImage(uv01));//vec4(uv01, 0.0, 1.0));
      }

      struct ScatteringParams
      {
        sunRadius:f32,
        sunRadiance:f32,

        mieG:f32,
        mieHeight:f32,

        rayleighHeight:f32,

        waveLambdaMie:vec3<f32>,
        waveLambdaOzone:vec3<f32>,
        waveLambdaRayleigh:vec3<f32>,

        earthRadius:f32,
        earthAtmTopRadius:f32,
        earthCenter:vec3<f32>,
      }

      fn ComputeSphereNormal(coord:vec2<f32>, phiStart:f32, phiLength:f32, thetaStart:f32, thetaLength:f32) -> vec3<f32>
      {
        var normal:vec3<f32>;
        normal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);
        normal.y = -cos(thetaStart + coord.y * thetaLength);
        normal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);
        return normalize(normal);
      }

      fn ComputeRaySphereIntersection(position:vec3<f32>, dir:vec3<f32>, center:vec3<f32>, radius:f32) -> vec2<f32>
      {
        var origin:vec3<f32> = position - center;
        var B = dot(origin, dir);
        var C = dot(origin, origin) - radius * radius;
        var D = B * B - C;

        var minimaxIntersections:vec2<f32>;
        if (D < 0.0)
        {
          minimaxIntersections = vec2<f32>(-1.0, -1.0);
        }
        else
        {
          D = sqrt(D);
          minimaxIntersections = vec2<f32>(-B - D, -B + D);
        }

        return minimaxIntersections;
      }

      fn ComputeWaveLambdaRayleigh(lambda: vec3<f32>) -> vec3<f32>
      {
        var n:f32 = 1.0003;
        var N:f32 = 2.545E25;
        var pn:f32 = 0.035;
        var n2:f32 = n * n;
        var pi3:f32 = PI * PI * PI;
        var rayleighConst:f32 = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));
        return vec3<f32>(rayleighConst) / (lambda * lambda * lambda * lambda);
      }

      fn ComputePhaseMie(theta: f32, g:f32) -> f32
      {
        var g2 = g * g;
        return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);
      }

      fn ComputePhaseRayleigh(theta: f32) -> f32
      {
        var theta2 = theta * theta;
        return (theta2 * 0.75 + 0.75) / (4.0 * PI);
      }

      fn ChapmanApproximation(X: f32, h: f32, cosZenith: f32) -> f32
      {
        var c = sqrt(X + h);
        var c_exp_h = c * exp(-h);

        if (cosZenith >= 0.0)
        {
          return c_exp_h / (c * cosZenith + 1.0);
        }
        else
        {
          var x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);
          var c0 = sqrt(x0);

          return 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);
        }
      }

      fn GetOpticalDepthSchueler(h: f32, H: f32, earthRadius: f32, cosZenith: f32) -> f32
      {
        return H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);
      }

      fn GetTransmittance(setting: ScatteringParams, L:vec3<f32>, V: vec3<f32>) -> vec3<f32>
      {
        var ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);
        return exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);
      }

      fn ComputeOpticalDepth(setting: ScatteringParams, samplePoint: vec3<f32>, V: vec3<f32>, L: vec3<f32>, neg: f32) -> vec2<f32>
      {
        var rl = length(samplePoint);
        var h = rl - setting.earthRadius;
        var r: vec3<f32> = samplePoint / rl;

        var cos_chi_sun = dot(r, L);
        var cos_chi_ray = dot(r, V * neg);

        var opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);
        var opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;

        return vec2<f32>(opticalDepthSun, opticalDepthCamera);
      }

      fn AerialPerspective(setting:ScatteringParams, start: vec3<f32>, end: vec3<f32>, V: vec3<f32>, L: vec3<f32>, infinite:i32)
      {
        var inf_neg:f32 = 1.0;
        if( infinite == 0){
          inf_neg = -1.0;
        }

        var sampleStep: vec3<f32> = (end - start) / f32(SAMPLES_NUMS);
        var samplePoint: vec3<f32> = end - sampleStep;
        var sampleLambda: vec3<f32> = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;

        var sampleLength:f32 = length(sampleStep);

        var scattering:vec3<f32> = vec3<f32>(0.0);
        var lastOpticalDepth:vec2<f32> = ComputeOpticalDepth(setting, end, V, L, inf_neg);

        for (var i:i32 = 1; i < SAMPLES_NUMS; i = i + 1)
        {
          var opticalDepth: vec2<f32> = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);

          var segment_s: vec3<f32> = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));
          var segment_t: vec3<f32> = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));

          transmittance *= segment_t;

          scattering = scattering * segment_t;
          scattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;

          lastOpticalDepth = opticalDepth;
          samplePoint = samplePoint - sampleStep;
        }

        insctrMie = scattering * setting.waveLambdaMie * sampleLength;
        insctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;
      }

      fn ComputeSkyboxChapman(setting: ScatteringParams, eye:vec3<f32>, V:vec3<f32>, L:vec3<f32>) -> f32
      {
        var neg:i32 = 1;
        var outerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
        if (outerIntersections.y < 0.0){
          return 0.0;
        }
        var innerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
        if (innerIntersections.x > 0.0)
        {
          neg = 0;
          outerIntersections.y = innerIntersections.x;
        }

        let eye0 = eye - setting.earthCenter;

        var start : vec3<f32> = eye0 + V * max(0.0, outerIntersections.x);
        var end : vec3<f32>= eye0 + V * outerIntersections.y;

        AerialPerspective(setting, start, end, V, L, neg);

        //bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;
        //return intersectionTest ? 1.0 : 0.0;

        if(innerIntersections.x < 0.0 && innerIntersections.y < 0.0){
          return 1.0;
        }
        return 0.0;
      }

      fn ComputeSkyInscattering(setting: ScatteringParams, eye: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> vec4<f32>
      {
        transmittance = vec3<f32>(1.0);
        insctrMie = vec3<f32>(0.0);
        insctrRayleigh = vec3<f32>(0.0);
        var intersectionTest:f32 = ComputeSkyboxChapman(setting, eye, V, L);

        var phaseTheta = dot(V, L);
        var phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
        var phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
        var phaseNight = 1.0 - saturate(transmittance.x * EPSILON);

        var insctrTotalMie: vec3<f32> = insctrMie * phaseMie;
        var insctrTotalRayleigh: vec3<f32> = insctrRayleigh * phaseRayleigh;

        var sky: vec3<f32> = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;
        if(uniformBuffer.displaySun > 0.5){
          var angle:f32 = clamp((1.0 - phaseTheta) * setting.sunRadius, 0.0000001, 0.9999999);
          var cosAngle:f32 = cos(angle * PI * 0.5);
          var edge:f32 = 0.0;
          if(angle >= 0.9){
            edge = smoothstep(0.9, 1.0, angle);
          }

          var limbDarkening: vec3<f32> = GetTransmittance(setting, -L, V);
          limbDarkening *= pow(vec3<f32>(cosAngle), vec3<f32>(0.420, 0.503, 0.652)) * mix(vec3<f32>(1.0), vec3<f32>(1.2,0.9,0.5), edge) * intersectionTest;
          sky += limbDarkening * uniformBuffer.sunBrightness; 
        }
        return vec4<f32>(sky, phaseNight * intersectionTest);
      }

      fn TonemapACES(x: vec3<f32>) -> vec3<f32>
      {
        var A:f32 = 2.51f;
        var B:f32 = 0.03f;
        var C:f32 = 2.43f;
        var D:f32 = 0.59f;
        var E:f32 = 0.14f;
        return (x * (A * x + B)) / (x * (C * x + D) + E);
      }

      fn noise(uv:vec2<f32>) -> f32
      {
        return fract(dot(sin(vec3<f32>(uv.xyx) * vec3<f32>(uv.xyy) * 1024.0), vec3<f32>(341896.483, 891618.637, 602649.7031)));
      }

      fn mainImage( uv:vec2<f32> ) -> vec4<f32>
      {
        let eyePosition = uniformBuffer.eyePos;
        var sun = vec2<f32>(uniformBuffer.sunU, uniformBuffer.sunV);
        var V: vec3<f32> = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);
        var L: vec3<f32> = ComputeSphereNormal(vec2<f32>(sun.x, sun.y), 0.0, PI_2, 0.0, PI);

        var setting: ScatteringParams;
        setting.sunRadius = uniformBuffer.sunRadius;//500.0;
        setting.sunRadiance = uniformBuffer.sunRadiance;//20.0;
        setting.mieG = uniformBuffer.mieG;//0.76;
        setting.mieHeight = uniformBuffer.mieHeight;// 1200.0;
        setting.rayleighHeight = 8000.0;
        setting.earthRadius = 6360000.0;
        setting.earthAtmTopRadius = 6420000.0;
        setting.earthCenter = vec3<f32>(0, -setting.earthRadius, 0);
        setting.waveLambdaMie = vec3<f32>(0.0000002);

        // wavelength with 680nm, 550nm, 450nm
        setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(vec3<f32>(0.000000680, 0.000000550, 0.000000450));

        // see https://www.shadertoy.com/view/MllBR2
        setting.waveLambdaOzone = vec3<f32>(1.36820899679147, 3.31405330400124, 0.13601728252538)* 0.0000006 * 2.504;

        var eye:vec3<f32> = vec3<f32>(0,eyePosition,0);
        var sky0:vec4<f32> = ComputeSkyInscattering(setting, eye, V, L);
        var sky = vec3<f32>(sky0.rgb);

        sky = TonemapACES(sky.rgb * 2.0);
        sky = pow(sky.rgb, vec3<f32>(1.0/1.2)); // gamma

        var fragColor:vec4<f32> = vec4<f32>((sky.rgb), 1.0);
        return fragColor;
      }
    `);class Bu{constructor(){s(this,"sunRadius",500);s(this,"sunRadiance",11);s(this,"mieG",.76);s(this,"mieHeight",1200);s(this,"eyePos",1500);s(this,"sunX",.71);s(this,"sunY",.56);s(this,"sunBrightness",1);s(this,"displaySun",!0);s(this,"defaultTextureCubeSize",512);s(this,"defaultTexture2DSize",1024);s(this,"skyColor",new Y(1,1,1,1))}}class Fu extends Sn{constructor(e){super();s(this,"_internalTexture");s(this,"_cubeSize");s(this,"setting");return this.setting=e,this._cubeSize=e.defaultTextureCubeSize,this._internalTexture=new Cu(e.defaultTexture2DSize,e.defaultTexture2DSize*.5),this._internalTexture.update(this.setting),this.createFromTexture(this._cubeSize,this._internalTexture),this}get texture2D(){return this._internalTexture}apply(){return this._internalTexture.update(this.setting),this._faceData.uploadErpTexture(this._internalTexture),this}}class Cu extends _t{constructor(e,r){super(e,r,H.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);s(this,"_computeShader");s(this,"_uniformBuffer");this.initCompute(e,r)}initCompute(e,r){this._uniformBuffer=new aa(16*4),this._uniformBuffer.apply(),this._computeShader=new bt(En.cs),this._computeShader.setUniformBuffer("uniformBuffer",this._uniformBuffer),this._computeShader.setStorageTexture("outTexture",this),this._computeShader.workerSizeX=e/8,this._computeShader.workerSizeY=r/8}update(e){this._uniformBuffer.setFloat("width",this.width),this._uniformBuffer.setFloat("height",this.height),this._uniformBuffer.setFloat("sunU",e.sunX),this._uniformBuffer.setFloat("sunV",e.sunY),this._uniformBuffer.setFloat("eyePos",e.eyePos),this._uniformBuffer.setFloat("sunRadius",e.sunRadius),this._uniformBuffer.setFloat("sunRadiance",e.sunRadiance),this._uniformBuffer.setFloat("mieG",e.mieG),this._uniformBuffer.setFloat("mieHeight",e.mieHeight),this._uniformBuffer.setFloat("sunBrightness",e.sunBrightness),this._uniformBuffer.setFloat("displaySun",e.displaySun?1:0),this._uniformBuffer.setColor("skyColor",e.skyColor),this._uniformBuffer.apply();let r=S.beginCommandEncoder();return S.computeCommand(r,[this._computeShader]),S.endCommandEncoder(r),this}}var Qu=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let Mi=class extends Ct{constructor(){super();let n=new _e("sky_vs_frag_wgsl","sky_fs_frag_wgsl");this.addRenderPass(n),n.setUniformVector3("eyesPos",new g),n.setUniformFloat("exposure",1),n.setUniformFloat("roughness",0);let t=n.shaderState;t.frontFace="ccw",t.cullMode=nt.front,t.depthWriteEnabled=!1,t.depthCompare=tr.less_equal}};Mi=Qu([Mr],Mi);class vu extends Fr{constructor(){super(),this.shader=new Mi,this.shader.setUniformVector3("eyesPos",new g),this.shader.setUniformFloat("exposure",1),this.shader.setUniformFloat("roughness",0)}set baseMap(t){this.setTexture("baseMap",t);const e="IS_HDR_SKY";this._shader.getDefaultShaders()[0].defineValue[e]!=(t==null?void 0:t.isHDRTexture)&&this._shader.setDefine(e,!!(t!=null&&t.isHDRTexture))}get baseMap(){return this._shader.getDefaultColorShader().getTexture("baseMap")}set envMap(t){}set shadowMap(t){}get exposure(){return C.setting.sky.skyExposure}set exposure(t){C.setting.sky.skyExposure=t}get roughness(){return this._shader.getDefaultColorShader().uniforms.roughness.value}set roughness(t){let e=this._shader.getDefaultColorShader();"roughness"in e.uniforms&&(e.uniforms.roughness.value=t)}}class yn extends ar{constructor(e,r,a,i,o,l,h){super();s(this,"shape_vertices",[]);s(this,"shape_indices",[]);s(this,"radius");s(this,"widthSegments");s(this,"heightSegments");s(this,"phiStart");s(this,"phiLength");s(this,"thetaStart");s(this,"thetaLength");this.radius=e,this.widthSegments=r,this.heightSegments=a,this.phiStart=i,this.phiLength=o,this.thetaStart=l,this.thetaLength=h,this.buildGeometry()}buildGeometry(){var e,r,a=0;let i=this.heightSegments,o=this.widthSegments,l=this.radius;var h=(i+1)*(o+1);let c=new Float32Array(h*3),u=new Float32Array(h*3),d=new Float32Array(h*2),f=new Uint16Array(o*i*2*3),A=0,p=0,B=0;for(r=0;r<=i;++r){var F=Math.PI*r/i,U=l*Math.cos(F),Q=l*Math.sin(F);for(e=0;e<=o;++e){var y=2*Math.PI*e/o,b=Q*Math.cos(y),x=Q*Math.sin(y),w=1/Math.sqrt(b*b+U*U+x*x);if(c[A++]=b,c[A++]=U,c[A++]=x,u[p++]=b*w,u[p++]=U*w,u[p++]=x*w,d[B++]=e/o,d[B++]=r/i,e>0&&r>0){var D=(o+1)*r+e,O=(o+1)*r+e-1,L=(o+1)*(r-1)+e-1,$=(o+1)*(r-1)+e;r==i?(f[a++]=D,f[a++]=L,f[a++]=$):r==1?(f[a++]=D,f[a++]=O,f[a++]=L):(f[a++]=D,f[a++]=O,f[a++]=L,f[a++]=D,f[a++]=L,f[a++]=$)}}}this.setIndices(f),this.setAttribute(k.position,c),this.setAttribute(k.normal,u),this.setAttribute(k.uv,d),this.setAttribute(k.TEXCOORD_1,d),this.addSubGeometry({indexStart:0,indexCount:f.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0}),this.bounds=new Pe(g.ZERO,new g(this.radius*2,this.radius*2,this.radius*2))}}class Su extends da{constructor(){super(...arguments);s(this,"gid",0);s(this,"needUpdate",!0);s(this,"autoUpdate",!1);s(this,"radius",500)}init(){super.init(),this.addRendererMask(de.Reflection),this.alwaysRender=!0,this.object3D.bound=new Pe(g.ZERO.clone(),g.MAX),$s(this.transform.onPositionChange,()=>{this.needUpdate=!0})}onEnable(){P.instance.addRenderNode(this.transform.scene3D,this)}onDisable(){P.instance.removeRenderNode(this.transform.scene3D,this)}renderPass2(e,r,a,i,o,l=!1){super.renderPass2(e,r,a,i,o,l)}}class Ru extends Ct{constructor(){super();let t=new _e("ReflectionShader_shader","ReflectionShader_shader");t.setShaderEntry("VertMain","FragMain"),this.addRenderPass(t);let e=t.shaderState;e.acceptShadow=!1,e.castShadow=!1,e.receiveEnv=!1,e.acceptGI=!1,e.useLight=!1,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformVector4("transformUV1",new j(0,0,1,1)),this.setUniformVector4("transformUV2",new j(0,0,1,1)),this.setUniformColor("baseColor",new Y),this.setUniformFloat("alphaCutoff",0)}set _MainTex(t){this.setTexture("baseMap",t)}set _BumpMap(t){this.setTexture("normalMap",t)}set _MaskTex(t){this.setTexture("maskMap",t)}set _UVTransform(t){this.setUniformVector4("transformUV1",t)}set _Metallic(t){this.setUniformFloat("metallic",t)}set _Roughness(t){this.setUniformFloat("roughness",t)}set _MainColor(t){this.setUniformColor("baseColor",t)}set _AlphaCutoff(t){this.setUniformFloat("alphaCutoff",t)}set _DoubleSidedEnable(t){let e=this.getDefaultColorShader();e.shaderState.cullMode=t?nt.none:e.shaderState.cullMode}set _SurfaceType(t){let e=this.getDefaultColorShader();t==0?e.blendMode=q.NONE:e.blendMode=q.ALPHA}set _AlphaCutoffEnable(t){t==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}}class Eu extends Fr{constructor(){super(),this.shader=new Ru,this.baseMap=C.res.whiteTexture,this.setDefine("USE_CUSTOMUNIFORM",!0),this.reflectionIndex=0}set baseMap(t){this.shader.setTexture("baseMap",t)}get baseMap(){return this.shader.getTexture("baseMap")}set baseColor(t){this.shader.setUniformColor("baseColor",t)}set reflectionIndex(t){this.shader.setUniformFloat("reflectionIndex",t)}get baseColor(){return this.shader.getUniformColor("baseColor")}set envMap(t){}set shadowMap(t){}}class qi{constructor(t,e){s(this,"center",new g);s(this,"extents");s(this,"max");s(this,"min");s(this,"size");s(this,"tmpVecA",new g);s(this,"tmpVecB",new g);s(this,"tmpVecC",new g);s(this,"tmpVecD",new g);s(this,"radius",0);s(this,"diffBetweenPoints",new g);s(this,"owner");s(this,"forward",new g(0,0,1));s(this,"worldCenter");s(this,"worldSize");s(this,"_center",new g);this.center=t||new g(0,0,0),this.radius=e===void 0?.5:e}updateBound(){throw new Error("Method not implemented.")}containsPoint(t){var e=this.tmpVecA.subtract(t,this.center).lengthSquared,r=this.radius;return e<r*r}intersectsRay(t,e){var r=this.tmpVecA.copyFrom(t.origin).subtract(this.center),a=r.dotProduct(this.tmpVecB.copyFrom(t.direction).normalize()),i=r.dotProduct(r)-this.radius*this.radius;if(i>0&&a>0)return null;var o=a*a-i;if(o<0)return!1;var l=Math.abs(-a-Math.sqrt(o));return e&&e.copyFrom(t.direction).scaleBy(l).add(t.origin),!0}intersectsBoundingSphere(t){this.tmpVecA.subtract(t.center,this.center);var e=t.radius+this.radius;return this.tmpVecA.lengthSquared<=e*e}calculateTransform(t){this.update(t)}inFrustum(t,e){return e.containsSphere(t)}clone(){return new qi(this.center.clone(),this.radius)}update(t){this.owner=t,this._center.add(t.transform.worldMatrix.position,this.center),this.forward=t.transform.forward}merge(t){throw new Error("BoundingSphere merge is not ready!")}setFromCenterAndSize(t,e){this.center.copy(t),this.radius=e}}class yu extends Su{init(){super.init(),this.castShadow=!1,this.castGI=!1,this.addRendererMask(de.Reflection),this.alwaysRender=!0,this.object3D.bound=new qi(g.ZERO.clone(),this.radius)}debug(t,e=1){let r=new ie,a=r.addComponent(Be);a.addMask(de.ReflectionDebug),a.geometry=new yn(25,30,30);let i=C.setting.reflectionSetting,o=Le.getGBufferFrame(Le.reflections_GBuffer,i.width,i.height),l=new Eu;l.reflectionIndex=t,l.baseMap=o.getCompressGBufferTexture(),a.material=l,this.object3D.addChild(r),r.scaleX=e,r.scaleY=e,r.scaleZ=e}onEnable(){super.onEnable()}onDisable(){super.onDisable()}renderPass2(t,e,r,a,i,o=!1){super.renderPass2(t,e,r,a,i,o)}}class Iu extends Be{constructor(){super(...arguments);s(this,"skyMaterial")}init(){super.init(),this.castShadow=!1,this.castGI=!0,this.addRendererMask(de.Sky),this.alwaysRender=!0,this.object3D.bound=new Pe(g.ZERO.clone(),g.MAX),this.geometry=new yn(C.setting.sky.defaultFar,20,20),this.skyMaterial||(this.skyMaterial=new vu)}onEnable(){this._readyPipeline?(this.castNeedPass(),!this._inRenderer&&this.transform.scene3D&&(P.instance.sky=this,this._inRenderer=!0)):this.initPipeline()}onDisable(){this._inRenderer&&this.transform.scene3D&&(this._inRenderer=!1,P.instance.sky=null),super.onDisable()}nodeUpdate(e,r,a,i){super.nodeUpdate(e,r,a,i)}renderPass2(e,r,a,i,o,l=!1){super.renderPass2(e,r,a,i,o,l)}set map(e){this.skyMaterial.baseMap=e,this.skyMaterial.name==null&&(this.skyMaterial.name="skyMaterial"),this.material=this.skyMaterial}get map(){return this.skyMaterial.baseMap}get exposure(){return this.skyMaterial.exposure}set exposure(e){this.skyMaterial&&(this.skyMaterial.exposure=e)}get roughness(){return this.skyMaterial.roughness}set roughness(e){this.skyMaterial&&(this.skyMaterial.roughness=e)}useSkyReflection(){let e=new ie,r=e.addComponent(yu);r.autoUpdate=!1,e.x=0,e.y=300,e.z=0,this.object3D.addChild(e)}}class xu{constructor(){s(this,"rotateX");s(this,"rotateY");s(this,"sunX");s(this,"sunY");this.reset()}reset(){return this.rotateX=this.rotateY=this.sunX=this.sunY=Number.MAX_VALUE,this}isRotateChange(t,e){return Math.abs(this.rotateX-t)>=.001||Math.abs(this.rotateY-e)>=.001}isSkyChange(t,e){return Math.abs(this.sunX-t)>=.001||Math.abs(this.sunY-e)>=.001}save(t,e,r,a){return this.sunX=t,this.sunY=e,this.rotateX=r,this.rotateY=a,this}}class bu extends Iu{constructor(){super(...arguments);s(this,"_atmosphericScatteringSky");s(this,"_onChange",!0);s(this,"_relatedTransform");s(this,"_historyData")}get sunX(){return this._atmosphericScatteringSky.setting.sunX}set sunX(e){this._atmosphericScatteringSky.setting.sunX!=e&&(this._atmosphericScatteringSky.setting.sunX=e,this._onChange=!0)}get sunY(){return this._atmosphericScatteringSky.setting.sunY}set sunY(e){this._atmosphericScatteringSky.setting.sunY!=e&&(this._atmosphericScatteringSky.setting.sunY=e,this._onChange=!0)}get eyePos(){return this._atmosphericScatteringSky.setting.eyePos}set eyePos(e){this._atmosphericScatteringSky.setting.eyePos!=e&&(this._atmosphericScatteringSky.setting.eyePos=e,this._onChange=!0)}get sunRadius(){return this._atmosphericScatteringSky.setting.sunRadius}set sunRadius(e){this._atmosphericScatteringSky.setting.sunRadius!=e&&(this._atmosphericScatteringSky.setting.sunRadius=e,this._onChange=!0)}get sunRadiance(){return this._atmosphericScatteringSky.setting.sunRadiance}set sunRadiance(e){this._atmosphericScatteringSky.setting.sunRadiance!=e&&(this._atmosphericScatteringSky.setting.sunRadiance=e,this._onChange=!0)}get sunBrightness(){return this._atmosphericScatteringSky.setting.sunBrightness}set sunBrightness(e){this._atmosphericScatteringSky.setting.sunBrightness!=e&&(this._atmosphericScatteringSky.setting.sunBrightness=e,this._onChange=!0)}get displaySun(){return this._atmosphericScatteringSky.setting.displaySun}set displaySun(e){this._atmosphericScatteringSky.setting.displaySun!=e&&(this._atmosphericScatteringSky.setting.displaySun=e,this._onChange=!0)}init(){super.init(),this._historyData=new xu,this._atmosphericScatteringSky=new Fu(new Bu);let e=this.transform.view3D,r=this.transform.scene3D;this.map=this._atmosphericScatteringSky,r.envMap=this._atmosphericScatteringSky,this.onUpdate(e)}start(e){let r=this.transform.scene3D;this.map=this._atmosphericScatteringSky,r.envMap=this._atmosphericScatteringSky,super.start()}get relativeTransform(){return this._relatedTransform}set relativeTransform(e){this._relatedTransform=e,this._historyData.reset()}onUpdate(e){this._relatedTransform&&(this._relatedTransform.rotationZ=0,this._historyData.isRotateChange(this._relatedTransform.rotationX,this._relatedTransform.rotationY)?(this.sunX=(this._relatedTransform.rotationY+90)/360,this.sunY=this._relatedTransform.rotationX/180+.5):this._historyData.isSkyChange(this.sunX,this.sunY)&&(this._relatedTransform.rotationY=this.sunX*360-90,this._relatedTransform.rotationX=(this.sunY-.5)*180),this._historyData.save(this.sunX,this.sunY,this._relatedTransform.rotationX,this._relatedTransform.rotationY)),this._onChange&&(this._onChange=!1,this._atmosphericScatteringSky.apply())}destroy(e){super.destroy(e),this._atmosphericScatteringSky.destroy(),this._atmosphericScatteringSky=null,this._onChange=null}}class gt{}s(gt,"panelRatio",1),s(gt,"quadMaxCountForWorld",256),s(gt,"quadMaxCountForView",2048),s(gt,"SortOrderStartWorld",7e3),s(gt,"SortOrderStartView",8e3),s(gt,"SortOrderCanvasSpan",1e4);var Pt=(n=>(n[n.View=0]="View",n[n.World=2]="World",n))(Pt||{}),Ha=(n=>(n[n.Simple=0]="Simple",n[n.Sliced=1]="Sliced",n[n.Tiled=2]="Tiled",n[n.Filled=3]="Filled",n))(Ha||{}),xr=(n=>(n[n.None=0]="None",n[n.BillboardY=9]="BillboardY",n[n.BillboardXYZ=10]="BillboardXYZ",n))(xr||{});class Ka extends ut{constructor(){super();s(this,"type");s(this,"camera");s(this,"_cameraPosition");this._cameraPosition=new g}onUpdate(){this.enable&&this.transform.view3D.camera&&this.updateBillboardMatrix()}updateBillboardMatrix(){let e=this.transform.view3D.camera;this._cameraPosition.copyFrom(e.transform.back),this.type==xr.BillboardXYZ||this.type==xr.BillboardY&&(this._cameraPosition.y=0),this._cameraPosition.normalize(),this._cameraPosition.add(this.object3D.localPosition,this._cameraPosition),this.transform.lookAt(this.object3D.localPosition,this._cameraPosition,e.transform.up)}cloneTo(e){let r=e.addComponent(Ka);r.type=this.type}}var _u=(n=>(n[n.None=0]="None",n[n.Box=1]="Box",n[n.Capsule=2]="Capsule",n[n.Sphere=3]="Sphere",n[n.Mesh=4]="Mesh",n))(_u||{});class Tu{constructor(t){s(this,"loop",!0);s(this,"speed",1);s(this,"t",0);s(this,"time",0);s(this,"weight",0);s(this,"currFrame",0);s(this,"lastFrame",-1);s(this,"nextFrame",0);s(this,"clip");s(this,"animation");s(this,"_isEnd",!1);s(this,"_currSkeletonPose");this.clip=t,this._currSkeletonPose=new Xa(this.clip.skeleton)}reset(){this.time=0,this.weight=0,this._isEnd=!1}get name(){return this.clip.name}get currSkeletonPose(){return this._currSkeletonPose}update(t){this.time=(this.time+t*this.speed)%this.clip.totalTime;let e=this.time/this.clip.frameRate;if(this.currFrame=Math.trunc(e),this.t=e-this.currFrame,this.currFrame<0&&(this.currFrame=this.clip.numFrame+this.currFrame),this.time>=0?this.nextFrame=(this.currFrame+1)%this.clip.numFrame:(this.nextFrame=this.currFrame-1,this.nextFrame<0&&(this.nextFrame=this.clip.numFrame+this.nextFrame),this.t=1-this.t),this._isEnd)this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1;else if(this.currFrame!=this.lastFrame){let i=this.speed<0?0:this.clip.numFrame;this.currFrame==i&&(this.loop?(this.currFrame=0,this.nextFrame=1,this.time=this.t=0):(this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1,this._isEnd=!0));var r=this.clip.getEvents();if(r)for(let o of r){var a=Math.floor(o.time/this.clip.frameRate);if(a=Math.min(a,this.clip.numFrame),a=Math.max(a,0),a==this.currFrame){o.skeletonAnimation=this.animation,this.animation.eventDispatcher.dispatchEvent(o);break}}this.lastFrame=this.currFrame}this.clip.getLerpSkeletonPose(this.currFrame,this.nextFrame,this.t,this._currSkeletonPose)}}var wu=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let Dr=class extends ut{constructor(){super();s(this,"isPlaying",!0);s(this,"timeScale",1);s(this,"_skeleton");s(this,"_clips",[]);s(this,"_clipStates",new Map);s(this,"_mixSkeletonPose");s(this,"_mixTempSkeletonPose");s(this,"_currentClipState");s(this,"_bindList",[]);s(this,"_jointMatrixIndexTableBuffer");s(this,"_crossFadeState")}start(){}get currName(){return this._currentClipState?this._currentClipState.name:""}set skeleton(t){this._skeleton=t,this._mixSkeletonPose=new Xa(this._skeleton,!0),this._mixTempSkeletonPose=new Xa(this._skeleton);const e=new Float32Array(this._mixSkeletonPose.jointMatrixIndexTable);this._jointMatrixIndexTableBuffer=new Xe(this._skeleton.numJoint*4,0,e)}get skeleton(){return this._skeleton}get finalSkeletonPose(){return this._mixSkeletonPose}get jointMatrixIndexTableBuffer(){return this._jointMatrixIndexTableBuffer}getJointIndexTable(t){let e=new Array;for(let r=0;r<t.length;r++){const a=t[r];let i=this._skeleton.getJointByName(a);e[r]=i?i.index:-1}return e}addAnimationClip(t){if(!this._clipStates.has(t.name)){this._clips.push(t);let e=new Tu(t);e.animation=this,this._clipStates.set(t.name,e),this._currentClipState||this.setCurrentClipState(e)}}getAnimationClip(t){var e=this.getAnimationClipState(t);return e?e.clip:null}getAnimationClips(){return this._clips}getAnimationClipState(t){return this._clipStates.has(t)?this._clipStates.get(t):null}getAnimationClipStates(){return this._clipStates}pause(){this.isPlaying=!1}resume(){this.isPlaying=!0}play(t,e=1,r=!1){if(this._currentClipState&&this._currentClipState.name==t)return r&&this._currentClipState.reset(),!1;let a=this.getAnimationClipState(t);return a?(a.speed=e,a.reset(),this._clipStates.forEach((i,o)=>{i.weight=0}),this.setCurrentClipState(a),!0):!1}crossFade(t,e){if(e<.01){this.play(t);return}if(this._currentClipState.name==t)return;let r=this.getAnimationClipState(t);r&&(r.reset(),this._crossFadeState?(this._crossFadeState.inClip&&(this._crossFadeState.inClip.weight=0),this._crossFadeState.outClip&&(this._crossFadeState.outClip.weight=0),this._crossFadeState.reset(r,this._currentClipState,e)):this._crossFadeState=new Du(r,this._currentClipState,e),this._currentClipState=r)}setAnimIsLoop(t,e){this._clipStates.has(t)&&(this._clipStates.get(t).loop=e)}addJointBind(t,e){this._bindList.push({jointName:t,obj:e})}removeJointBind(t){for(let e=0;e<this._bindList.length;e++)if(this._bindList[e].obj==t){this._bindList.splice(e,1);break}}onUpdate(){if(!this.isPlaying)return;let t=Ae.delta*.001*this.timeScale;this._crossFadeState&&this._crossFadeState.update(t);var e=0,r=[];if(this._clipStates.forEach((i,o)=>{i.weight>0&&(i.update(t),e+=i.weight,r.push(i))}),r.length>0){this._mixSkeletonPose.copyFrom(r[0].currSkeletonPose);for(var a=1;a<r.length;++a){const i=r[a];this._mixTempSkeletonPose.lerp(this._mixSkeletonPose,i.currSkeletonPose,i.weight/e),this._mixSkeletonPose.copyFrom(this._mixTempSkeletonPose)}}}cloneTo(t){let e=t.addComponent(Dr);e.skeleton=this.skeleton;for(var r=0;r<this._clips.length;++r)e.addAnimationClip(this._clips[r])}setCurrentClipState(t){this._currentClipState!=t&&(this._currentClipState=t,this._currentClipState.weight=1)}};Dr=wu([Tt(Dr,"SkeletonAnimationComponent")],Dr);class Du{constructor(t,e,r){s(this,"inClip");s(this,"outClip");s(this,"currentTime");s(this,"crossFadeTime");this.reset(t,e,r)}reset(t,e,r){this.inClip=t,this.outClip=e,this.currentTime=0,this.crossFadeTime=r}update(t){!this.inClip||!this.outClip||(this.currentTime+=t,this.inClip.weight=Math.min(Math.abs(this.currentTime%this.crossFadeTime)/this.crossFadeTime,1),this.outClip.weight=1-this.inClip.weight,Math.abs(this.currentTime)>=this.crossFadeTime&&(this.inClip.weight=1,this.outClip.weight=0,this.inClip=null,this.outClip=null))}}var Vu=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let gr=class extends ut{constructor(){super(...arguments);s(this,"timeScale",1);s(this,"jointMatrixIndexTableBuffer");s(this,"playBlendShapeLoop",!1);s(this,"inverseBindMatrices");s(this,"_avatar");s(this,"_rendererList");s(this,"propertyCache");s(this,"_clips");s(this,"_clipsState");s(this,"_clipsMap");s(this,"_currentSkeletonClip");s(this,"_currentBlendAnimClip");s(this,"_skeletonTime",0);s(this,"_blendShapeTime",0);s(this,"_skeletonSpeed",1);s(this,"_blendShapeSpeed",1);s(this,"_skeletonStart",!0);s(this,"_blendShapeStart",!0);s(this,"root");s(this,"_avatarName");s(this,"_bonePos",new g);s(this,"_boneScale",new g);s(this,"_boneRot",new X);s(this,"_crossFadeState");s(this,"skeltonPoseObject3D",{});s(this,"skeltonTPoseObject3D",{})}init(t){this.propertyCache=new Map,this._clipsMap=new Map,this._clips=[],this._clipsState=[],this._rendererList=this.object3D.getComponentsInChild(Yr);let e=this.object3D.getComponentsInChild(Be);for(let r of e){let a=r;a.blendShape=r.morphData,this._rendererList.push(a)}for(const r of this._rendererList)Mt.hasMask(r.rendererMask,de.MorphTarget)&&r.selfCloneMaterials("MORPH_TARGET_UUID")}start(){}debug(){}playAnim(t,e=0,r=1){let a=this.getAnimationClipState(t);a?(this._currentSkeletonClip&&(this._currentSkeletonClip.weight=0),this._currentSkeletonClip=a,this._currentSkeletonClip.weight=1,this._skeletonTime=e,this._skeletonSpeed=r,this._skeletonStart=!0):console.warn(`not has anim ${t}`)}crossFade(t,e){let r=this.getAnimationClipState(t);if(!r){console.warn(`not has anim ${t}`);return}if(e<.01||!this._currentSkeletonClip){this.playAnim(t);return}if(this._currentSkeletonClip&&this._currentSkeletonClip.clip.clipName===t)return;let a=r,i=this._currentSkeletonClip;this._crossFadeState?(this._crossFadeState.inClip&&(this._crossFadeState.inClip.weight=0),this._crossFadeState.outClip&&(this._crossFadeState.outClip.weight=0),this._crossFadeState.reset(a,i,e)):this._crossFadeState=new Mu(a,i,e),this._currentSkeletonClip=a}playBlendShape(t,e=0,r=1){this._clipsMap.has(t)?(this._currentBlendAnimClip=this._clipsMap.get(t),this._blendShapeTime=e,this._blendShapeSpeed=r,this._blendShapeStart=!0):console.warn(`not has blendShape ${t}`)}set avatar(t){this._avatarName=t,this.inverseBindMatrices=[],this._avatar=C.res.getObj(t);let e=this.buildSkeletonPose();const r=new Float32Array(e);this.jointMatrixIndexTableBuffer=new Xe(this._avatar.count,0,r)}get numJoint(){return this._avatar.count}getJointIndexTable(t){let e=new Array;for(let r=0;r<t.length;r++){let a=this._avatar.boneMap.get(t[r]);e[r]=a?a.boneID:-1}return e}buildSkeletonPose(){let t=[];for(const e of this._avatar.boneData){let r=new ie;Z.getEuler(g.HELP_6,e.q,!0,"ZYX"),r.localPosition=e.t.clone(),r.localRotation=g.HELP_6.clone(),r.localScale=g.ONE,e.s.clone(),this.skeltonPoseObject3D[e.boneName]=r,this.skeltonTPoseObject3D[e.bonePath]=r.clone(),e.parentBoneName&&e.parentBoneName!=""?this.skeltonPoseObject3D[e.parentBoneName].addChild(r):(this.object3D.transform.scene3D&&this.object3D.transform.scene3D.addChild(r),this.root=r),t.push(r.transform.worldMatrix.index);let a=new Z;a.copyFrom(r.transform.worldMatrix),a.invert(),this.inverseBindMatrices.push(a.rawData)}return t}set clips(t){this._clips=t;for(const e of t)this._clipsMap.set(e.clipName,e);this._clipsState=[];for(const e of t)this._clipsState.push(new Nu(e));this._currentSkeletonClip||this.playAnim(t[0].clipName)}get clips(){return this._clips}get clipsState(){return this._clipsState}cloneTo(t){let e=t.addComponent(gr);e.avatar=this._avatarName,e.clips=this._clips}updateTime(){const t=Ae.delta*.001;this._skeletonStart&&(this._skeletonTime+=t*this._skeletonSpeed*this.timeScale,this._currentSkeletonClip&&this._currentSkeletonClip.clip.loopTime&&(this._skeletonTime=this._skeletonTime%this._currentSkeletonClip.clip.stopTime)),this._blendShapeStart&&(this._blendShapeTime+=t*this._blendShapeSpeed,this._currentBlendAnimClip&&(this._currentBlendAnimClip.loopTime&&this.playBlendShapeLoop?this._blendShapeTime=this._blendShapeTime%this._currentBlendAnimClip.stopTime:this._blendShapeTime=Math.min(this._blendShapeTime,this._currentBlendAnimClip.stopTime)-1e-4)),this._crossFadeState&&this._crossFadeState.update(t)}onUpdate(t){this.updateTime();let e=[];for(let r of this._clipsState)r.weight>0&&e.push(r);e.length>0?this.updateSkeletonAnimMix(e):this.updateSkeletonAnim(),this.updateMorphAnim()}updateSkeletonAnim(){if(this._currentSkeletonClip){let t=this._avatar.boneData,e=0,r=t.length;for(e=0;e<r;e++){const a=t[e];let i=this.skeltonPoseObject3D[a.boneName];if(this._currentSkeletonClip.clip.useSkeletonPos){let l=this.getPosition(a.bonePath,this._skeletonTime);i.transform.localPosition=l}let o=this.getRotation(a.bonePath,this._skeletonTime);if(i.transform.localRotQuat=o,this._currentSkeletonClip.clip.useSkeletonScale){let l=this.getScale(a.bonePath,this._skeletonTime);i.transform.localScale=l}}}}updateMorphAnim(){if(this._currentBlendAnimClip&&this._currentBlendAnimClip.floatCurves&&this._currentBlendAnimClip.floatCurves.size>0&&this._rendererList)for(const t of this._currentBlendAnimClip.floatCurves){let e=t[0],r=t[1].propertys,a=this._currentBlendAnimClip.floatCurves.get(e).getValue(this._blendShapeTime)/100;this.updateBlendShape(r,e,a)}}updateBlendShape(t,e,r){for(const a of this._rendererList)if(a.blendShape){let i=this.propertyCache.get(a);if(i&&e in i)i[e](r);else{i=a;for(const o of t){if(!i[o]){i=null;break}i=i[o]}if(!i||i==a)continue;this.propertyCache.get(a)||this.propertyCache.set(a,{}),this.propertyCache.get(a)[e]=i,i(r)}}}updateSkeletonAnimMix(t){let e=0;for(let r of t)e+=r.weight;if(t.length>0){let r=this._avatar.boneData,a=r.length;for(let i=0;i<a;i++){const o=r[i];let l=this.skeltonPoseObject3D[o.boneName];if(t[0].clip.useSkeletonPos){this._bonePos.copyFrom(this.getPosition(o.bonePath,this._skeletonTime,t[0].clip));for(let h=1;h<t.length;h++){const c=t[h];if(c.clip.useSkeletonPos){let u=this.getPosition(o.bonePath,this._skeletonTime,c.clip);g.HELP_0.lerp(this._bonePos,u,c.weight/e),this._bonePos.copyFrom(g.HELP_0)}}l.transform.localPosition=this._bonePos}this._boneRot.copyFrom(this.getRotation(o.bonePath,this._skeletonTime,t[0].clip));for(let h=1;h<t.length;h++){const c=t[h];let u=this.getRotation(o.bonePath,this._skeletonTime,c.clip);X.HELP_2.slerp(this._boneRot,u,c.weight/e),this._boneRot.copyFrom(X.HELP_2)}if(l.transform.localRotQuat=this._boneRot,t[0].clip.useSkeletonScale){this._boneScale.copyFrom(this.getScale(o.bonePath,this._skeletonTime,t[0].clip));for(let h=1;h<t.length;h++){const c=t[h];if(c.clip.useSkeletonScale){let u=this.getScale(o.bonePath,this._skeletonTime,c.clip);g.HELP_0.lerp(this._boneScale,u,c.weight/e),this._boneScale.copyFrom(g.HELP_0)}}l.transform.localScale=this._boneScale}}}}getPosition(t,e,r=this._currentSkeletonClip.clip){return r.positionCurves.has(t)?r.positionCurves.get(t).getValue(e):this.skeltonTPoseObject3D[t].localPosition}getRotation(t,e,r=this._currentSkeletonClip.clip){if(r.rotationCurves.has(t)){let a=r.rotationCurves.get(t).getValue(e);return X.HELP_0.set(a.x,a.y,a.z,a.w),X.HELP_0}return this.skeltonTPoseObject3D[t].localQuaternion}getScale(t,e,r=this._currentSkeletonClip.clip){return r.scaleCurves.has(t)?r.scaleCurves.get(t).getValue(e):this.skeltonTPoseObject3D[t].localScale}getAnimationClipState(t){for(let e of this._clipsState)if(e.clip.clipName===t)return e;return null}cloneMorphRenderers(){let t={};for(const e of this._rendererList)for(const r in e.geometry.morphTargetDictionary){let a=t[r]||[];a.push(e),t[r]=a}return t}};gr=Vu([Tt(gr,"AnimatorComponent")],gr);class Nu{constructor(t){s(this,"clip");s(this,"weight",0);this.clip=t}get totalTime(){return this.clip.stopTime-this.clip.startTime}}class Mu{constructor(t,e,r){s(this,"inClip");s(this,"outClip");s(this,"currentTime");s(this,"crossFadeTime");this.reset(t,e,r)}reset(t,e,r){this.inClip=t,this.outClip=e,this.currentTime=0,this.crossFadeTime=r}update(t){!this.inClip||!this.outClip||(this.currentTime+=t,this.inClip.weight=Math.min(Math.abs(this.currentTime%this.crossFadeTime)/this.crossFadeTime,1),this.outClip.weight=1-this.inClip.weight,Math.abs(this.currentTime)>=this.crossFadeTime&&(this.inClip.weight=1,this.outClip.weight=0,this.inClip=null,this.outClip=null))}}class ku{constructor(){s(this,"index");s(this,"time");s(this,"timeEnd");s(this,"coeff",[])}}var Sr=(n=>(n[n.PingPong=0]="PingPong",n[n.Repeat=1]="Repeat",n[n.Clamp=2]="Clamp",n))(Sr||{});class ki{constructor(t=0,e=0){s(this,"serializedVersion","2");s(this,"time");s(this,"value");s(this,"inSlope",0);s(this,"outSlope",0);s(this,"tangentMode",0);s(this,"weightedMode",0);s(this,"inWeight");s(this,"outWeight");this.time=t,this.value=e}unSerialized(t){this.serializedVersion=t.serializedVersion,this.time=t.time,this.value=t.value,this.tangentMode=t.tangentMode,this.inSlope=t.inSlope=="Infinity"?NaN:t.inSlope,this.outSlope=t.outSlope=="Infinity"?NaN:t.outSlope}unSerialized2(t){this.serializedVersion=t.serializedVersion,this.time=t.time,this.value=t.value,this.tangentMode=t.tangentMode,this.inSlope=t.inTangent=="Infinity"?NaN:t.inTangent,this.outSlope=t.outTangent=="Infinity"?NaN:t.outTangent}}class Pu{constructor(t,e=Sr.Repeat,r=Sr.Repeat){s(this,"_totalTime",1);s(this,"_cache",new ku);s(this,"_cacheOut",{lhsIndex:0,rhsIndex:0});s(this,"_InvalidateCache",!1);s(this,"curve",[]);s(this,"serializedVersion");s(this,"preWarpMode");s(this,"postWarpMode");s(this,"rotationOrder");if(t)for(let a=0;a<t.length;a++){const i=t[a];this.addKeyFrame(i)}this.preWarpMode=e,this.postWarpMode=r}get cacheOut(){return this._cacheOut}get totalTime(){return this._totalTime}get first(){return this.curve[0]}get last(){return this.curve[this.curve.length-1]}addKeyFrame(t){this.curve.indexOf(t)==-1&&this.curve.push(t),this.calcTotalTime()}removeKeyFrame(t){let e=this.curve.indexOf(t);e!=-1&&this.curve.splice(e,1),this.calcTotalTime()}calculateCacheData(t,e,r,a=0){let i=this.curve,o=i[e],l=i[r];t.index=e,t.time=o.time+a,t.timeEnd=l.time+a,t.index=e;let h,c,u,d,f,A,p;h=l.time-o.time,h=Math.max(h,1e-4),u=l.value-o.value,c=1/(h*h),d=o.outSlope,f=l.inSlope,A=d*h,p=f*h,t.coeff[0]=(A+p-u-u)*c/h,t.coeff[1]=(u+u+u-A-A-p)*c,t.coeff[2]=d,t.coeff[3]=o.value,this.setupStepped(t.coeff,o,l)}getValue(t){return t=this.wrapTime(t),this.findCurve(t,this._cacheOut),this.calculateCacheData(this._cache,this._cacheOut.lhsIndex,this._cacheOut.rhsIndex,0),this.evaluateCache(this._cache,t)}getCurveFramesExtent(t){return t=this.wrapTime(t),this.findCurve(t,this._cacheOut),{lhsIndex:this._cacheOut.lhsIndex,rhsIndex:this._cacheOut.rhsIndex,time:t}}getKeyCount(){return this.curve.length}getKey(t){return this.curve[t]}unSerialized(t){this.preWarpMode=t.m_PreInfinity,this.postWarpMode=t.m_PostInfinity,this.rotationOrder=t.m_RotationOrder;let e=t.m_Curve.length;for(let r=0;r<e;r++)this.curve[r]=new ki,this.curve[r].unSerialized(t.m_Curve[r.toString()]);return this.calcTotalTime(),this}unSerialized2(t){this.preWarpMode=t.preWrapMode,this.postWarpMode=t.postWrapMode;let e=t.keyFrames||t.keys,r=e.length;for(let a=0;a<r;a++)this.curve[a]=new ki,this.curve[a].unSerialized2(e[a.toString()]);return this.calcTotalTime(),this}wrapTime(t){let e=this.curve,r=e[0].time,a=e[e.length-1].time;return t<r?this.preWarpMode==Sr.Clamp?t=r:this.preWarpMode==Sr.PingPong?t=Fs(t,r,a):t=Cs(t,r,a):t>a&&(this.postWarpMode==Sr.Clamp?t=a:this.postWarpMode==Sr.PingPong?t=Fs(t,r,a):t=Cs(t,r,a)),t}evaluateCache(t,e){let r=e-t.time;return r*(r*(r*t.coeff[0]+t.coeff[1])+t.coeff[2])+t.coeff[3]}findCurve(t,e){let r=this.curve;for(let a=1;a<r.length;a++){let i=r[a-1],o=r[a];i.time<=t&&o.time>t&&(e.lhsIndex=a-1,e.rhsIndex=a)}}setupStepped(t,e,r){(isNaN(e.outSlope)||isNaN(r.inSlope))&&(t[0]=0,t[1]=0,t[2]=0,t[3]=e.value)}invalidateCache(){this._InvalidateCache=!0}calcTotalTime(){let t=0;for(let e of this.curve)e?t=Math.max(t,e.time):console.error(e);this._totalTime=t}static scaleCurveValue(t,e){if(!t._InvalidateCache)for(let r=0;r<t.curve.length;r++){let a=t.curve[r];a.value*=e,a.inSlope*=e,a.outSlope*=e}t.invalidateCache()}}var Lu=(n=>(n[n.Default=0]="Default",n[n.Clamp=1]="Clamp",n[n.Once=1]="Once",n[n.Loop=2]="Loop",n[n.PingPong=4]="PingPong",n[n.ClampForever=8]="ClampForever",n))(Lu||{}),Ou=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let Yr=class extends Be{constructor(){super();s(this,"skinJointsName");s(this,"mInverseBindMatrixData");s(this,"mInverseBindMatrixBuffer");s(this,"mSkeletonAnimation");s(this,"mJointIndexTableBuffer");this.addRendererMask(de.SkinnedMesh)}get geometry(){return this._geometry}set geometry(t){this.skinJointsName=t.skinNames;let e=[];for(let r=0;r<t.bindPose.length;r++)e.push(new Float32Array(t.bindPose[r].rawData.slice(0,16)));this.skinInverseBindMatrices=e,super.geometry=t}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(gr),!this.skeletonAnimation){let t=this.object3D.parentObject.parentObject.getComponentsInChild(gr);t.length>0&&(this.skeletonAnimation=t[0]);let e=this.object3D;for(;!this.skeletonAnimation&&e;)this.skeletonAnimation=e.getComponentFromParent(gr),e.parent&&(e=e.parent.object3D)}}get blendShape(){return this.morphData}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(t){if(this.mSkeletonAnimation=t,!!t&&!this.mJointIndexTableBuffer){let e=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new Xe(e.length,0,new Float32Array(e)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(t){this.mInverseBindMatrixData=t;var e=new Float32Array(t.length*16);for(let r=0;r<t.length;r++){let a=r*16,i=t[r];e.set(i,a)}this.mInverseBindMatrixBuffer=new Xe(e.byteLength,0,e),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(t){let e=t.addComponent(Yr),r=[];for(const a of this.materials)r.push(a.clone());e.materials=r,e.geometry=this.geometry,e.castShadow=this.castShadow,e.castGI=this.castGI,e.receiveShadow=this.receiveShadow,e.rendererMask=this.rendererMask,e.skinJointsName=this.skinJointsName,e.skinInverseBindMatrices=this.skinInverseBindMatrices,e.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(t,e,r,a){for(let i=0;i<this.materials.length;i++){let o=this.materials[i].getPass(e);if(o)for(let l=0;l<o.length;l++){const h=o[l];!h.pipeline&&this.mSkeletonAnimation&&(h.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),h.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),h.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(t,e,r,a)}};Yr=Ou([Tt(Yr,"SkinnedMeshRenderer2")],Yr);var Gu=(n=>(n.mouthRollLower="mouthRollLower",n.browOuterUp_L="browOuterUpLeft",n.mouthSmile_L="mouthSmileLeft",n.jawRight="jawRight",n.eyeLookOut_L="eyeLookOutLeft",n.mouthFunnel="mouthFunnel",n.mouthUpperUp_R="mouthUpperUpRight",n.browDown_L="browDownLeft",n.jawLeft="jawLeft",n.mouthLowerDown_L="mouthLowerDownLeft",n.noseSneer_R="noseSneerRight",n.jawForward="jawForward",n.mouthLowerDown_R="mouthLowerDownRight",n.browInnerUp="browInnerUp",n.mouthRollUpper="mouthRollUpper",n.mouthStretch_R="mouthStretchRight",n.mouthPucker="mouthPucker",n.eyeBlink_L="eyeBlinkLeft",n.mouthUpperUp_L="mouthUpperUpLeft",n.mouthShrugUpper="mouthShrugUpper",n.eyeLookIn_R="eyeLookInRight",n.noseSneer_L="noseSneerLeft",n.mouthFrown_L="mouthFrownLeft",n.cheekSquint_L="cheekSquintLeft",n.eyeLookDown_L="eyeLookDownLeft",n.mouthDimple_L="mouthDimpleLeft",n.mouthFrown_R="mouthFrownRight",n.eyeLookIn_L="eyeLookInLeft",n.eyeLookOut_R="eyeLookOutRight",n.mouthLeft="mouthLeft",n.mouthStretch_L="mouthStretchLeft",n.mouthPress_L="mouthPressLeft",n.mouthDimple_R="mouthDimpleRight",n.eyeWide_R="eyeWideRight",n.browDown_R="browDownRight",n.eyeLookUp_R="eyeLookUpRight",n.eyeBlink_R="eyeBlinkRight",n.cheekSquint_R="cheekSquintRight",n.mouthRight="mouthDimpleRight",n.eyeLookDown_R="eyeLookDownRight",n.eyeLookUp_L="eyeLookUpLeft",n.eyeSquint_L="eyeSquintLeft",n.jawOpen="jawOpen",n.browOuterUp_R="browOuterUpRight",n.mouthClose="mouthClose",n.mouthShrugLower="mouthShrugLower",n.eyeWide_L="eyeWideLeft",n.tongueOut="tongueOut",n.eyeSquint_R="eyeSquintRight",n.cheekPuff="cheekPuff",n.mouthPress_R="mouthPressRight",n.mouthSmile_R="mouthSmileRight",n))(Gu||{}),Wu=(n=>(n[n.Key_BackSpace=8]="Key_BackSpace",n[n.Key_Tab=9]="Key_Tab",n[n.Key_Clear=12]="Key_Clear",n[n.Key_Enter=13]="Key_Enter",n[n.Key_Shift_L=16]="Key_Shift_L",n[n.Key_Control_L=17]="Key_Control_L",n[n.Key_Alt_L=18]="Key_Alt_L",n[n.Key_Pause=19]="Key_Pause",n[n.Key_CapsLock=20]="Key_CapsLock",n[n.Key_Escape=21]="Key_Escape",n[n.Key_Esc=27]="Key_Esc",n[n.Key_Space=32]="Key_Space",n[n.Key_Prior=33]="Key_Prior",n[n.Key_Next=34]="Key_Next",n[n.Key_End=35]="Key_End",n[n.Key_Home=36]="Key_Home",n[n.Key_Left=37]="Key_Left",n[n.Key_Up=38]="Key_Up",n[n.Key_Right=39]="Key_Right",n[n.Key_Down=40]="Key_Down",n[n.Key_Select=41]="Key_Select",n[n.Key_Print=42]="Key_Print",n[n.Key_Execute=43]="Key_Execute",n[n.Key_Insert=45]="Key_Insert",n[n.Key_Delete=46]="Key_Delete",n[n.Key_Help=47]="Key_Help",n[n.Key_0=48]="Key_0",n[n.Key_1=49]="Key_1",n[n.Key_2=50]="Key_2",n[n.Key_3=51]="Key_3",n[n.Key_4=52]="Key_4",n[n.Key_5=53]="Key_5",n[n.Key_6=54]="Key_6",n[n.Key_7=55]="Key_7",n[n.Key_8=56]="Key_8",n[n.Key_9=57]="Key_9",n[n.Key_A=65]="Key_A",n[n.Key_B=66]="Key_B",n[n.Key_C=67]="Key_C",n[n.Key_D=68]="Key_D",n[n.Key_E=69]="Key_E",n[n.Key_F=70]="Key_F",n[n.Key_G=71]="Key_G",n[n.Key_H=72]="Key_H",n[n.Key_I=73]="Key_I",n[n.Key_J=74]="Key_J",n[n.Key_K=75]="Key_K",n[n.Key_L=76]="Key_L",n[n.Key_M=77]="Key_M",n[n.Key_N=78]="Key_N",n[n.Key_O=79]="Key_O",n[n.Key_P=80]="Key_P",n[n.Key_Q=81]="Key_Q",n[n.Key_R=82]="Key_R",n[n.Key_S=83]="Key_S",n[n.Key_T=84]="Key_T",n[n.Key_U=85]="Key_U",n[n.Key_V=86]="Key_V",n[n.Key_W=87]="Key_W",n[n.Key_X=88]="Key_X",n[n.Key_Y=89]="Key_Y",n[n.Key_Z=90]="Key_Z",n[n.Key_KP_0=96]="Key_KP_0",n[n.Key_KP_1=97]="Key_KP_1",n[n.Key_KP_2=98]="Key_KP_2",n[n.Key_KP_3=99]="Key_KP_3",n[n.Key_KP_4=100]="Key_KP_4",n[n.Key_KP_5=101]="Key_KP_5",n[n.Key_KP_6=102]="Key_KP_6",n[n.Key_KP_7=103]="Key_KP_7",n[n.Key_KP_8=104]="Key_KP_8",n[n.Key_KP_9=105]="Key_KP_9",n[n.Key_Multiply=106]="Key_Multiply",n[n.Key_Add=107]="Key_Add",n[n.Key_Separator=108]="Key_Separator",n[n.Key_Subtract=109]="Key_Subtract",n[n.Key_Decimal=110]="Key_Decimal",n[n.Key_Divide=111]="Key_Divide",n[n.Key_F1=112]="Key_F1",n[n.Key_F2=113]="Key_F2",n[n.Key_F3=114]="Key_F3",n[n.Key_F4=115]="Key_F4",n[n.Key_F5=116]="Key_F5",n[n.Key_F6=117]="Key_F6",n[n.Key_F7=118]="Key_F7",n[n.Key_F8=119]="Key_F8",n[n.Key_F9=120]="Key_F9",n[n.Key_F10=121]="Key_F10",n[n.Key_F11=122]="Key_F11",n[n.Key_F12=123]="Key_F12",n[n.Key_F13=124]="Key_F13",n[n.Key_F14=125]="Key_F14",n[n.Key_F15=126]="Key_F15",n[n.Key_F16=127]="Key_F16",n[n.Key_F17=128]="Key_F17",n[n.Key_F18=129]="Key_F18",n[n.Key_F19=130]="Key_F19",n[n.Key_F20=131]="Key_F20",n[n.Key_F21=132]="Key_F21",n[n.Key_F22=133]="Key_F22",n[n.Key_F23=134]="Key_F23",n[n.Key_F24=135]="Key_F24",n[n.Key_Num_Lock=136]="Key_Num_Lock",n[n.Key_Scroll_Lock=137]="Key_Scroll_Lock",n))(Wu||{});class Ns{static add(t,e,r){return r||(r=new g),r.x=t.x+e.x,r.y=t.y+e.y,r.z=t.z+e.z,r}static sub(t,e,r){return r||(r=new g),r.x=t.x-e.x,r.y=t.y-e.y,r.z=t.z-e.z,r}static mul(t,e,r){return r||(r=new g),r.x=t.x*e.x,r.y=t.y*e.y,r.z=t.z*e.z,r}static mulScale(t,e,r){return r||(r=new g),r.x=t.x*e,r.y=t.y*e,r.z=t.z*e,r}static div(t,e,r){return r||(r=new g),r.x=t.x/e.x,r.y=t.y/e.y,r.z=t.z/e.z,r}static normalize(t){return t.clone().normalize()}static dot(t,e){let r=g.HELP_0;return r.copyFrom(t),r.dotProduct(e)}static calculateVectorAngle_xz(t,e){return Math.acos((t.x*e.x+t.y*e.y)/Math.sqrt((t.x*t.x+t.y*t.y)*(e.x*e.x+e.y*e.y)))}static distance(t,e){return g.distance(t,e)}static getRandomXYZ(t=-100,e=100){return new g(Math.random()*(e-t)+t,Math.random()*(e-t)+t,Math.random()*(e-t)+t)}static getRandomV3(t=-100,e=100,r,a){return new g(Math.random()*e+t,Math.random()*a+r,Math.random()*e+t)}static sphere(t){let e=t*Math.random(),r=new g(Math.random()*1-.5,Math.random()*1-.5,Math.random()*1-.5);return r.normalize(),r.scaleBy(e),r}static sphereXYZ(t,e,r=1,a=1,i=1){let o=t+(e-t)*Math.random(),l=new g(Math.random()*r-r*.5,Math.random()*a-a*.5,Math.random()*i-i*.5);return l.normalize(),l.scaleBy(o),l}}class Ju extends ut{constructor(){super();s(this,"camera");s(this,"minDistance",.1);s(this,"maxDistance",500);s(this,"rollSmooth",15);s(this,"dragSmooth",20);s(this,"wheelSmooth",10);s(this,"wheelStep",.002);s(this,"mouseRightFactor",.25);s(this,"mouseLeftFactor",20);s(this,"smooth",!0);s(this,"_wheelStep",.002);s(this,"_distance",0);s(this,"distance",10);s(this,"_roll",0);s(this,"roll",0);s(this,"_pitch",0);s(this,"pitch",0);s(this,"_currentPos");s(this,"_targetPos");s(this,"_flowTarget");s(this,"_flowOffset");s(this,"_mouseLeftDown",!1);s(this,"_mouseRightDown",!1);s(this,"_bottomClamp",89.99);s(this,"_topClamp",-89.99);s(this,"_tempDir",new g);s(this,"_tempPos",new g);this._currentPos=new ie,this._targetPos=new ie}get bottomClamp(){return this._bottomClamp}set bottomClamp(e){this._bottomClamp=e>89.99?89.99:e}get topClamp(){return this._topClamp}set topClamp(e){this._topClamp=e<-89.99?-89.99:e}start(){this.camera=this.object3D.getOrAddComponent(Gi),C.inputSystem.addEventListener(G.POINTER_DOWN,this.onMouseDown,this),C.inputSystem.addEventListener(G.POINTER_MOVE,this.onMouseMove,this,null,10),C.inputSystem.addEventListener(G.POINTER_UP,this.onMouseUp,this,null,10),C.inputSystem.addEventListener(G.POINTER_WHEEL,this.onMouseWheel,this)}flowTarget(e,r=g.ZERO){this._flowTarget=e,this._flowOffset||(this._flowOffset=new g),this._flowOffset.copyFrom(r)}getFlowTarget(){return this._flowTarget}setCamera(e,r,a,i){this.roll=e,this.pitch=r,this.distance=a,this.maxDistance<a*1.5&&(this.maxDistance=a*1.5),i&&this._targetPos.transform.localPosition.copy(i)}focusByBounds(e){let r=Oa.genMeshBounds(e);this.target=r.center}set target(e){this._targetPos.transform.localPosition.copy(e)}get target(){return this._targetPos.transform.localPosition}onMouseWheel(e){this.enable&&(this._wheelStep=this.wheelStep*Ns.distance(this._currentPos.transform.worldPosition,this.camera.transform.worldPosition)/10,this.distance-=C.inputSystem.wheelDelta*this._wheelStep,this.distance=yt(this.distance,this.minDistance,this.maxDistance))}onMouseDown(e){if(this.enable)switch(e.mouseCode){case 0:this._mouseLeftDown=!0;break;case 1:break;case 2:this._mouseRightDown=!0;break}}onMouseUp(e){this._mouseLeftDown=!1,this._mouseRightDown=!1}onMouseMove(e){this.enable&&(this._mouseRightDown&&(g.HELP_1.x=-1*e.movementX*Math.cos(this._roll*Math.PI/180)-e.movementY*Math.sin(this._roll*Math.PI/180),g.HELP_1.z=-1*e.movementY*Math.cos(this._roll*Math.PI/180)+e.movementX*Math.sin(this._roll*Math.PI/180),this._targetPos.x+=g.HELP_1.x*this.mouseRightFactor,this._targetPos.z+=g.HELP_1.z*this.mouseRightFactor),this._mouseLeftDown&&(this.roll-=e.movementX*Ae.delta*.001*this.mouseLeftFactor,this.pitch-=e.movementY*Ae.delta*.001*this.mouseLeftFactor,this.pitch=yt(this.pitch,this._topClamp,this._bottomClamp)))}onBeforeUpdate(e){if(!this.enable)return;this._flowTarget&&(g.HELP_0.copyFrom(this._flowTarget.transform.worldPosition),g.HELP_0.add(this._flowOffset,g.HELP_0),this.target=g.HELP_0);let r=yt(Ae.delta,0,.016);this.smooth?(this._currentPos.x+=(this._targetPos.x-this._currentPos.x)*r*this.dragSmooth,this._currentPos.y+=(this._targetPos.y-this._currentPos.y)*r*this.dragSmooth,this._currentPos.z+=(this._targetPos.z-this._currentPos.z)*r*this.dragSmooth,this._distance+=(this.distance-this._distance)*r*this.wheelSmooth,this._roll+=(this.roll-this._roll)*r*this.rollSmooth,this._pitch+=(this.pitch-this._pitch)*r*this.rollSmooth):(this._currentPos.x=this._targetPos.x,this._currentPos.y=this._targetPos.y,this._currentPos.z=this._targetPos.z,this._distance=this.distance,this._roll=this.roll,this._pitch=this.pitch),this._tempDir.set(0,0,1);let a=X.HELP_0;a.fromEulerAngles(this._pitch,this._roll,0),this._tempDir.applyQuaternion(a),this._tempPos=Ns.mulScale(this._tempDir,this._distance,this._tempPos),this._tempPos.add(this._currentPos.transform.localPosition,this._tempPos),this.camera.lookAt(this._tempPos,this._currentPos.transform.localPosition,g.UP)}destroy(e){C.inputSystem.removeEventListener(G.POINTER_DOWN,this.onMouseDown,this),C.inputSystem.removeEventListener(G.POINTER_MOVE,this.onMouseMove,this),C.inputSystem.removeEventListener(G.POINTER_UP,this.onMouseUp,this),C.inputSystem.removeEventListener(G.POINTER_WHEEL,this.onMouseWheel,this),super.destroy(e),this.camera=null,this._flowTarget=null}}var Or=(n=>(n[n.NORMAL=0]="NORMAL",n[n.DOWN=1]="DOWN",n[n.OVER=2]="OVER",n[n.DISABLE=3]="DISABLE",n))(Or||{});let zu=Math.PI,Ms=zu*2;class Hr{constructor(t=1,e=0,r=0,a=1,i=0,o=0){s(this,"a");s(this,"b");s(this,"c");s(this,"d");s(this,"tx");s(this,"ty");this.a=t,this.b=e,this.c=r,this.d=a,this.tx=i,this.ty=o}clone(){return new Hr(this.a,this.b,this.c,this.d,this.tx,this.ty)}concat(t){let e=this.a,r=this.c,a=this.tx;this.a=e*t.a+this.b*t.c,this.b=e*t.b+this.b*t.d,this.c=r*t.a+this.d*t.c,this.d=r*t.b+this.d*t.d,this.tx=a*t.a+this.ty*t.c+t.tx,this.ty=a*t.b+this.ty*t.d+t.ty}copyFrom(t){return this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty,this}identity(){return this.a=this.d=1,this.b=this.c=this.tx=this.ty=0,this}invert(){this._invertInto(this)}rotate(t){if(t=+t,t!==0){t=t*Ze;let e=Math.cos(t),r=Math.sin(t),a=this.a,i=this.b,o=this.c,l=this.d,h=this.tx,c=this.ty;this.a=a*e-i*r,this.b=a*r+i*e,this.c=o*e-l*r,this.d=o*r+l*e,this.tx=h*e-c*r,this.ty=h*r+c*e}}scale(t,e){t!==1&&(this.a*=t,this.c*=t,this.tx*=t),e!==1&&(this.b*=e,this.d*=e,this.ty*=e)}setTo(t,e,r,a,i,o){return this.a=t,this.b=e,this.c=r,this.d=a,this.tx=i,this.ty=o,this}transformPoint(t,e,r){let a=this.a*t+this.c*e+this.tx,i=this.b*t+this.d*e+this.ty;return r?(r.setTo(a,i,0,1),r):new g(a,i,0,1)}setTranslate(t,e){this.tx=t,this.ty=e}translate(t,e){this.tx+=t,this.ty+=e}mul(t){let e=this,r=t,a=e.a,i=e.b,o=e.c,l=e.d,h=e.tx,c=e.ty,u=r.a,d=r.b,f=r.c,A=r.d,p=r.tx,B=r.ty;d!==0||f!==0?(this.a=a*u+i*f,this.b=a*d+i*A,this.c=o*u+l*f,this.d=o*d+l*A,this.tx=u*h+f*c+p,this.ty=d*h+A*c+B):(this.a=a*u,this.b=i*A,this.c=o*u,this.d=l*A,this.tx=u*h+p,this.ty=A*c+B)}equals(t){return this.a==t.a&&this.b==t.b&&this.c==t.c&&this.d==t.d&&this.tx==t.tx&&this.ty==t.ty}prepend(t,e,r,a,i,o){let l=this.tx;if(t!=1||e!=0||r!=0||a!=1){let h=this.a,c=this.c;this.a=h*t+this.b*r,this.b=h*e+this.b*a,this.c=c*t+this.d*r,this.d=c*e+this.d*a}return this.tx=l*t+this.ty*r+i,this.ty=l*e+this.ty*a+o,this}append(t){let e=this.a,r=this.b,a=this.c,i=this.d;return(t.a!=1||t.b!=0||t.c!=0||t.d!=1)&&(this.a=t.a*e+t.b*a,this.b=t.a*r+t.b*i,this.c=t.c*e+t.d*a,this.d=t.c*r+t.d*i),this.tx=t.tx*e+t.ty*a+this.tx,this.ty=t.tx*r+t.ty*i+this.ty,this}deltaTransformPoint(t){let e=this,r=e.a*t.x+e.c*t.y,a=e.b*t.x+e.d*t.y;return new g(r,a)}toString(){return"(a="+this.a+", b="+this.b+", c="+this.c+", d="+this.d+", tx="+this.tx+", ty="+this.ty+")"}createBox(t,e,r=0,a=0,i=0){let o=this;if(r!==0){r=r*Ze;let l=Math.cos(r),h=Math.sin(r);o.a=l*t,o.b=h*e,o.c=-h*t,o.d=l*e}else o.a=t,o.b=0,o.c=0,o.d=e;o.tx=a,o.ty=i}createGradientBox(t,e,r=0,a=0,i=0){this.createBox(t/1638.4,e/1638.4,r,a+t/2,i+e/2)}_invertInto(t){let e=this.a,r=this.b,a=this.c,i=this.d,o=this.tx,l=this.ty;if(r==0&&a==0){t.b=t.c=0,e==0||i==0?t.a=t.d=t.tx=t.ty=0:(e=t.a=1/e,i=t.d=1/i,t.tx=-e*o,t.ty=-i*l);return}let h=e*i-r*a;if(h==0){t.identity();return}h=1/h;let c=t.a=i*h;r=t.b=-r*h,a=t.c=-a*h,i=t.d=e*h,t.tx=-(c*o+a*l),t.ty=-(r*o+i*l)}getScaleX(){let t=this;if(t.a==1&&t.b==0)return 1;let e=Math.sqrt(t.a*t.a+t.b*t.b);return this.getDeterminant()<0?-e:e}getScaleY(){let t=this;if(t.c==0&&t.d==1)return 1;let e=Math.sqrt(t.c*t.c+t.d*t.d);return this.getDeterminant()<0?-e:e}getSkewX(){return Math.atan2(this.d,this.c)-Math.PI/2}getSkewY(){return Math.atan2(this.b,this.a)}updateScaleAndRotation(t,e,r,a){if((r==0||r==Ms)&&(a==0||a==Ms)){this.a=t,this.b=this.c=0,this.d=e;return}r=r*Ze,a=a*Ze;let i=Math.cos(r),o=Math.sin(r);r==a?(this.a=i*t,this.b=o*t):(this.a=Math.cos(a)*t,this.b=Math.sin(a)*t),this.c=-o*e,this.d=i*e}preMultiplyInto(t,e){let r=t.a*this.a,a=0,i=0,o=t.d*this.d,l=t.tx*this.a+this.tx,h=t.ty*this.d+this.ty;(t.b!==0||t.c!==0||this.b!==0||this.c!==0)&&(r+=t.b*this.c,o+=t.c*this.b,a+=t.a*this.b+t.b*this.d,i+=t.c*this.a+t.d*this.c,l+=t.ty*this.c,h+=t.tx*this.b),e.a=r,e.b=a,e.c=i,e.d=o,e.tx=l,e.ty=h}$transformBounds(t){let e=this.a,r=this.b,a=this.c,i=this.d,o=this.tx,l=this.ty,h=t.x,c=t.y,u=h+t.width,d=c+t.height,f=e*h+a*c+o,A=r*h+i*c+l,p=e*u+a*c+o,B=r*u+i*c+l,F=e*u+a*d+o,U=r*u+i*d+l,Q=e*h+a*d+o,y=r*h+i*d+l,b=0;f>p&&(b=f,f=p,p=b),F>Q&&(b=F,F=Q,Q=b),t.x=Math.floor(f<F?f:F),t.width=Math.ceil((p>Q?p:Q)-t.x),A>B&&(b=A,A=B,B=b),U>y&&(b=U,U=y,y=b),t.y=Math.floor(A<U?A:U),t.height=Math.ceil((B>y?B:y)-t.y)}getDeterminant(){return this.a*this.d-this.b*this.c}}class oi extends ut{constructor(){super(...arguments);s(this,"isGUICanvas",!0);s(this,"index",0)}addChild(e){return this.object3D.addChild(e),this}removeChild(e){return this.object3D.removeChild(e),this}cloneTo(e){e.getOrAddComponent(oi).copyComponent(this)}copyComponent(e){return e.index=e.index,this}}var be=(n=>(n[n.NONE=0]="NONE",n[n.POSITION=1]="POSITION",n[n.SPRITE=2]="SPRITE",n[n.COLOR=4]="COLOR",n[n.MAX=7]="MAX",n))(be||{});class Ai{constructor(t){s(this,"array");s(this,"buffer");this.buffer=new Xe(t,0),this.array=new Float32Array(this.buffer.memory.shareDataBuffer)}}class Zu extends ar{constructor(e){super();s(this,"_attributeUV");s(this,"_attributeVIndex");s(this,"_faceIndexes");s(this,"_uvSize",2);s(this,"_vIndexSize",1);s(this,"_posAttribute");s(this,"_spriteAttribute");s(this,"_colorAttribute");s(this,"_onPositionChange",!0);s(this,"_onSpriteChange",!0);s(this,"_onColorChange",!0);s(this,"maxQuadCount");this.maxQuadCount=e}updateSubGeometry(e,r,a){let i=this.subGeometries[e];if(i){let o=i.lodLevels[0];o.indexStart=r,o.indexCount=a,o.index=e}else i=this.addSubGeometry({indexStart:r,indexCount:a,vertexStart:0,vertexCount:0,firstStart:0,index:e,topology:0});return i}resetSubGeometries(){for(let e of this.subGeometries){let r=e.lodLevels[0];r.indexStart=0,r.indexCount=0,r.index=0}}updateBounds(e,r){let a=Number.MAX_VALUE*.1;return e=new g(-a,-a,-a),r=new g(a,a,a),this.bounds.setFromMinMax(e,r),this}getPositionBuffer(){return this._onPositionChange&&(this._posAttribute.buffer.apply(),this._onPositionChange=!1),this._posAttribute.buffer}getSpriteBuffer(){return this._onSpriteChange&&(this._spriteAttribute.buffer.apply(),this._onSpriteChange=!1),this._spriteAttribute.buffer}getColorBuffer(){return this._onColorChange&&(this._colorAttribute.buffer.apply(),this._onColorChange=!1),this._colorAttribute.buffer}create(){this.createBuffer(),this.updateBounds();let e=this.maxQuadCount,r=[],a=[];for(let o=0;o<e;o++)r.push(...$t.attUV);for(let o=0,l=this.maxQuadCount*$t.vertexCount;o<l;o++)a[o]=o;this._attributeUV=new Float32Array($t.vertexCount*e*this._uvSize),this._attributeVIndex=new Float32Array($t.vertexCount*e*this._vIndexSize),this._attributeUV.set(r,0),this._attributeVIndex.set(a,0);let i=[];for(let o=0;o<e;o++)for(let l=0;l<$t.indecies.length;l++){const h=$t.indecies[l]+o*4;i.push(h)}return this._faceIndexes=new Uint32Array(e*6),this._faceIndexes.set(i,0),this.setIndices(this._faceIndexes),this.setAttribute(k.uv,this._attributeUV),this.setAttribute(k.vIndex,this._attributeVIndex),this.updateSubGeometry(0,0,this._faceIndexes.length),this}createBuffer(){let e=this.maxQuadCount;this._posAttribute=new Ai(e*4),this._spriteAttribute=new Ai(e*12),this._colorAttribute=new Ai(e*4)}fillQuad(e,r){e.dirtyAttributes&be.POSITION&&this.fillQuadPosition(e,r),e.dirtyAttributes&be.COLOR&&this.fillQuadColor(e,r),e.dirtyAttributes&be.SPRITE&&this.fillQuadSprite(e,r)}fillQuadPosition(e,r){ks.setXYZW(this._posAttribute.array,e.z,e.left,e.bottom,e.right,e.top),this._onPositionChange=!0}fillQuadColor(e,r){let a=e.color,i=this._colorAttribute.array;ks.setXYZW(i,e.z,a.r,a.g,a.b,a.a),this._onColorChange=!0}fillQuadSprite(e,r){let a=e.sprite,i=0,o=0;a.isSliced&&e.imageType==Ha.Sliced&&(i=a.trimSize.x,i=(r.width-(a.offsetSize.z-a.trimSize.x))/i,o=a.trimSize.y,o=(r.height-(a.offsetSize.w-a.trimSize.y))/o);let l=a.guiTexture.dynamicId,h=a.uvRec,c=a.uvBorder,u=this._spriteAttribute.array,d=12*e.z;u[d+0]=h.x,u[d+1]=h.y,u[d+2]=h.z,u[d+3]=h.w,u[d+4]=c.x,u[d+5]=c.y,u[d+6]=c.z,u[d+7]=c.w,u[d+8]=i,u[d+9]=o,u[d+10]=l,u[d+11]=e.visible?1:0,this._onSpriteChange=!0}}class Xu{static set(t,e,r,a,...i){let o=e*a+r;for(let l=0,h=i.length;l<h;l++)t[o+l]=i[l]}}class ks extends Xu{static setXYZW(t,e,r,a,i,o){this.set(t,e,0,4,r,a,i,o)}static setXYZ(t,e,r,a,i){this.set(t,e,0,4,r,a,i)}static setZ(t,e,r){this.set(t,e,3,4,r)}}class $t{}s($t,"vertexCount",4),s($t,"attUV",[0,0,1,0,1,1,0,1]),s($t,"indecies",[0,1,2,0,2,3]);class Yu{constructor(){s(this,"_textureMap",new Map);s(this,"_textureList",[])}build(t,e,r){let a=e._geometry;a.resetSubGeometries();let i=-1,o=0,l=0,h=0,c=0,u=this._textureList,d=this._textureMap;function f(){h>0&&(e.updateDrawCallSegment(c,l,h),e._uiRenderer.materials[c].setTextures(u),d.clear(),u.length=0,c++,l+=h,h=0,o=0)}d.clear(),u.length=0;let A=[],p=e.quadMaxCount-1;for(let B of t){let F=B.needUpdateQuads;A.length=0;const U=this.collectQuads(B.object3D,A);for(let Q of U){let y=Q.sprite.guiTexture;if(d.has(y.staticId)||(o==7&&f(),d.set(y.staticId,y),y.dynamicId=o,u[o]=y.texture,o+=1),Q.z=++i,h+=6,Q.cacheTextureId!=y.dynamicId&&(Q.dirtyAttributes=be.MAX,Q.cacheTextureId=y.dynamicId),(F||r)&&(Q.dirtyAttributes=be.MAX),Q.dirtyAttributes&be.POSITION&&Q.applyTransform(B),Q.dirtyAttributes&&Q.writeToGeometry(a,B),i==p)return f(),!0}}return f(),!1}collectQuads(t,e){e||(e=[]);let r=t.components.values();for(let a of r){let i=a;if(i.isUIShadow||!i.mainQuads)continue;let o=i.getShadowRender();o&&this.push(o.mainQuads,e),this.push(i.mainQuads,e)}return e}push(t,e){t&&t.length>0&&e.push(...t)}}const we=class we{static bindTextureArray(){let t="";for(let e=0;e<7;e++)t+=`
        @group(1) @binding(auto)
        var tex_${e}Sampler: sampler;
        @group(1) @binding(auto)
#if VideoTexture${e}
        var tex_${e}: texture_external;
#else
        var tex_${e}: texture_2d<f32>;
#endif
`;return t}static sampleTexture(t){return`
#if VideoTexture${t}
            let size = textureDimensions(tex_${t}).xy - 1;
            uv.y = 1.0 - uv.y;
            let iuv = vec2<i32>(uv * vec2<f32>(size));
            color = textureLoad(tex_${t}, iuv) ;
#else
            color = textureSampleLevel(tex_${t}, tex_${t}Sampler, uv, 0.0);
#endif        `}};s(we,"fs",`
        ${an}
        ${we.bindTextureArray()}

        var<private> fragmentOutput: FragmentOutput;
        var<private> uvSlice: vec2<f32>;
        var<private> EPSILON: f32 = 0.001;
        
        fn sliceBorder(uv:f32, scale:f32, border:vec2<f32>) -> f32 
        {
            var s = uv * scale;
            if(s > border.x){
                s -= border.x;
                let centerPartMax = scale - border.x - border.y;
                let centerPartMin = 1.0 - border.x - border.y;
                if(s < centerPartMax){
                    s = border.x + (s / centerPartMax) * centerPartMin;
                }else{
                    s = s - centerPartMax + border.x + centerPartMin;
                }
            }
            return s;
        }

        fn isInsideAlpha(coord:vec2<f32>, rect:vec4<f32>, cornerRadius0:f32, fadeOutSize0:f32) -> f32
        {
            var minX = min(rect.x, rect.z);
            var maxX = max(rect.x, rect.z);
            var minY = min(rect.y, rect.w);
            var maxY = max(rect.y, rect.w);

            var cornerRadius = max(EPSILON, cornerRadius0);

            var center = vec2<f32>(minX + maxX, minY + maxY) * 0.5;
            var extents = vec2<f32>(maxX - minX, maxY - minY) * 0.5;

            cornerRadius = min(extents.x, cornerRadius);
            cornerRadius = min(extents.y, cornerRadius);
            
            var extendsMin = max(vec2<f32>(0.0), extents - cornerRadius);
            
            var toCenter = abs(coord - center);
            var outerDist = toCenter - extents;
            var innerDist = toCenter - extendsMin;
            
            if(innerDist.x <= 0 && innerDist.y <= 0){
                return 1.0;
            }else if(outerDist.x <= 0 && outerDist.y <= 0){
                var fadeOutPercent = clamp(fadeOutSize0, EPSILON, cornerRadius) / cornerRadius;
                innerDist = max(vec2(EPSILON), innerDist);
                var distance = min(cornerRadius, length(innerDist));
                var alpha = 1.0 - distance / cornerRadius;
                alpha /= fadeOutPercent;
                alpha = clamp(alpha, 0.0, 1.0);
                return alpha;
            }
            return 0.0;
        }
        
        @fragment
        fn FragMain( 
            @location(auto) vUV: vec2<f32>,
            @location(auto) vColor4: vec4<f32>,
            @location(auto) vLocalPos: vec2<f32>,
            @location(auto) vUvRec: vec4<f32>,
            @location(auto) vUvBorder: vec4<f32>,
            @location(auto) vUvSlice: vec2<f32>,
            @location(auto) vTextureID: f32,
            @builtin(front_facing) face: bool,
            @builtin(position) fragCoord : vec4<f32> 
        ) -> FragmentOutput {

            var scissorAlpha = 1.0;
#if SCISSOR_ENABLE
            scissorAlpha = isInsideAlpha(
                vLocalPos.xy,
                materialUniform.scissorRect,
                materialUniform.scissorCornerRadius,
                materialUniform.scissorFadeOutSize);

            if(scissorAlpha < EPSILON){
                discard;
            }
#endif

            uvSlice = vUvSlice;
            
            var uv:vec2<f32> = vUV;
            if(uvSlice.x > 1.0){ uv.x = sliceBorder(uv.x, uvSlice.x, vUvBorder.xz);}
            if(uvSlice.y > 1.0){ uv.y = sliceBorder(uv.y, uvSlice.y, vUvBorder.yw);}
            uv = uv * vUvRec.zw + vUvRec.xy;
            
            var color = vec4<f32>(0.0,0.0,0.0,1.0);
            let texId = i32(vTextureID + 0.5);
            
            var texSize = vec2<i32>(0);
            var coord = vec2<i32>(0);
            
            if(texId == 0){
                ${we.sampleTexture(0)}
            }else if(texId == 1){
                ${we.sampleTexture(1)}
            }else if(texId == 2){
                ${we.sampleTexture(2)}
            }else if(texId == 3){            
                ${we.sampleTexture(3)}
            }else if(texId == 4){            
                ${we.sampleTexture(4)}
            }else if(texId == 5){            
                ${we.sampleTexture(5)}
            }else if(texId == 6){            
                ${we.sampleTexture(6)}
            }
            var rgb = color.rgb;
            var alpha = color.a;

            rgb *= vColor4.rgb;
            alpha *= vColor4.a;
            alpha *= scissorAlpha;
            if(color.a < EPSILON)
            { 
                discard;
            }

            fragmentOutput.color = vec4<f32>(rgb, alpha);
            return fragmentOutput ;
        }`),s(we,"GUI_common_vs",`
        ${rn}
        ${tn}

        struct VertexSpriteBuffer {
            vUvRec: vec4<f32>,
            vUvBorder: vec4<f32>,
            vUvSlice: vec2<f32>,
            vTextureID: f32,
            vVisible: f32
        }
                
        struct MaterialUniform{
            scissorRect:vec4<f32>,

            screenSize:vec2<f32>,
            scissorCornerRadius:f32,
            scissorFadeOutSize:f32,

            pixelRatio:f32,

            v3:vec3<f32>
        }
        
        struct VertexOutput {
            @location(auto) vUV: vec2<f32>,
            @location(auto) vColor4: vec4<f32>,
            @location(auto) vLocalPos: vec2<f32>,
            @location(auto) vUvRec: vec4<f32>,
            @location(auto) vUvBorder: vec4<f32>,
            @location(auto) vUvSlice: vec2<f32>,
            @location(auto) vTextureID: f32,
            
            @builtin(position) member: vec4<f32>
        };
        
         struct VertexInput{
            @builtin(instance_index) index : u32,
            @location(auto) uv: vec2<f32>,
            @location(auto) vIndex: f32,
        }

        @group(2) @binding(0)
        var<uniform> materialUniform : MaterialUniform;
        @group(3) @binding(1)
        var<storage, read> vPositionBuffer: array<vec4<f32>>;
        @group(3) @binding(2)
        var<storage, read> vSpriteBuffer: array<VertexSpriteBuffer>;
        @group(3) @binding(3)
        var<storage, read> vColorBuffer: array<vec4<f32>>;

        var<private> vertexOut: VertexOutput ;

        //quad: (left, bottom, right, top)
        //index: 0~3
        fn getVertexXY(quad:vec4<f32>, index:u32) -> vec2<f32>
        {
            var ret = vec2<f32>(0.0);
            if(index == 0 || index == 3){
                ret.x = quad.x;
            }else{
                ret.x = quad.z;
            }
            if(index == 0 || index == 1){
                ret.y = quad.w;
            }else{
                ret.y = quad.y;
            }
            return ret;
        }
    `),s(we,"GUI_shader_view",`
        ${we.GUI_common_vs}

        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var _m = models.matrix[0];
            var _n = globalUniform.frame;
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var vSpriteData = vSpriteBuffer[quadIndex];
            
            var op = vec2<f32>(0.0001);
            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = 2.0 * vertexPosition * materialUniform.pixelRatio  / materialUniform.screenSize;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = vec4<f32>(op.x, op.y, vertexIndex * 0.0001, 1.0);

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${we.fs}
        `),s(we,"GUI_shader_world",`
        ${we.GUI_common_vs}
        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var modelMatrix = models.matrix[vertex.index];
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var localPos = vec4<f32>(vertexPosition.xy, vertexIndex * 0.0001, 1.0) ;
            var op = vec4<f32>(0.0001);
            var vSpriteData = vSpriteBuffer[quadIndex];

            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = globalUniform.projMat * globalUniform.viewMat * modelMatrix * localPos ;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = op;

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${we.fs}

        `);let ja=we;class Ps extends Fr{constructor(e){super();s(this,"_scissorRect");s(this,"_screenSize",new Ie(1024,768));s(this,"_scissorEnable",!1);s(this,"_videoTextureFlags",{});N.register("GUI_shader_view",ja.GUI_shader_view),N.register("GUI_shader_world",ja.GUI_shader_world);let r=new Ct;this.addColorPass(r,W.COLOR,e),this.addColorPass(r,W.UI,e),this.shader=r}addColorPass(e,r,a){let i=a==Pt.View?"GUI_shader_view":"GUI_shader_world",o=new _e(i,i);o.passType=r,o.setShaderEntry("VertMain","FragMain"),o.setUniformVector4("scissorRect",new j),o.setUniformVector2("screenSize",this._screenSize),o.setUniformFloat("scissorCornerRadius",0),o.setUniformFloat("scissorFadeOutSize",0),o.setUniformFloat("pixelRatio",1),o.setUniformVector3("v3",g.ZERO);let l=o.shaderState;l.depthWriteEnabled=!1,o.blendMode=q.NORMAL,o.depthCompare=a==Pt.View?tr.always:tr.less_equal,o.cullMode=nt.back,e.addRenderPass(o)}setPanelRatio(e){this.shader.setUniformFloat("pixelRatio",e)}setScissorRect(e,r,a,i){this._scissorRect||(this._scissorRect=new j),this._scissorRect.set(e,r,a,i),this.shader.setUniformVector4("scissorRect",this._scissorRect)}setScissorEnable(e){this._scissorEnable!=e&&(this._scissorEnable=e,e?this.shader.setDefine("SCISSOR_ENABLE",!0):this.shader.deleteDefine("SCISSOR_ENABLE"),this.shader.noticeValueChange())}setScissorCorner(e,r){this.shader.setUniformFloat("scissorCornerRadius",e),this.shader.setUniformFloat("scissorFadeOutSize",r)}setScreenSize(e,r){return this._screenSize.set(e,r),this.shader.setUniformVector2("screenSize",this._screenSize),this}setTextures(e){for(let r=0;r<7;r++){let a=e[r]||C.res.whiteTexture;this.shader.setTexture(`tex_${r}`,a),this.setVideoTextureDefine(r,a.isVideoTexture)}}setVideoTextureDefine(e,r){let a=!1;r!=this._videoTextureFlags[e]&&(r?this.shader.setDefine(`VideoTexture${e}`,!0):this.shader.deleteDefine(`VideoTexture${e}`),this._videoTextureFlags[e]=r,a=!0),a&&this.shader.noticeValueChange()}set envMap(e){}set shadowMap(e){}set baseMap(e){}set normalMap(e){}set emissiveMap(e){}set irradianceMap(e){}set irradianceDepthMap(e){}}class Hu extends Be{constructor(){super(...arguments);s(this,"_guiGeometry")}init(e){super.init(),this.addRendererMask(de.UI),this.removeRendererMask(de.Default),this.castGI=!1,this.castShadow=!1,this.alwaysRender=!0,this._ignoreEnvMap=this._ignorePrefilterMap=!0}get geometry(){return super.geometry}set geometry(e){super.geometry=e,this._guiGeometry=e}nodeUpdate(e,r,a,i){for(let o=0;o<this.materials.length;o++){let l=this.materials[o].getPass(r),h=this._guiGeometry.getPositionBuffer(),c=this._guiGeometry.getSpriteBuffer(),u=this._guiGeometry.getColorBuffer();if(l)for(let d=0;d<l.length;d++){const f=l[d];f.pipeline||(f.setStorageBuffer("vPositionBuffer",h),f.setStorageBuffer("vSpriteBuffer",c),f.setStorageBuffer("vColorBuffer",u))}}super.nodeUpdate(e,r,a,i)}onUpdate(e){}}class Ku{constructor(){s(this,"_use");s(this,"_unUse");this._use=[],this._unUse=[]}pushBack(t){let e=this._use.indexOf(t);e!=-1&&(this._use.splice(e,1),this._unUse.push(t))}getUseList(){return this._use}getOne(t,e){let r;return this._unUse.length>0?(r=this._unUse[0],this._unUse.splice(0,1),this._use.push(r),r):(r=new t(e),this._use.push(r),r)}hasFree(){return this._unUse.length>0}}let na;const Jr=class Jr{constructor(){s(this,"x",0);s(this,"y",0);s(this,"z",0);s(this,"width",1);s(this,"height",1);s(this,"_globalX",0);s(this,"_globalY",0);s(this,"_globalWidth",0);s(this,"_globalHeight",0);s(this,"_visible",!0);s(this,"_offsetX",0);s(this,"_offsetY",0);s(this,"_sprite",C.res.defaultGUISprite);s(this,"_color",new Y(1,1,1,1));s(this,"_imageType",Ha.Simple);s(this,"dirtyAttributes",be.MAX);s(this,"cacheTextureId",-1)}static get quadPool(){return this.textPool||(this.textPool=new Ku),this.textPool}static recycleQuad(t){t.sprite=null,t.dirtyAttributes=be.MAX,t.x=0,t.y=0,t.z=-1,t.cacheTextureId=-1,Jr.quadPool.pushBack(t)}static spawnQuad(){return Jr.quadPool.getOne(Jr)}get imageType(){return this._imageType}set imageType(t){this._imageType=t,this.setAttrChange(be.SPRITE|be.POSITION)}get color(){return this._color}set color(t){this._color.copyFrom(t),this.setAttrChange(be.COLOR)}get visible(){return this._visible}set visible(t){t!=this._visible&&(this._visible=t,this.setAttrChange(be.SPRITE))}get sprite(){return this._sprite}set sprite(t){this._sprite!=t&&(this._sprite=t,this.setAttrChange(be.SPRITE|be.POSITION))}get left(){return this._globalX-this._offsetX}get right(){return this.left+this._globalWidth}get top(){return this._globalY-this._offsetY}get bottom(){return this.top+this._globalHeight}setSize(t,e){this.width=t,this.height=e,this.setAttrChange(be.POSITION)}setXY(t,e){this.x=t,this.y=e,this.setAttrChange(be.POSITION)}setAttrChange(t){this.dirtyAttributes=this.dirtyAttributes|t}applyTransform(t){this.setAttrChange(be.POSITION);let e=this._sprite,r=t.getWorldMatrix();(this.x!=0||this.y!=0)&&(r=this.getQuadMatrix(r));let a=r.getScaleX(),i=r.getScaleY(),o=e.isSliced&&this._imageType==Ha.Sliced;if(this._offsetX=t.width*.5*a,this._offsetY=t.height*.5*i,o)this._globalWidth=a*(t.width-(e.offsetSize.z-e.trimSize.x)),this._globalHeight=i*(t.height-(e.offsetSize.w-e.trimSize.y)),this._globalX=r.tx+e.offsetSize.x*a,this._globalY=r.ty+e.offsetSize.y*i;else{let l=this.width/e.offsetSize.z,h=this.height/e.offsetSize.w;this._globalWidth=a*e.trimSize.x*l,this._globalHeight=i*e.trimSize.y*h,this._globalX=r.tx+e.offsetSize.x*l*a,this._globalY=r.ty+e.offsetSize.y*h*i}return this}getQuadMatrix(t){return na||(na=new Hr),na.identity(),na.setTranslate(this.x,this.y),na.mul(t),na}writeToGeometry(t,e){return t.fillQuad(this,e),this.dirtyAttributes=be.NONE,this}};s(Jr,"textPool");let qa=Jr;class ju extends ut{constructor(){super(...arguments);s(this,"_uiTransform");s(this,"_visible",!0)}destroy(){this._uiTransform.setNeedUpdateUIPanel(),super.destroy()}get uiTransform(){return this._uiTransform}get visible(){return this._visible}set visible(e){var r;this._visible!=e&&(this._visible=e,(r=this.onUIComponentVisible)==null||r.call(this,this._visible))}init(e){var r;(r=super.init)==null||r.call(this,e),this._uiTransform=this.object3D.getOrAddComponent(fr),this._uiTransform.setNeedUpdateUIPanel()}copyComponent(e){return this.visible=e.visible,this}}class qu extends ju{constructor(){super(...arguments);s(this,"_mainQuads");s(this,"_shadowRender");s(this,"_shadowSource");s(this,"isUIShadow");s(this,"isShadowless");s(this,"needUpdateShadow")}init(e){var r;(r=super.init)==null||r.call(this,e),this._mainQuads=[]}destroy(){var e,r;this.detachQuads(),(e=this._shadowRender)==null||e.setShadowSource(null),(r=this._shadowSource)==null||r.setShadowRenderer(null),super.destroy(),this._shadowRender=null,this._shadowSource=null}start(){var e;(e=super.start)==null||e.call(this),this.isUIShadow?this.autoBindShadow(null,this):this.isShadowless||this.autoBindShadow(this,null),this.setShadowDirty()}setShadowDirty(){this._shadowRender&&(this._shadowRender.needUpdateShadow=!0)}get mainQuads(){return this._mainQuads}setShadowRenderer(e){this._shadowRender=e}setShadowSource(e){this._shadowSource=e}getShadowRender(){return this._shadowRender}autoBindShadow(e,r){let a=this.object3D.components.values();if(!e)for(let i of a){let o=i;if(!(o.isShadowless||o.isUIShadow)&&o.mainQuads){e=o;break}}if(!r)for(let i of a){let o=i;if(o.isUIShadow&&o.mainQuads){r=o;break}}return e&&r?(e.setShadowRenderer(r),r.setShadowSource(e),!0):!1}recycleQuad(e){if(e&&this._mainQuads){let r=this._mainQuads.indexOf(e);r>=0?(this._mainQuads.splice(r,1),qa.recycleQuad(e)):e=null}return e}attachQuad(e){return this._mainQuads&&this._mainQuads.push(e),this}detachQuads(){if(this._mainQuads)for(;this._mainQuads.length>0;){let e=this._mainQuads.shift();this.recycleQuad(e)}return this}copyComponent(e){return super.copyComponent(e),this.isUIShadow=e.isUIShadow,this.isShadowless=e.isShadowless,this}}class $i extends qu{init(t){var e;(e=super.init)==null||e.call(this,t),this.attachQuad(qa.spawnQuad()),this.sprite=C.res.defaultGUISprite}cloneTo(t){t.getOrAddComponent($i).copyComponent(this)}copyComponent(t){return super.copyComponent(t),this.sprite=t.sprite,this.color=t.color,this.imageType=t.imageType,this}set sprite(t){t||(t=C.res.defaultGUISprite);for(let e of this._mainQuads)e.sprite=t,e.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}onTransformResize(){this.applyTransformSize()}applyTransformSize(){for(let t of this._mainQuads)t.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}get sprite(){return this._mainQuads[0].sprite}onUIComponentVisible(t){this.applyComponentVisible()}onUITransformVisible(t){this.applyComponentVisible()}applyComponentVisible(){let t=!this._visible||!this._uiTransform.globalVisible;for(let e of this._mainQuads)e.visible=!t;this.setShadowDirty()}get color(){return this._mainQuads[0].color}set color(t){for(let e of this._mainQuads)e.color=t;this.setShadowDirty()}get imageType(){return this._mainQuads[0].imageType}set imageType(t){for(let e of this._mainQuads)e.imageType=t;this.setShadowDirty()}}class li extends $i{constructor(){super(...arguments);s(this,"space",Pt.World);s(this,"needUpdateGeometry",!0);s(this,"panelOrder",0);s(this,"needSortOnCameraZ");s(this,"_billboard");s(this,"_rebuild");s(this,"scissorEnable",!1);s(this,"scissorCornerRadius",0);s(this,"scissorFadeOutSize",0);s(this,"_uiRenderer");s(this,"_geometry");s(this,"_maxCount",128);s(this,"panelRatio",1);s(this,"isUIPanel",!0);s(this,"_collectTransform",[])}cloneTo(e){e.getOrAddComponent(li).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.panelOrder=e.panelOrder,this.needSortOnCameraZ=e.needSortOnCameraZ,this.cullMode=e.cullMode,this.billboard=e.billboard,this.scissorEnable=e.scissorEnable,this.scissorCornerRadius=e.scissorCornerRadius,this.scissorFadeOutSize=e.scissorFadeOutSize,this}init(e){super.init(e),this._uiTransform.resize(R.canvas.width,R.canvas.height),this.create(this.space),this.visible=!1}updateDrawCallSegment(e,r,a){this._geometry.updateSubGeometry(e,r,a);let i=this._uiRenderer.material,o=this._uiRenderer.materials[e];if(!o){o=new Ps(this.space);let l=this._uiRenderer.materials.slice();l.push(o),this._uiRenderer.materials=l,o.cullMode=i.cullMode,o.depthCompare=i.depthCompare}}create(e){this._maxCount=this.space==Pt.World?gt.quadMaxCountForWorld:gt.quadMaxCountForView,this._uiRenderer=this.object3D.addComponent(Hu),this._geometry=this._uiRenderer.geometry=new Zu(this._maxCount).create(),this._uiRenderer.material=new Ps(e),this._uiRenderer.renderOrder=gt.SortOrderStartWorld,this._rebuild=new Yu,this.object3D.bound=new Pe(new g,new g(1,1,1).multiplyScalar(Number.MAX_VALUE*.1))}get quadMaxCount(){return this._maxCount}get renderer(){return this._uiRenderer}set billboard(e){this.space==Pt.View&&(e=xr.None,console.warn("Cannot enable billboard in view space")),e==xr.BillboardXYZ||e==xr.BillboardY?(this._billboard=this.object3D.getOrAddComponent(Ka),this._billboard.type=e):(this.object3D.removeComponent(Ka),this._billboard=null)}get billboard(){return this._billboard?this._billboard.type:xr.None}set cullMode(e){if(this.space==Pt.World)for(let r of this._uiRenderer.materials)r.cullMode=e;else console.warn("Cannot change cullMode in view space")}get cullMode(){return this._uiRenderer.material.cullMode}onUpdate(e){var r;(r=super.onUpdate)==null||r.call(this,e),this.rebuildGUIMesh(e)}rebuildGUIMesh(e){let r=this,a=r._collectTransform;if(a.length=0,r.object3D.getComponents(fr,a),a.length>0){r._rebuild.build(a,r,r.needUpdateGeometry);for(const h of a)h.needUpdateQuads=!1}let i=r.object3D.getComponentFromParent(oi),o=i?i.index:0;r._uiRenderer.enable=a.length>0;let l=r.isViewPanel?gt.SortOrderStartView:gt.SortOrderStartWorld;if(r._uiRenderer.renderOrder=o*gt.SortOrderCanvasSpan+l+r.panelOrder,r._uiRenderer.needSortOnCameraZ=r.needSortOnCameraZ,this.space==Pt.View){let h=R.canvas.clientWidth,c=R.canvas.clientHeight,u=this._uiTransform.width,d=this._uiTransform.height;this.panelRatio=this.updateGUIPixelRatio(h,c,u,d)}else this.panelRatio=1;for(let h of r._uiRenderer.materials){let c=h;if(c.setPanelRatio(this.panelRatio),c.setScreenSize(R.canvas.clientWidth,R.canvas.clientHeight),c.setScissorEnable(r.scissorEnable),r.scissorEnable){let u=r.mainQuads[0];c.setScissorRect(u.left,u.bottom,u.right,u.top),c.setScissorCorner(r.scissorCornerRadius,r.scissorFadeOutSize)}}r.needUpdateGeometry=!1}updateGUIPixelRatio(e,r,a,i){let o=a/i,l=e/r,h=1;return o<l?h=r/i:h=e/a,h}}class es extends li{constructor(){super();s(this,"isViewPanel",!0);s(this,"space",Pt.View)}cloneTo(e){e.getOrAddComponent(es).copyComponent(this)}}class ts extends li{constructor(){super();s(this,"isWorldPanel",!0);s(this,"space",Pt.World);s(this,"_depthTest",!0)}cloneTo(e){e.getOrAddComponent(ts).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.depthTest=e.depthTest,this}get depthTest(){return this._depthTest}set depthTest(e){if(this._depthTest!=e){this._depthTest=e;let r=this.depthTest?tr.less_equal:tr.always;for(let a of this._uiRenderer.materials)a.depthCompare=r}}}let Ls;class fr extends ut{constructor(){super();s(this,"useParentPivot",!1);s(this,"parent");s(this,"pivotX",.5);s(this,"pivotY",.5);s(this,"_width",100);s(this,"_height",100);s(this,"_localVisible",!0);s(this,"_globalVisible",!0);s(this,"_uiInteractiveList");s(this,"_localMatrix");s(this,"_worldMatrix");s(this,"_onChange",!0);s(this,"needUpdateQuads",!0);s(this,"_tempTransforms",[]);this._localMatrix=new Hr,this._worldMatrix=new Hr}get uiInteractiveList(){return this._uiInteractiveList}init(e){var r;super.init(e),this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),this.onParentChange(null,(r=this.object3D.parent)==null?void 0:r.object3D)}onTransformChange(e){this.onChange=!0}addUIInteractive(e){return this._uiInteractiveList||(this._uiInteractiveList=[]),this._uiInteractiveList.push(e),this}removeUIInteractive(e){if(this._uiInteractiveList){let r=this._uiInteractiveList.indexOf(e);if(r>=0)return this._uiInteractiveList.slice(r,1),e}return null}get globalVisible(){return this._globalVisible}set visible(e){if(this._localVisible!=e){this._localVisible=e;let r=this.parent?this.parent._globalVisible:!0;this.onUITransformVisible(this._localVisible&&r)}}get visible(){return this._localVisible}onUITransformVisible(e){let r=this._localVisible&&e;r!=this._globalVisible&&(this._globalVisible=r,this.object3D.components.forEach((a,i)=>{let o=a;if(o.onUITransformVisible)if(o==this)for(let l of this.object3D.entityChildren){let h=l.getComponent(fr);h&&h.onUITransformVisible(this._globalVisible)}else o.onUITransformVisible(this._globalVisible)}))}onParentChange(e,r){var a,i;(a=this.parent)==null||a.setNeedUpdateUIPanel(),this.parent=r==null?void 0:r.getComponent(fr),(i=this.parent)==null||i.setNeedUpdateUIPanel()}get width(){return this._width}get height(){return this._height}resize(e,r){var a;if(this._width!=e||this._height!=r){this._width=e,this._height=r,this.onChange=!0;for(let i of this.object3D.components.values())(a=i.onTransformResize)==null||a.call(i);return!0}return!1}get x(){return this.object3D.x}set x(e){e!=this.object3D.x&&(this.object3D.x=e,this.onChange=!0)}get y(){return this.object3D.y}set y(e){e!=this.object3D.y&&(this.object3D.y=e,this.onChange=!0)}setXY(e,r){let a=this.object3D.localPosition;a.set(e,r,a.z),this.object3D.localPosition=a,this.onChange=!0}get z(){return this.object3D.z}set z(e){e!=this.object3D.z&&(this.object3D.z=e,this.onChange=!0)}get scaleX(){return this.object3D.scaleX}set scaleX(e){this.onChange=!0,this.object3D.scaleX=e}get scaleY(){return this.object3D.scaleY}set scaleY(e){this.onChange=!0,this.object3D.scaleY=e}get scaleZ(){return this.object3D.scaleZ}set scaleZ(e){this.onChange=!0,this.object3D.scaleZ=e}get onChange(){return this._onChange}set onChange(e){if(this._onChange!=e&&(this._onChange=e,e)){this._tempTransforms.length=0;let r=this.object3D.getComponents(fr,this._tempTransforms,!0);for(let a of r)a._onChange=!0,a.needUpdateQuads=!0}}onEnable(){this.setNeedUpdateUIPanel(),this.onChange=!0}onDisable(){this.setNeedUpdateUIPanel(),this.onChange=!0}setNeedUpdateUIPanel(){let e;e=this.object3D.getComponentFromParent(ts),e||(e=this.object3D.getComponentFromParent(es)),e&&(e.needUpdateGeometry=!0)}cloneTo(e){let r=e.getOrAddComponent(fr);r.visible=this.visible,r.x=this.x,r.y=this.y,r.z=this.z,r.resize(this.width,this.height),r.pivotX=this.pivotX,r.pivotY=this.pivotY,r.scaleX=this.scaleX,r.scaleY=this.scaleY}matrix(){let e=this._localMatrix,r=this.object3D.rotationZ;return this.parent?(e.updateScaleAndRotation(this.object3D.scaleX,this.object3D.scaleY,r,r),e.tx=this.object3D.x,e.ty=this.object3D.y):e.updateScaleAndRotation(1,1,0,0),(this.pivotX!=.5||this.pivotY!=.5)&&(Ls||(Ls=new Hr().identity()),e.mul(Ls.setTo(1,0,0,1,-(this.pivotX-.5)*this.width,-(this.pivotY-.5)*this.height))),e}getWorldMatrix(){let e=this,r=e._worldMatrix;return this._onChange&&(r.copyFrom(e.matrix()),e.parent&&r.mul(e.parent.getWorldMatrix()),e._onChange=!1),r}beforeDestroy(e){var r;this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),(r=super.beforeDestroy)==null||r.call(this,e)}}class $u{constructor(){s(this,"_ray");s(this,"_mouseCode");s(this,"_clickEvent");s(this,"_outEvent");s(this,"_overEvent");s(this,"_upEvent");s(this,"_downEvent");s(this,"_view");s(this,"_lastDownTarget");s(this,"_lastOverTarget");s(this,"_lastDownPosition",new Ie);s(this,"_calcDistanceVec2",new Ie);s(this,"_lastDownTime",0);s(this,"_clickTimeSpan",200);s(this,"_clickDistanceSpan",10);s(this,"_colliderOut",[]);s(this,"_transformList",[]);s(this,"_sortWorldPanelList",[]);s(this,"_iteractive2PanelDict",new Map)}init(t){this._view=t,this._ray=new ma,this._clickEvent=new ye(ye.PICK_CLICK_GUI),this._outEvent=new ye(ye.PICK_OUT_GUI),this._overEvent=new ye(ye.PICK_OVER_GUI),this._upEvent=new ye(ye.PICK_UP_GUI),this._downEvent=new ye(ye.PICK_DOWN_GUI),C.inputSystem.addEventListener(G.POINTER_DOWN,this.onTouchDown,this,null,1),C.inputSystem.addEventListener(G.POINTER_UP,this.onTouchUp,this,null,1),C.inputSystem.addEventListener(G.POINTER_MOVE,this.onTouchMove,this,null,1),C.inputSystem.addEventListener(G.POINTER_CLICK,this.onTouchClick,this,null,1)}onTouchClick(t){this._lastOverTarget&&t.stopImmediatePropagation()}onTouchMove(t){this._mouseCode=t.mouseCode,this.collectEntities();let e=this.pick(this._colliderOut);if(e){t.stopImmediatePropagation();let r=e.collider;r!=this._lastOverTarget&&(r.mouseStyle=Or.OVER,Object.assign(this._overEvent,t),this._overEvent.type=ye.PICK_OVER_GUI,this._overEvent.target=r.object3D,this._overEvent.data=e,r.object3D.dispatchEvent(this._overEvent),this._lastOverTarget&&(this._lastOverTarget.mouseStyle=Or.NORMAL,Object.assign(this._outEvent,t),this._outEvent.type=ye.PICK_OUT_GUI,this._outEvent.target=r.object3D,this._outEvent.data=e,this._lastOverTarget.object3D.dispatchEvent(this._outEvent))),this._lastOverTarget=r}else this._lastOverTarget&&(this._lastOverTarget.mouseStyle=Or.NORMAL,Object.assign(this._outEvent,t),this._outEvent.type=ye.PICK_OUT_GUI,this._outEvent.target=this._lastOverTarget.object3D,this._outEvent.data=e,this._lastOverTarget.object3D.dispatchEvent(this._outEvent),this._lastOverTarget=null)}onTouchDown(t){this._lastDownTime=Ae.time,this._lastDownPosition.set(t.mouseX,t.mouseY),this._mouseCode=t.mouseCode,this.collectEntities();let e=this.pick(this._colliderOut);e&&t.stopImmediatePropagation();let r=e?e.collider:null;r&&(r.mouseStyle=Or.DOWN,Object.assign(this._downEvent,t),this._downEvent.type=ye.PICK_DOWN_GUI,this._downEvent.target=r.object3D,this._downEvent.data=e,r.object3D.dispatchEvent(this._downEvent)),this._lastDownTarget=r}onTouchUp(t){this._calcDistanceVec2.set(t.mouseX,t.mouseY),this._mouseCode=t.mouseCode,this.collectEntities();let e=this.pick(this._colliderOut);e&&t.stopImmediatePropagation();let r=e?e.collider:null;this._lastDownTarget&&this._lastDownTarget.enable&&(this._lastDownTarget.mouseStyle=Or.NORMAL),r&&r==this._lastDownTarget&&Ae.time-this._lastDownTime<=this._clickTimeSpan&&(this._calcDistanceVec2.set(t.mouseX,t.mouseY),this._calcDistanceVec2.distance(this._lastDownPosition)<=this._clickDistanceSpan&&(Object.assign(this._clickEvent,t),this._clickEvent.type=ye.PICK_CLICK_GUI,this._clickEvent.target=r.object3D,this._clickEvent.data=e,r.object3D.dispatchEvent(this._clickEvent))),this._lastDownTarget=null}collectEntities(){return this._colliderOut.length=0,this._sortWorldPanelList.length=0,this._iteractive2PanelDict.clear(),this._view.canvasList.slice().reverse().forEach(t=>{if(t&&t.transform&&t.transform.parent){let e=t.object3D.getComponentsByProperty("isUIPanel",!0,!0);e.sort((r,a)=>{let i=r._uiRenderer.__renderOrder,o=a._uiRenderer.__renderOrder;return i>o?-1:1});for(let r of e){this._transformList.length=0,r.object3D.getComponents(fr,this._transformList),this._transformList.reverse();for(const a of this._transformList){let i=a.uiInteractiveList;if(i&&i.length>0)for(let o of i)this._colliderOut.push(o),this._iteractive2PanelDict.set(o,r)}}}}),this._colliderOut}pick(t){this._ray=this._view.camera.screenPointToRay(C.inputSystem.mouseX,C.inputSystem.mouseY);let e=new Ie(C.inputSystem.mouseX,C.inputSystem.mouseY),r=new Ie(R.canvas.clientWidth,R.canvas.clientHeight),a;for(const i of t)if(i.interactive&&i.enable&&i.interactiveVisible){let o=this._iteractive2PanelDict.get(i);if(a=i.rayPick(this._ray,o,e,r),a)return a.collider=i,a}return null}}var ed=(n=>(n[n.COLLINEAR=0]="COLLINEAR",n[n.LINES_INTERSECT=1]="LINES_INTERSECT",n[n.SEGMENTS_INTERSECT=2]="SEGMENTS_INTERSECT",n[n.A_BISECTS_B=3]="A_BISECTS_B",n[n.B_BISECTS_A=4]="B_BISECTS_A",n[n.PARALELL=5]="PARALELL",n))(ed||{}),td=(n=>(n[n.ON_LINE=0]="ON_LINE",n[n.LEFT_SIDE=1]="LEFT_SIDE",n[n.RIGHT_SIDE=2]="RIGHT_SIDE",n))(td||{});const Je=class Je{constructor(t,e){s(this,"start");s(this,"end");s(this,"color",new Y(1,1,1,1));s(this,"_normal");s(this,"_normalCalculated",!1);this.start=t,this.end=e}set(t,e){this.start=t,this.end=e}getCenter(){let t=g.HELP_0;return this.start.subtract(this.end,t),t.scaleBy(.5),t.add(this.end),t}inverse(){let t=this.start;this.start=this.end,this.end=t}equals(t){return this.start==t.start&&this.end==t.end||this.start==t.end&&this.end==t.start}toArray(){return[this.start.x,this.start.y,this.start.z,this.end.x,this.end.y,this.end.z]}static getLines(t){let e=[];for(let r=0;r<t.length;r++){let a=r,i=Il(r+1,t.length),o=t[a],l=t[i];e.push(new Je(o,l))}return e}intersection(t,e=null){var r=(t.end.z-t.start.z)*(this.end.x-this.start.x)-(t.end.x-t.start.x)*(this.end.z-this.start.z),a=(t.end.x-t.start.x)*(this.start.z-t.start.z)-(t.end.z-t.start.z)*(this.start.x-t.start.x),i=(t.start.x-this.start.x)*(this.end.z-this.start.z)-(t.start.z-this.start.z)*(this.end.x-this.start.x);if(r==0)return a==0&&i==0?0:5;a=a/r,i=i/r;var o=this.start.x+a*(this.end.x-this.start.x),l=this.start.z+a*(this.end.z-this.start.z);return e!=null&&(e.x=o,e.y=0,e.z=l),a>=0&&a<=1&&i>=0&&i<=1?2:i>=0&&i<=1?3:a>=0&&a<=1?4:1}getDirection(){var t=this.end.subtract(this.start),e=new g(t.x,t.y);return e.normalize()}copyFrom(t){this.start||(this.start=new g),this.end||(this.end=new g),this.start.copyFrom(t.start),this.end.copyFrom(t.end)}static IsEqual(t,e){return Math.abs(t-e)<1e-7}static squreDistanceSegmentToSegment(t,e,r){let a=t.start,i=t.end,o=e.start,l=e.end,h=a.x,c=a.y,u=a.z,d=i.x,f=i.y,A=i.z,p=o.x,B=o.y,F=o.z,U=l.x,Q=l.y,y=l.z,b=d-h,x=f-c,w=A-u,D=U-p,O=Q-B,L=y-F,$=h-p,J=c-B,ue=u-F,ee=b*b+x*x+w*w,se=b*D+x*O+w*L,Ce=D*D+O*O+L*L,me=b*$+x*J+w*ue,Oe=D*$+O*J+L*ue,Ye=ee*Ce-se*se,He=Ye,ot=Ye,Qe=0,dt=0;this.IsEqual(Ye,0)?(Qe=0,He=1,dt=Oe,ot=Ce):(Qe=se*Oe-Ce*me,dt=ee*Oe-se*me,Qe<0?(Qe=0,dt=Oe,ot=Ce):Qe>He&&(Qe=He,dt=Oe+se,ot=Ce)),dt<0?(dt=0,-me<0?Qe=0:-me>ee?Qe=He:(Qe=-me,He=ee)):dt>ot&&(dt=ot,-me+se<0?Qe=0:-me+se>ee?Qe=He:(Qe=-me+se,He=ee));let Cr=0,Qr=0;this.IsEqual(Qe,0)?Cr=0:Cr=Qe/He,this.IsEqual(dt,0)?Qr=0:Qr=dt/ot;let Qa=$+Cr*b-Qr*D,wt=J+Cr*x-Qr*O,or=ue+Cr*w-Qr*L;return Qa*Qa+wt*wt+or*or}isNear(t,e=0,r){let a=g.HELP_0,i=g.HELP_1;a.copyFrom(t.origin),i.copyFrom(t.direction),i.scaleBy(9999),i.add(a,i),Je.cacluteLine0.set(a,i),Je.cacluteLine1.copyFrom(this),r&&(r.perspectiveMultiplyPoint3(Je.cacluteLine1.start,Je.cacluteLine1.start),r.perspectiveMultiplyPoint3(Je.cacluteLine1.end,Je.cacluteLine1.end));let o=Je.squreDistanceSegmentToSegment(Je.cacluteLine0,Je.cacluteLine1,r);return o+1e-4<=e?(t.length=o,!0):(t.length=-999999,!1)}};s(Je,"cacluteLine0",new Je(null,null)),s(Je,"cacluteLine1",new Je(null,null));let Os=Je;var rd=(n=>(n[n.UpperLeft=0]="UpperLeft",n[n.UpperCenter=1]="UpperCenter",n[n.UpperRight=2]="UpperRight",n[n.MiddleLeft=3]="MiddleLeft",n[n.MiddleCenter=4]="MiddleCenter",n[n.MiddleRight=5]="MiddleRight",n[n.LowerLeft=6]="LowerLeft",n[n.LowerCenter=7]="LowerCenter",n[n.LowerRight=8]="LowerRight",n))(rd||{}),ad=(n=>(n[n.Upper=0]="Upper",n[n.Middle=1]="Middle",n[n.Lower=2]="Lower",n))(ad||{}),id=(n=>(n[n.Left=0]="Left",n[n.Center=1]="Center",n[n.Right=2]="Right",n))(id||{}),sd=(n=>(n[n.NONE=0]="NONE",n[n.COLOR=1]="COLOR",n[n.SPRITE=2]="SPRITE",n))(sd||{}),nd=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let gi=class extends ni{constructor(){super()}init(){super.init(),this.lightData.lightType=De.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+Ft())}get range(){return this.lightData.range}set range(n){this.lightData.range=n,this.onChange()}get at(){return this.lightData.linear}set at(n){this.lightData.linear=n,this.onChange()}get radius(){return this.lightData.radius}set radius(n){this.lightData.radius=n,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(n){this.lightData.quadratic=n,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(n){let t=n.scene.getChildByName("graphic3D");if(!t)return;let e=t.createCustomShape(`PointLight_${this.object3D.instanceID}`,this.transform);e.buildAxis(),e.buildCircle(g.ZERO,this.range,32,g.X_AXIS),e.buildCircle(g.ZERO,this.range,32,g.Y_AXIS),e.buildCircle(g.ZERO,this.range,32,g.Z_AXIS)}debug(){}debugDraw(n){}};gi=nd([Tt(gi,"Light")],gi);var od=(n=>(n[n.CastGI=0]="CastGI",n[n.ReceiveGI=1]="ReceiveGI",n[n.CastDepth=2]="CastDepth",n[n.Other=3]="Other",n))(od||{}),ld=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let pi=class extends Be{constructor(){super()}get geometry(){return null}set geometry(n){}cloneTo(n){}set meshURL(n){let t=C.res.getGeometry(n);t?this.geometry=t:console.error("no geometry set",n)}};pi=ld([Tt(pi,"MeshFilter")],pi);var hd=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let wa=class extends Be{constructor(){super();s(this,"skinJointsName");s(this,"mInverseBindMatrixData");s(this,"mInverseBindMatrixBuffer");s(this,"mSkeletonAnimation");s(this,"mJointIndexTableBuffer");this.addRendererMask(de.SkinnedMesh)}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(Dr),!this.skeletonAnimation){let t=this.object3D.parentObject.parentObject.getComponentsInChild(Dr);t.length>0&&(this.skeletonAnimation=t[0]);let e=this.object3D;for(;!this.skeletonAnimation&&e;)this.skeletonAnimation=e.getComponentFromParent(Dr),e.parent&&(e=e.parent.object3D)}}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(t){if(this.mSkeletonAnimation=t,!!t&&!this.mJointIndexTableBuffer){let e=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new Xe(e.length*4,0,new Float32Array(e)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(t){this.mInverseBindMatrixData=t;var e=new Float32Array(t.length*16);for(let r=0;r<t.length;r++){let a=r*16,i=t[r];e.set(i,a)}this.mInverseBindMatrixBuffer=new Xe(e.byteLength,0,e),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(t){let e=t.addComponent(wa);e.geometry=this.geometry,e.material=this.material.clone(),e.castShadow=this.castShadow,e.castGI=this.castGI,e.receiveShadow=this.receiveShadow,e.rendererMask=this.rendererMask,e.skinJointsName=this.skinJointsName,e.skinInverseBindMatrices=this.skinInverseBindMatrices,e.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(t,e,r,a){for(let i=0;i<this.materials.length;i++){let o=this.materials[i].getPass(e);if(o)for(let l=0;l<o.length;l++){const h=o[l];!h.pipeline&&this.mSkeletonAnimation&&(h.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),h.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),h.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(t,e,r,a)}};wa=hd([Tt(wa,"SkinnedMeshRenderer")],wa);class cd extends ie{constructor(){super();s(this,"_envMap");s(this,"skyObject");s(this,"envMapChange",!0);s(this,"view");this.transform.scene3D=this,this.skyObject=new ie,this.addChild(this.skyObject),this._isScene3D=!0,this.envMap||(this.envMap=C.res.defaultSky)}get envMap(){return this._envMap}set envMap(e){this._envMap!=e&&(this.envMapChange=!0),this._envMap=e,P.instance.sky&&"map"in P.instance.sky&&(P.instance.sky.map=e)}get exposure(){return P.instance.sky&&"exposure"in P.instance.sky?P.instance.sky.exposure:0}set exposure(e){P.instance.sky&&"exposure"in P.instance.sky&&(P.instance.sky.exposure=e,C.setting.sky.skyExposure=e)}get roughness(){if(P.instance.sky&&"roughness"in P.instance.sky)return P.instance.sky.roughness}set roughness(e){P.instance.sky&&"roughness"in P.instance.sky&&(P.instance.sky.roughness=e)}}class ud{constructor(){s(this,"_computeShader");s(this,"_outBuffer")}init(){let t=Le.getGBufferFrame(Le.colorPass_GBuffer);this._computeShader=new bt(du),this._outBuffer=new ba(32),this._computeShader.setStorageBuffer("outBuffer",this._outBuffer),this._computeShader.setSamplerTexture("gBufferTexture",t.getCompressGBufferTexture())}compute(t){let e=ce.getCameraGroup(t.camera);this._computeShader.setStorageBuffer("globalUniform",e.uniformGPUBuffer);let r=S.beginCommandEncoder();S.computeCommand(r,[this._computeShader]),S.endCommandEncoder(r),this._outBuffer.readBuffer()}getPickMeshID(){var t=this._outBuffer.outFloat32Array[0]+.1;return Math.floor(t)}getPickWorldPosition(t){t||(t=new g);var e=this._outBuffer.outFloat32Array[4],r=this._outBuffer.outFloat32Array[5],a=this._outBuffer.outFloat32Array[6];return t.set(e,r,a),t}getPickWorldNormal(t){t||(t=new g);var e=this._outBuffer.outFloat32Array[8],r=this._outBuffer.outFloat32Array[9],a=this._outBuffer.outFloat32Array[10];return t.set(e*2-1,r*2-1,a*2-1).normalize(),t}getPickScreenUV(t){t||(t=new Ie);var e=this._outBuffer.outFloat32Array[2],r=this._outBuffer.outFloat32Array[3];return t.set(e,r),t}}class dd extends ra{constructor(e){super();s(this,"ray");s(this,"isTouching",!1);s(this,"_mouseCode");s(this,"_pickEvent");s(this,"_outEvent");s(this,"_overEvent");s(this,"_upEvent");s(this,"_downEvent");s(this,"_mouseMove");s(this,"_pickCompute");s(this,"_lastDownTarget");s(this,"mouseEnableMap");s(this,"_view");s(this,"_lastFocus");s(this,"_interestList",[]);this._view=e,this.init()}init(){this.ray=new ma,this.mouseEnableMap=new Map,this._pickEvent=new G(G.PICK_CLICK),this._outEvent=new G(G.PICK_OUT),this._overEvent=new G(G.PICK_OVER),this._mouseMove=new G(G.PICK_MOVE),this._upEvent=new G(G.PICK_UP),this._downEvent=new G(G.PICK_DOWN)}start(){C.setting.pick.enable&&(C.inputSystem.addEventListener(G.POINTER_DOWN,this.onTouchStart,this),C.inputSystem.addEventListener(G.POINTER_UP,this.onTouchEnd,this),C.inputSystem.addEventListener(G.POINTER_CLICK,this.onTouchOnce,this),C.inputSystem.addEventListener(G.POINTER_RIGHT_CLICK,this.onTouchOnce,this),C.inputSystem.addEventListener(G.POINTER_MOVE,this.onTouchMove,this)),C.setting.pick.mode=="pixel"&&(this._pickCompute=new ud,this._pickCompute.init())}stop(){C.inputSystem.removeEventListener(G.POINTER_DOWN,this.onTouchStart,this),C.inputSystem.removeEventListener(G.POINTER_UP,this.onTouchEnd,this),C.inputSystem.removeEventListener(G.POINTER_CLICK,this.onTouchOnce,this),C.inputSystem.removeEventListener(G.POINTER_RIGHT_CLICK,this.onTouchOnce,this),C.inputSystem.removeEventListener(G.POINTER_MOVE,this.onTouchMove,this)}onTouchStart(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let r=this.findNearestObj(this._interestList,this._view.camera);this._lastDownTarget=r,r&&(Object.assign(this._downEvent,e),this._downEvent.type=G.PICK_DOWN,this._downEvent.target=r.object3D,this._downEvent.data=this.getPickInfo(),this.dispatchEvent(this._downEvent),r.object3D.containEventListener(G.PICK_DOWN)&&r.object3D.dispatchEvent(this._downEvent))}onTouchEnd(e){this.isTouching=!1,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let r=this.findNearestObj(this._interestList,this._view.camera);r&&(Object.assign(this._upEvent,e),this._upEvent.type=G.PICK_UP,this._upEvent.target=r.object3D,this._upEvent.data=this.getPickInfo(),this.dispatchEvent(this._upEvent),r.object3D.containEventListener(G.PICK_UP)&&r.object3D.dispatchEvent(this._upEvent))}getPickInfo(){if(C.setting.pick.mode=="pixel")return{worldPos:this._pickCompute.getPickWorldPosition(),worldNormal:this._pickCompute.getPickWorldNormal(),screenUv:this._pickCompute.getPickScreenUV(),meshID:this._pickCompute.getPickMeshID()};{let e=this._interestList[0];return{worldPos:e.intersectPoint,worldNormal:e.normal,meshID:e.collider.transform.worldMatrix.index,distance:e.distance}}}onTouchMove(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let r=this.findNearestObj(this._interestList,this._view.camera);r&&(Object.assign(this._mouseMove,e),this._mouseMove.type=G.PICK_MOVE,this._mouseMove.target=r.object3D,this._mouseMove.data=this.getPickInfo(),this.dispatchEvent(this._mouseMove),r.object3D.containEventListener(G.PICK_MOVE)&&r.object3D.dispatchEvent(this._mouseMove)),r!=this._lastFocus&&(this._lastFocus&&this._lastFocus.object3D&&(Object.assign(this._outEvent,e),this._outEvent.type=G.PICK_OUT,this._outEvent.target=this._lastFocus.object3D,this._outEvent.data=this.getPickInfo(),this.dispatchEvent(this._outEvent),this._lastFocus.object3D.containEventListener(G.PICK_OUT)&&this._lastFocus.object3D.dispatchEvent(this._outEvent)),r&&(Object.assign(this._overEvent,e),this._overEvent.type=G.PICK_OVER,this._overEvent.target=r.object3D,this._overEvent.data=this.getPickInfo(),this.dispatchEvent(this._overEvent),r.object3D.containEventListener(G.PICK_OVER)&&r.object3D.dispatchEvent(this._overEvent))),this._lastFocus=r}onTouchOnce(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let r=this.findNearestObj(this._interestList,this._view.camera);if(r){let a=this.getPickInfo();Object.assign(this._pickEvent,e),this._pickEvent.type=G.PICK_CLICK,this._pickEvent.target=r.object3D,this._pickEvent.data=a,this.dispatchEvent(this._pickEvent),r===this._lastDownTarget&&r.object3D.containEventListener(G.PICK_CLICK)&&r.object3D.dispatchEvent(this._pickEvent)}this._lastDownTarget=null}findNearestObj(e,r){var a;return e.sort((i,o)=>i.distance>o.distance?1:-1),(a=e[0])==null?void 0:a.collider}pick(e){if(this._interestList.length=0,C.setting.pick.mode=="pixel"){this._pickCompute.compute(this._view);let r=this._pickCompute.getPickMeshID(),a=this.mouseEnableMap.get(r);if(a){let i=this._pickCompute.getPickWorldPosition(),o=g.distance(i,this.ray.origin);this._interestList.push({distance:o,collider:a,intersectPoint:i})}}else if(C.setting.pick.mode=="bound"){this.ray=e.screenPointToRay(C.inputSystem.mouseX,C.inputSystem.mouseY);let r,a=Ue.componentsEnablePickerList.get(this._view);if(a)for(const i of a){let o=i[0];o.enable&&(r=o.rayPick(this.ray),r&&(r.collider=o,this._interestList.push(r)))}}}}class fd extends Na{constructor(e=0,r=0,a=0,i=0){super();s(this,"_camera");s(this,"_scene");s(this,"_viewPort");s(this,"_enablePick",!1);s(this,"_enable",!0);s(this,"pickFire");s(this,"guiPick");s(this,"canvasList");this.canvasList=[],this._viewPort=new j(e,r,a,i)}get enable(){return this._enable}set enable(e){this._enable=e}get enablePick(){return this._enablePick}set enablePick(e){this._enablePick!=e&&(this.pickFire=new dd(this),this.pickFire.start()),this._enablePick=e}get scene(){return this._scene}set scene(e){this._scene=e,e.view=this,mt.createBuffer(this),e&&this.canvasList.forEach(r=>{r&&e.addChild(r.object3D)})}get camera(){return this._camera}set camera(e){this._camera=e}get viewPort(){return this._viewPort}set viewPort(e){this._viewPort=e}enableUICanvas(e=0){let r=this.canvasList[e];if(!r){let a=new ie;a.name="Canvas "+e,r=a.addComponent(oi),r.index=e,this.canvasList[e]=r}return this.scene.addChild(r.object3D),this.guiPick||(this.guiPick=new $u,this.guiPick.init(this)),r}disableUICanvas(e=0){let r=this.canvasList[e];r&&r.object3D&&r.object3D.removeFromParent()}}var Ad=(n=>(n[n.position=3]="position",n[n.normal=3]="normal",n[n.TANGENT=4]="TANGENT",n[n.uv=2]="uv",n[n.TEXCOORD_1=2]="TEXCOORD_1",n[n.color=4]="color",n[n.joints0=4]="joints0",n[n.weights0=4]="weights0",n[n.joints1=4]="joints1",n[n.weights1=4]="weights1",n[n.vIndex=1]="vIndex",n[n.weight=1]="weight",n[n.a_morphPositions_0=3]="a_morphPositions_0",n))(Ad||{});class gd{constructor(){s(this,"min",0);s(this,"max",0)}set(t,e){return this.max=e,this.min=t,this}copy(t){return this.max=t.max,this.min=t.min,this}isInterestRange(t){return!(this.max>t.min||t.max<this.min)}}class pd{constructor(){s(this,"_spaceDesc")}getRange(t){return this._spaceDesc[t]}initSpace(t){this._spaceDesc={};for(let e of t)(this._spaceDesc[e]=new gd).set(-Number.MAX_VALUE,Number.MAX_VALUE);return this}isContain(t,e){let r=this._spaceDesc[t];return e>=r.min&&e<r.max}isInterestRange(t,e){let r=this._spaceDesc[t];return r?e.isInterestRange(r):!1}splitSpace(t,e,r){let a=this._spaceDesc[t];return e?a.max=r:a.min=r,this}copySpace(t){for(let e in t._spaceDesc){let r=t._spaceDesc[e];this._spaceDesc[e].copy(r)}return this}}const zr=class zr{};s(zr,"MaxEntityCountInLeaf",4),s(zr,"MaxLayer",10),s(zr,"ClearLeafLayer",zr.MaxLayer-4);let Aa=zr;const ri=class ri{constructor(){s(this,"uuid","0");this.uuid=(ri.UUID++).toString()}};s(ri,"UUID",0);let Pi=ri;class md{constructor(){s(this,"map",{});s(this,"_count",0)}get count(){return this._count}push(t){return this.map[t.uuid]?!1:(this.map[t.uuid]=t,this._count++,!0)}remove(t){return this.map[t]?(delete this.map[t],this._count--,!0):!1}}const Vt=class Vt extends Pi{constructor(e=0){super();s(this,"_dimensionIndex",0);s(this,"_dimensions");s(this,"_dimension");s(this,"_left");s(this,"_right");s(this,"_space");s(this,"_parent");s(this,"_entities");s(this,"layer");s(this,"_splitEntityList",[]);s(this,"pointIntersect",new g);this.layer=e,Vt.nodeCount++}get dimension(){return this._dimension}initNode(e,r,a){return this._dimensions=r,this._dimensionIndex=a,this._dimension=r[a],this._space=new pd().initSpace(r),e&&this._space.copySpace(e._space),this._parent=e,this._entities=new md,this}updateEntity(e){if(e.isInNode(this,this._dimension)&&(e.attachTreeNode(this),this.autoSplit(),this._left&&this._right)){let r=(this._dimensionIndex+1)%this._dimensions.length,a=this._dimensions[r];e.isInNode(this._right,a)?this._right.updateEntity(e):e.isInNode(this._left,a)&&this._left.updateEntity(e)}}buildRoot(e){for(const r of e)r.entity.attachTreeNode(this);this.autoSplit()}autoSplit(){if(this._entities.count>Aa.MaxEntityCountInLeaf&&!this._right&&!this._left&&this.layer<Aa.MaxLayer){let e=this._splitEntityList,r=(this._dimensionIndex+1)%this._dimensions.length,a=this._dimensions[r],i=0;for(const o in this._entities.map){let l=this._entities.map[o];i+=l.centerValue(a),e.push(l)}i/=this._entities.count,this._left=new Vt(this.layer+1),this._right=new Vt(this.layer+1),this._left.initNode(this,this._dimensions,r),this._right.initNode(this,this._dimensions,r),this._left.setSpace(!0,i),this._right.setSpace(!1,i);for(let o of e)o.isInNode(this._right,a)?o.attachTreeNode(this._right):o.isInNode(this._left,a)&&o.attachTreeNode(this._left)}this._left&&this._left.autoSplit(),this._right&&this._right.autoSplit()}setSpace(e,r){return this._parent&&this._space.splitSpace(this._dimension,e,r),this}isEmpty(){return this._left==null&&this._right==null&&this._entities.count==0}pushEntity(e){return this._entities.push(e)}removeEntity(e){return this._entities.remove(e.uuid)}autoClear(){let e=this;for(;e&&e.layer>Aa.ClearLeafLayer&&e.clearLeaf();)e=e._parent}clearLeaf(){let e=!this._left&&!this._right,r=!e&&this._left.isEmpty()&&this._right.isEmpty();return r&&(this._left=this._right=null,Vt.nodeCount-=2),e||r}isContain(e){return this._space.isContain(this._dimension,e)}nodeIntersectsBox(e){let r=this._space.getRange("x"),a=this._space.getRange("y"),i=this._space.getRange("z"),o=Vt.rangeBox;return o.min.set(r.min,a.min,i.min),o.max.set(r.max,a.max,i.max),o.intersectsBox(e)}nodeIntersectsRay(e){let r=this._space.getRange("x"),a=this._space.getRange("y"),i=this._space.getRange("z"),o=Vt.rangeBox;return o.min.set(r.min,a.min,i.min),o.max.set(r.max,a.max,i.max),!0}pointCast(e,r=0,a){if(a=a||[],this._entities.count>0){let i=this._entities.map;for(let o in i){let l=i[o],h=l.entityContainPoint(e);!h&&r>0&&(h=l.squareDistanceTo(e,this._dimensions)<=r),h&&a.push(l)}}this._left&&this._left.isContain(e[this._left.dimension])&&this._left.pointCast(e,r,a),this._right&&this._right.isContain(e[this._right.dimension])&&this._right.pointCast(e,r,a)}boxCast(e,r){if(r=r||[],this._entities.count>0){let a=this._entities.map;for(let i in a){let o=a[i];o.entityIntersectsBox(e)&&r.push(o)}}this._left&&this._left.nodeIntersectsBox(e)&&this._left.boxCast(e,r),this._right&&this._right.nodeIntersectsBox(e)&&this._right.boxCast(e,r)}rayCast(e,r,a){r=r||[],a=a||[];let i=this.pointIntersect;if(this._entities.count>0){let o=this._entities.map;for(let l in o){let h=o[l];h.entityIntersectsRay(e,i)&&(a.push(new g().copyFrom(i)),r.push(h))}}this._left&&this._left.nodeIntersectsRay(e)&&this._left.rayCast(e,r,a),this._right&&this._right.nodeIntersectsRay(e)&&this._right.rayCast(e,r,a)}};s(Vt,"nodeCount",0),s(Vt,"rangeBox",new Pe(new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),new g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)));let Gs=Vt;var Ud=(n=>(n[n.MOUSE_LEFT=0]="MOUSE_LEFT",n[n.MOUSE_MID=1]="MOUSE_MID",n[n.MOUSE_RIGHT=2]="MOUSE_RIGHT",n))(Ud||{});class Bd{constructor(t,e){s(this,"sourceShader");s(this,"compute");s(this,"needUpdate",!0);this.sourceShader=e,this.compute=new bt(t),this.init()}init(){}onUpdate(){this.onFrame&&this.onFrame(),this.onOnce&&this.needUpdate&&(this.needUpdate=!1,this.onFrame())}}class Fd extends Bd{constructor(t){super(fu,t)}init(){let t=new _t(256,256,H.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);return this.compute.setStorageTexture("sssMap",t),this.sourceShader.setTexture("lutMap",t),t}onFrame(){this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let t=S.beginCommandEncoder();S.computeCommand(t,[this.compute]),S.endCommandEncoder(t)}}class Cd{constructor(){s(this,"indexList");s(this,"color");s(this,"count")}}class Qd{constructor(){s(this,"SlotCount",8);s(this,"MaxEntities",16);s(this,"defaultColor",new Y(.2,1,1,1));s(this,"slots",[]);s(this,"dataDirty",!0);let t=C.setting.render.postProcessing.outline.groupCount;this.SlotCount=Math.max(1,Math.min(t,this.SlotCount));for(let e=0;e<this.SlotCount;e++){let r=this.slots[e]=new Cd;r.indexList=new Float32Array(this.MaxEntities),r.color=this.defaultColor.clone(),r.count=0}}clear(){for(let t=0;t<this.SlotCount;t++)this.clearAt(t)}clearAt(t){this.dataDirty=!0;let e=this.slots[t];return e.color.copyFrom(this.defaultColor),e.indexList.fill(-1),e.count=0,this}fillDataAt(t,e,r){this.dataDirty=!0;let a=this.slots[t];if(a){a.indexList.fill(-1);for(let i=0,o=e.length;i<o;i++)a.indexList[i]=e[i];a.count=e.length,a.color.copyFrom(r)}return this}fetchData(t){return t.dirty=this.dataDirty,t.slots=this.slots,this.dataDirty=!1,this}}new Qd;var vd=(n=>(n.Point="Point",n.LineString="LineString",n.MultiPolygon="MultiPolygon",n))(vd||{});class Sd extends at{constructor(){super(...arguments);s(this,"json")}async parseString(e){this.json=e,this.data=JSON.parse(e)}}s(Sd,"format",ke.JSON);class In{constructor(){s(this,"boneName");s(this,"bonePath");s(this,"parentBoneName");s(this,"boneID");s(this,"parentBoneID");s(this,"instanceID");s(this,"parentInstanceID");s(this,"t");s(this,"q");s(this,"s")}formBytes(t){this.boneName=t.readUTF(),this.bonePath=t.readUTF(),this.parentBoneName=t.readUTF(),this.boneID=t.readInt32(),this.parentBoneID=t.readInt32(),this.instanceID=t.readUTF(),this.parentInstanceID=t.readUTF(),this.t=t.readVector3(),this.q=t.readQuaternion(),this.s=t.readVector3()}}class xn{constructor(){s(this,"name");s(this,"count");s(this,"boneData");s(this,"boneMap")}formBytes(t){this.boneData=[],this.boneMap=new Map,this.name=t.readUTF(),this.count=t.readInt32();for(let e=0;e<this.count;e++){let r=new In;r.formBytes(t.readBytesArray()),this.boneData[e]=r,this.boneMap.set(r.boneName,r)}}}class bn extends at{static parser(t,e){let r=t.readInt32();for(let a=0;a<r;a++){let i=new xn;i.formBytes(t.readBytesArray()),C.res.addObj(i.name,i)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}s(bn,"format",ke.BIN);k.position,k.normal,k.color,k.TANGENT,k.uv,k.TEXCOORD_1,k.TEXCOORD_2,k.TEXCOORD_2,k.TEXCOORD_4,k.TEXCOORD_5,k.TEXCOORD_6,k.TEXCOORD_7,k.joints0,k.weights0;var V=(n=>(n[n.single=0]="single",n[n.boolean=1]="boolean",n[n.int=2]="int",n[n.int16=3]="int16",n[n.int32=4]="int32",n[n.float=5]="float",n[n.long=6]="long",n[n.uint=7]="uint",n[n.uint32=8]="uint32",n[n.uint64=9]="uint64",n[n.double=10]="double",n[n.string=11]="string",n[n.singleArray=12]="singleArray",n[n.stringArray=13]="stringArray",n[n.floatArray=14]="floatArray",n[n.vector2=15]="vector2",n[n.vector3=16]="vector3",n[n.vector4=17]="vector4",n[n.color=18]="color",n[n.color32=19]="color32",n[n.animationCurve=20]="animationCurve",n[n.quaternion=21]="quaternion",n[n.matrix4x4=22]="matrix4x4",n[n.mesh=23]="mesh",n[n.texture=24]="texture",n[n.material=25]="material",n[n.materials=26]="materials",n[n.skeleton=27]="skeleton",n[n.animClip=28]="animClip",n[n.vector2Int=29]="vector2Int",n[n.int32List=30]="int32List",n[n.colorList=31]="colorList",n[n.color32List=32]="color32List",n))(V||{});class mi{static GetMaterial(t){let e=t,r=e.split("/");e=r[r.length-1],r=e.split("."),e=r[r.length-1];let a=Fo(e);if(a){let i=new Fr;return i.shader=new a,i}else throw new Error("not found shader, shader name is "+e)}static applyMaterialTexture(t,e){for(let r=0;r<e.length;r++){const a=e[r];a.property in t?t[a.property]=a.texture:a.property in t.shader?t.shader[a.property]=a.texture:t.setTexture(a.property,a.texture)}}static applyMaterialProperties(t,e){for(let r=0;r<e.length;r++){const a=e[r],i=a.key;switch(a.type){case V.color:case V.color32:{let o=a.getValue();i in t?t[i]=o:i in t.shader?t.shader[i]=o:t.setUniformColor(i,o)}break;case V.single:case V.float:case V.int:case V.int16:case V.int32:case V.uint:case V.uint32:case V.uint64:{let o=a.getValue();i in t?t[i]=o:i in t.shader?t.shader[i]=o:t.setUniformFloat(i,o)}break;case V.singleArray:{let o=a.getValue()[0];i in t?t[i]=o:i in t.shader?t.shader[i]=o:t.setUniformFloat(i,o)}break;case V.vector2:case V.vector2Int:{let o=a.getValue();i in t?t[i]=o:i in t.shader?t.shader[i]=o:t.setUniformVector2(i,o)}break;case V.vector3:{let o=a.getValue();i in t?t[i]=o:i in t.shader?t.shader[i]=o:t.setUniformVector3(i,o)}break;case V.vector4:{let o=a.getValue();i in t?t[i]=o:i in t.shader?t.shader[i]=o:t.setUniformVector4(i,o)}break}}}}class er{static parser(t){switch(t.readInt32()){case V.single:return{t:V.single,v:t.readFloat32()};case V.boolean:return{t:V.boolean,v:t.readBoolean()};case V.int:return{t:V.int,v:t.readInt32()};case V.int16:return{t:V.int16,v:t.readInt16()};case V.int32:return{t:V.int32,v:t.readInt32()};case V.float:return{t:V.float,v:t.readFloat32()};case V.long:return{t:V.long,v:t.readFloat64()};case V.uint:return{t:V.uint,v:t.readUnit32()};case V.uint32:return{t:V.uint32,v:t.readUnit32()};case V.uint64:return{t:V.uint64,v:t.readUnit32()};case V.double:return{t:V.double,v:t.readFloat64()};case V.string:return{t:V.string,v:t.readUTF()};case V.singleArray:return{t:V.singleArray,v:t.readFloatArray()};case V.stringArray:return{t:V.stringArray,v:t.readStringArray()};case V.floatArray:return{t:V.floatArray,v:t.readFloatArray()};case V.vector2:return{t:V.vector2,v:t.readVector2()};case V.vector3:return{t:V.vector3,v:t.readVector3()};case V.vector4:return{t:V.vector4,v:t.readVector4()};case V.color:return{t:V.color,v:t.readColor()};case V.color32:return{t:V.color32,v:t.readColor()};case V.animationCurve:return{t:V.animationCurve,v:null};case V.quaternion:return{t:V.quaternion,v:t.readQuaternion()};case V.matrix4x4:return{t:V.matrix4x4,v:null};case V.mesh:{let o=t.readUTF(),l=C.res.getGeometry(o);return{t:V.mesh,v:l}}case V.texture:{let o=t.readUTF(),l=C.res.getTexture(o);return{t:V.texture,v:l}}case V.material:{let o=t.readUTF(),l=C.res.getMat(o);return{t:V.material,v:l}}case V.materials:{let o=t.readStringArray(),l=[];for(let h=0;h<o.length;h++){const c=o[h];let u=C.res.getMat(c);l.push(u)}return{t:V.materials,v:l}}case V.skeleton:break;case V.animClip:{let o=[],l=t.readInt32();for(let h=0;h<l;h++){let c=new Mn;c.formBytes(t),o.push(c)}return{t:V.animClip,v:o}}case V.vector2Int:return{t:V.vector2Int,v:t.readVector2int()};case V.int32List:return{t:V.int32List,v:t.readInt32List()};case V.colorList:let e=t.readInt32(),r=[];for(let o=0;o<e;o++){const l=er.parser(t).v;r.push(l)}return{t:V.colorList,v:r};case V.color32List:let a=t.readInt32(),i=[];for(let o=0;o<a;o++){const l=er.parser(t).v;i.push(l)}return{t:V.color32List,v:i}}}}class _n{constructor(){s(this,"key");s(this,"type");s(this,"_data")}getValue(){return this._data}formBytes(t){this.key=t.readUTF();let{t:e,v:r}=er.parser(t);this.type=e,this._data=r}}class Rd{constructor(){s(this,"property");s(this,"name");s(this,"texture");s(this,"texelSize");s(this,"wrapModeU");s(this,"wrapModeV");s(this,"wrapModeW");s(this,"wrapMode");s(this,"anisoLevel");s(this,"dimension");s(this,"filterMode")}}class Tn extends at{static parserMaterial(t,e){let r=t.readInt32();for(let a=0;a<r;a++){let i=t.readBytesArray(),o=i.readUTF(),l=i.readUTF();i.readUTF();let h=i.readStringArray();i.readVector4(),i.readVector4();let c=i.readUTF(),u=[],d=[],f=i.readInt32();for(let B=0;B<f;B++){let F=new _n;F.formBytes(i),u.push(F)}let A=i.readInt32();for(let B=0;B<A;B++){let F=i.readBytesArray(),U=new Rd;U.property=F.readUTF(),U.name=F.readUTF(),U.texture=C.res.getTexture(U.name),U.texelSize=F.readVector2(),U.wrapModeU=F.readUnit32(),U.wrapModeV=F.readUnit32(),U.wrapModeW=F.readUnit32(),U.wrapMode=F.readUnit32(),U.anisoLevel=F.readUnit32(),U.dimension=F.readUnit32(),U.filterMode=F.readUnit32(),d.push(U)}let p=mi.GetMaterial(c);p.name=o;for(let B=0;B<h.length;B++){const F=h[B];p.shader.setDefine(F,!0)}mi.applyMaterialTexture(p,d),mi.applyMaterialProperties(p,u),C.res.addMat(l,p)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}s(Tn,"format",ke.TEXT);class wn{constructor(){s(this,"shapeName");s(this,"shapeIndex");s(this,"frameCount");s(this,"blendPositionList",new Float32Array);s(this,"blendNormalList",new Float32Array)}formBytes(t){let e=t.readBytesArray();this.shapeName=e.readUTF(),this.shapeIndex=e.readInt32(),this.frameCount=e.readInt32();let r=e.readInt32();this.blendPositionList=e.readFloat32Array(r*3);let a=e.readInt32();this.blendNormalList=e.readFloat32Array(a*3)}}class Dn{constructor(){s(this,"vertexCount");s(this,"shapeNames");s(this,"shapeIndexs");s(this,"blendCount");s(this,"blendShapePropertyDatas");s(this,"blendShapeMap")}formBytes(t){this.blendShapeMap=new Map,this.blendShapePropertyDatas=[];let e=t.readBytesArray();this.vertexCount=e.readInt32(),this.shapeNames=e.readStringArray(),this.shapeIndexs=e.readIntArray(),this.blendCount=e.readInt32();for(let r=0;r<this.blendCount;r++){let a=new wn;a.formBytes(e),this.blendShapePropertyDatas.push(a),this.blendShapeMap.set(a.shapeName,a)}return t}}class Ed{constructor(){s(this,"name");s(this,"meshName");s(this,"meshID");s(this,"vertexCount");s(this,"vertexStrip");s(this,"vertexBuffer");s(this,"indices");s(this,"attributes");s(this,"bones");s(this,"bindPose");s(this,"blendShapeData")}}class Vn extends at{async parseBuffer(t){}static parserMeshs(t,e){let r=t.readInt32();for(let a=0;a<r;a++){let i=new Ed,o=t.readBytesArray();i.meshName=o.readUTF(),i.meshID=o.readUTF(),o.readFloat32()>0,o.readFloat32()>0,o.readFloat32()>0;let l=o.readFloat32()>0,h=o.readFloat32()>0;l&&(i.bones=o.readStringArray(),i.bindPose=o.readMatrix44Array()),h&&(i.blendShapeData=new Dn,i.blendShapeData.formBytes(o));let c=o.readBytesArray(),u=o.readBytesArray(),d=c.readInt32(),f=0,A=[];for(let Q=0;Q<d;Q++)A[Q]={},A[Q].att=yd[c.readUTF()],A[Q].dim=c.readInt32(),f+=A[Q].dim,A[Q].format=c.readUTF();i.vertexCount=c.readInt32(),i.vertexBuffer=u.getFloat32Array();let p=o.readInt32Array(),B=[],F=o.readInt32();for(let Q=0;Q<F;Q++){let y=o.readInt32(),b=o.readInt32(),x=o.readInt32(),w=o.readInt32(),D=o.readInt32(),O=o.readInt32();o.readVector3(),o.readVector3();let L={indexStart:b,indexCount:x,vertexStart:w,vertexCount:O,firstStart:D,topology:y,index:Q};B.push(L)}p.length>65535?i.indices=new Uint32Array(p):i.indices=new Uint16Array(p);let U=new ar;if(U.vertexDim=f,U.geometryType=qe.compose_bin,U.setIndices(i.indices),U.setAttribute(k.all,i.vertexBuffer),l&&(U.skinNames=i.bones,U.bindPose=i.bindPose),h){U.blendShapeData=i.blendShapeData,U.morphTargetsRelative=!0,U.morphTargetDictionary={};for(let Q=0;Q<i.blendShapeData.blendCount;Q++){U.setAttribute("a_morphPositions_"+Q,i.blendShapeData.blendShapePropertyDatas[Q].blendPositionList),U.setAttribute("a_morphNormals_"+Q,i.blendShapeData.blendShapePropertyDatas[Q].blendNormalList);for(let y=0;y<i.blendShapeData.blendCount;y++){let b=i.blendShapeData.shapeNames[y],x=i.blendShapeData.shapeIndexs[y];U.morphTargetDictionary[b]=x}}}for(let Q=0;Q<A.length;Q++){const y=A[Q].att;U.setAttribute(y,null)}for(let Q=0;Q<B.length;Q++){const y=B[Q];U.addSubGeometry(y)}U.name=i.meshName,C.res.addGeometry(i.meshID,U)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}s(Vn,"format",ke.BIN);let yd={Position:k.position,Normal:k.normal,Color:k.color,Tangent:k.TANGENT,TexCoord0:k.uv,TexCoord1:k.TEXCOORD_1,TexCoord2:k.TEXCOORD_2,TexCoord3:k.TEXCOORD_2,TexCoord4:k.TEXCOORD_4,TexCoord5:k.TEXCOORD_5,TexCoord6:k.TEXCOORD_6,TexCoord7:k.vIndex,BlendIndices:k.joints0,BlendWeight:k.weights0};class rs extends DataView{constructor(e,r,a){super(e,r,a);s(this,"position",0);s(this,"littleEndian",!0);this.position=0,this.position+=this.byteOffset}readUTF(){let e=this.readInt32(),r=e%4;r>0&&r<4&&(r=4-r);let a="",i=new Int8Array(this.buffer,this.position,e);return this.position+=e*Int8Array.BYTES_PER_ELEMENT,a+=String.fromCharCode.apply(null,i),this.position+=r*Int8Array.BYTES_PER_ELEMENT,a}readStringArray(){let e=[],r=this.readInt32();for(let a=0;a<r;a++)e.push(this.readUTF());return e}readByte(){let e=this.buffer[this.position];return this.position+=1,e}readBoolean(){let e=this.readInt32();return this.position+=4,e==1}readBytes(e){let r=new DataView(this.buffer,this.position,e);return this.position+=e,r.buffer}readBytesArray(){let e=this.readInt32(),r=new rs(this.buffer.slice(this.position,this.position+e));return this.position+=e,r}readUnit8(){let e=this.getUint8(this.position);return this.position+=Uint8Array.BYTES_PER_ELEMENT,e}readUnit16(){let e=this.getUint16(this.position);return this.position+=Uint16Array.BYTES_PER_ELEMENT,e}readUnit32(){let e=this.getUint32(this.position);return this.position+=Uint32Array.BYTES_PER_ELEMENT,e}readInt8(){let e=this.getInt8(this.position);return this.position+=Int8Array.BYTES_PER_ELEMENT,e}readInt16(){let e=this.getInt16(this.position,this.littleEndian);return this.position+=Int16Array.BYTES_PER_ELEMENT,e}readInt32(){let e=this.getInt32(this.position,this.littleEndian);return this.position+=Int32Array.BYTES_PER_ELEMENT,e}readFloat32(){let e=this.getFloat32(this.position,this.littleEndian);return this.position+=Float32Array.BYTES_PER_ELEMENT,e}readFloat64(){let e=this.getFloat64(this.position,this.littleEndian);return this.position+=Float64Array.BYTES_PER_ELEMENT,e}readInt32Array(){let e=this.readInt32(),r=new Int32Array(this.buffer,this.position,e);return r=r.slice(0,e),this.position+=r.byteLength,r}readInt32List(){let e=this.readInt32(),r=[];for(let a=0;a<e;a++)r.push(this.readInt32());return r}readFloatArray(){let e=this.readInt32(),r=[];for(let a=0;a<e;a++){let i=this.readFloat32();r.push(i)}return r}readIntArray(){let e=this.readInt32(),r=[];for(let a=0;a<e;a++){let i=this.readInt32();r.push(i)}return r}readVector2int(){let e=new Ie;return e.x=this.readInt32(),e.y=this.readInt32(),e}readVector2(){let e=new Ie;return e.x=this.readFloat32(),e.y=this.readFloat32(),e}readVector3(){let e=new g;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e}readVector3Array(){let e=[],r=this.readInt32();for(let a=0;a<r;a++)e.push(this.readVector3());return e}readVector4(){let e=new j;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e.w=this.readFloat32(),e}readVector4Array(){let e=[],r=this.readInt32();for(let a=0;a<r;a++)e.push(this.readVector4());return e}readColor(){let e=new Y;return e.r=this.readFloat32(),e.g=this.readFloat32(),e.b=this.readFloat32(),e.a=this.readFloat32(),e}readColorArray(){let e=[],r=this.readInt32();for(let a=0;a<r;a++)e.push(this.readColor());return e}readQuaternion(){let e=new X;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e.w=this.readFloat32(),e}readQuaternionArray(){let e=[],r=this.readInt32();for(let a=0;a<r;a++)e.push(this.readQuaternion());return e}readMatrix44(){let e=new Z,r=e.rawData;return r[0]=this.readFloat32(),r[1]=this.readFloat32(),r[2]=this.readFloat32(),r[3]=this.readFloat32(),r[4]=this.readFloat32(),r[5]=this.readFloat32(),r[6]=this.readFloat32(),r[7]=this.readFloat32(),r[8]=this.readFloat32(),r[9]=this.readFloat32(),r[10]=this.readFloat32(),r[11]=this.readFloat32(),r[12]=this.readFloat32(),r[13]=this.readFloat32(),r[14]=this.readFloat32(),r[15]=this.readFloat32(),e}readMatrix44Array(){let e=this.readInt32(),r=[];for(let a=0;a<e;a++){let i=this.readMatrix44();r.push(i)}return r}readFloat32Array(e){let r=new Float32Array(this.buffer,this.position,e);return r=r.slice(0,this.byteLength),this.position+=e*Float32Array.BYTES_PER_ELEMENT,r}getFloat32Array(){let e=new Float32Array(this.buffer,this.byteOffset,this.byteLength/Float32Array.BYTES_PER_ELEMENT);return e=e.slice(0,this.byteLength),e}}class Nn extends at{static async parserTexture(t,e,r){let a=t.readInt32(),i=[];for(let l=0;l<a;l++){let h=t.readUTF();Li.useWebp?(h=h.replace("png","webp"),h=h.replace("jpb","webp"),i.push(e.baseUrl+"webp/"+h)):i.push(e.baseUrl+h)}let o=await C.res.loadBitmapTextures(i,C.setting.loader.numConcurrent,r,!0);for(const l of o)C.res.addTexture(l.name,l)}verification(){if(this.data)return!0;throw new Error("verify failed.")}}s(Nn,"format",ke.TEXT);var Id=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let Ws=class extends Ct{constructor(){super(),N.register("PBRLitSSSShader",mu);let n=new _e("PBRLitSSSShader","PBRLitSSSShader");n.setShaderEntry("VertMain","FragMain"),this.addRenderPass(n);let t=n.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefine("USE_CUSTOMUNIFORM",!0),this.setDefault(),this.debug(),this.computes=[new Fd(this)]}debug(){}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new j(0,0,1,1)),this.setUniformVector4("transformUV2",new j(0,0,1,1)),this.setUniformColor("baseColor",new Y),this.setUniformColor("emissiveColor",new Y(1,1,1)),this.setUniformVector4("materialF0",new j(.04,.04,.04,1)),this.setUniformColor("specularColor",new Y(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",0),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new Y(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this.setUniformColor("skinColor",new Y(1,0,0)),this.setUniformFloat("skinPower",3.4),this.setUniformFloat("skinColorIns",.5),this.setUniformFloat("curveFactor",1)}set _MainTex(n){this.setTexture("baseMap",n)}set _BumpMap(n){this.setTexture("normalMap",n)}set _SSSMap(n){this.setTexture("sssMap",n)}set _MaskTex(n){this.setTexture("maskMap",n)}set _UVTransform(n){this.setUniformVector4("transformUV1",n)}set _Metallic(n){this.setUniformFloat("metallic",n)}set _Roughness(n){this.setUniformFloat("roughness",n)}set _MainColor(n){this.setUniformColor("baseColor",n)}set _AlphaCutoff(n){this.setUniformFloat("alphaCutoff",n)}set _DoubleSidedEnable(n){let t=this.getDefaultColorShader();t.shaderState.cullMode=n?nt.none:t.shaderState.cullMode}set _SkinColor(n){this.setUniformColor("skinColor",n)}set _SkinPower(n){this.setUniformFloat("skinPower",n)}set _SkinColorIns(n){this.setUniformFloat("skinColorIns",n)}set curveFactor(n){this.setUniformFloat("curveFactor",n)}set _SurfaceType(n){let t=this.getDefaultColorShader();n==0?t.blendMode=q.NONE:t.blendMode=q.ALPHA}set _AlphaCutoffEnable(n){n==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Ws=Id([Mr],Ws);var xd=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let Js=class extends Ct{constructor(){super();let n=new _e("PBRLItShader","PBRLItShader");n.setShaderEntry("VertMain","FragMain"),this.addRenderPass(n);let t=n.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new j(0,0,1,1)),this.setUniformVector4("transformUV2",new j(0,0,1,1)),this.setUniformColor("baseColor",new Y),this.setUniformColor("emissiveColor",new Y(0,0,0)),this.setUniformVector4("materialF0",new j(.04,.04,.04,1)),this.setUniformColor("specularColor",new Y(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",0),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new Y(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this._MainTex=C.res.grayTexture,this._BumpMap=C.res.normalTexture,this._MaskTex=C.res.maskTexture}set _MainTex(n){this.setTexture("baseMap",n)}set _BumpMap(n){this.setTexture("normalMap",n)}set _MaskTex(n){this.setTexture("maskMap",n)}set _UVTransform(n){this.setUniformVector4("transformUV1",n)}set _Metallic(n){this.setUniformFloat("metallic",n)}set _Roughness(n){this.setUniformFloat("roughness",n)}set _MainColor(n){this.setUniformColor("baseColor",n)}set _AlphaCutoff(n){this.setUniformFloat("alphaCutoff",n)}set _DoubleSidedEnable(n){let t=this.getDefaultColorShader();t.shaderState.cullMode=n?nt.none:t.shaderState.cullMode}set _SurfaceType(n){let t=this.getDefaultColorShader();n==0?t.blendMode=q.NONE:t.blendMode=q.ALPHA}set _AlphaCutoffEnable(n){n==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Js=xd([Mr],Js);class as{constructor(){s(this,"comName");s(this,"data")}static parser(t){let e=t.readBytesArray(),r=new as;r.comName=e.readUTF(),r.data=[];let a=e.readInt32();for(let i=0;i<a;i++){let o=new _n;o.formBytes(e),r.data.push(o)}return r}}class $a{constructor(){s(this,"name");s(this,"parentName");s(this,"position");s(this,"rotation");s(this,"scale");s(this,"comDatas");s(this,"child")}static parser(t){let e=t.readBytesArray(),r=new $a;r.name=e.readUTF(),r.parentName=e.readUTF(),r.position=e.readVector3(),r.rotation=e.readQuaternion(),r.scale=e.readVector3(),r.comDatas=[],r.child=[];let a=e.readInt32();for(let o=0;o<a;o++){const l=as.parser(e);r.comDatas.push(l)}let i=e.readInt32();for(let o=0;o<i;o++){const l=$a.parser(e);r.child.push(l)}return r}}class Li extends at{constructor(){super(...arguments);s(this,"avatarDic");s(this,"nodeData")}async parseBuffer(e){this.avatarDic={};let r=new rs(e,0);await Nn.parserTexture(r,this,this.loaderFunctions),bn.parser(r,this),Vn.parserMeshs(r,this),Tn.parserMaterial(r,this),this.nodeData=this.parserPrefabNode(r),this.data=this.data=this.parserNodeTree(this.nodeData)}parserPrefabNode(e){return $a.parser(e)}parserNodeTree(e){let r=new ie;if(r.localPosition=g.serialize(e.position),r.localQuaternion=X.serialize(e.rotation),r.localScale=g.serialize(e.scale),r.name=e.name,e.comDatas)for(let a=0;a<e.comDatas.length;a++){const i=e.comDatas[a];let o=null,l=Bo(i.comName);if(l){o=r.getOrAddComponent(l);for(let h=0;h<i.data.length;h++){const c=i.data[h];c.key in o&&(o[c.key]=c.getValue())}}}if(e.child&&e.child.length>0)for(let a=0;a<e.child.length;a++){let i=this.parserNodeTree(e.child[a]);r.addChild(i)}return r}verification(){if(this.data)return!0;throw new Error("verify failed.")}}s(Li,"useWebp",!0),s(Li,"format",ke.BIN);var bd=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let zs=class extends Ct{constructor(){super(),this.create_opPass(),this.setDefine("USEC",!0),this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefine("USE_HAIR",!0),this.setDefine("USE_CUSTOMUNIFORM",!0),this.setDefine("USE_HAIRCOLOR",!0),this.setDefault(),this.debug()}create_opPass(){N.register("HairShader_op",gu);let n=new _e("HairShader_op","HairShader_op");this.addRenderPass(n),n.setShaderEntry("VertMain","FragMain");let t=n.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,t.blendMode=q.NONE,t.cullMode=nt.none,t.writeMasks[0]=GPUColorWrite.ALL}create_trPass(){N.register("HairShader_tr",pu);let n=new _e("HairShader_tr","HairShader_tr");this.addRenderPass(n),n.setShaderEntry("VertMain","FragMain");let t=n.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,t.depthWriteEnabled=!1,t.blendMode=q.NORMAL,t.cullMode=nt.none,t.writeMasks[0]=GPUColorWrite.ALL,t.writeMasks[1]=0,t.writeMasks[2]=0,t.writeMasks[3]=0}debug(){}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new j(0,0,1,1)),this.setUniformVector4("transformUV2",new j(0,0,1,1)),this.setUniformColor("baseColor0",new Y(3/255,2/255,2/255)),this.setUniformColor("baseColor1",new Y(2/255,2/255,2/255)),this.setUniformColor("emissiveColor",new Y(1,1,1)),this.setUniformVector4("materialF0",new j(.04,.04,.04,1)),this.setUniformColor("specularColor",new Y(36/255,36/255,36/255)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",.1),this.setUniformFloat("metallic",.3),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",.1),this.setUniformFloat("ior",1.5),this.setUniformFloat("backlit",.3987),this.setUniformFloat("area",.0615)}set _MainTex(n){this.setTexture("baseMap",n)}set _IDMap(n){this.setTexture("idMap",n)}set _DepthMap(n){this.setTexture("depthMap",n)}set _RootMap(n){this.setTexture("rootMap",n)}set _AlphaMap(n){this.setTexture("alphaMap",n)}set _UVTransform(n){this.setUniformVector4("transformUV1",n)}set _Metallic(n){this.setUniformFloat("metallic",n)}set _Roughness(n){this.setUniformFloat("roughness",n)}set _HairColor0(n){this.setUniformColor("baseColor0",n)}set _HairColor1(n){this.setUniformColor("baseColor1",n)}set _SpecularColor(n){this.setUniformColor("specularColor",n)}set _AlphaCutoff(n){this.setUniformFloat("alphaCutoff",n)}set _BackLit(n){this.setUniformFloat("backlit",n)}set _Area(n){this.setUniformFloat("area",n)}set _DoubleSidedEnable(n){let t=this.getSubShaders(W.COLOR)[0];t.shaderState.cullMode=n?nt.none:t.shaderState.cullMode}set _SurfaceType(n){}set _AlphaCutoffEnable(n){n==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};zs=bd([Mr],zs);var _d=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let Zs=class extends Ct{constructor(){super();let n=new _e("UnLit","UnLit");n.setShaderEntry("VertMain","FragMain"),this.addRenderPass(n);let t=n.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformVector4("transformUV1",new j(0,0,1,1)),this.setUniformVector4("transformUV2",new j(0,0,1,1)),this.setUniformColor("baseColor",new Y),this.setUniformFloat("alphaCutoff",0)}set _MainTex(n){this.setTexture("baseMap",n)}set _BumpMap(n){this.setTexture("normalMap",n)}set _MaskTex(n){this.setTexture("maskMap",n)}set _UVTransform(n){this.setUniformVector4("transformUV1",n)}set _Metallic(n){this.setUniformFloat("metallic",n)}set _Roughness(n){this.setUniformFloat("roughness",n)}set _MainColor(n){this.setUniformColor("baseColor",n)}set _AlphaCutoff(n){this.setUniformFloat("alphaCutoff",n)}set _DoubleSidedEnable(n){let t=this.getDefaultColorShader();t.shaderState.cullMode=n?nt.none:t.shaderState.cullMode}set _SurfaceType(n){let t=this.getDefaultColorShader();n==0?t.blendMode=q.NONE:t.blendMode=q.ALPHA}set _AlphaCutoffEnable(n){n==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Zs=_d([Mr],Zs);var Td=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let Xs=class extends Ct{constructor(){super(),N.register("VertexAttributeIndexShader",Au),N.register("UnLitTextureArray",Uu);let n=new _e("UnLitTextureArray","UnLitTextureArray");n.setShaderEntry("VertMain","FragMain"),this.addRenderPass(n);let t=n.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformVector4("transformUV1",new j(0,0,1,1)),this.setUniformVector4("transformUV2",new j(0,0,1,1)),this.setUniformColor("baseColor",new Y),this.setUniformFloat("alphaCutoff",0)}set _MainTex(n){this.setTexture("baseMap",n)}set _BumpMap(n){this.setTexture("normalMap",n)}set _MaskTex(n){this.setTexture("maskMap",n)}set _UVTransform(n){this.setUniformVector4("transformUV1",n)}set _Metallic(n){this.setUniformFloat("metallic",n)}set _Roughness(n){this.setUniformFloat("roughness",n)}set _MainColor(n){this.setUniformColor("baseColor",n)}set _AlphaCutoff(n){this.setUniformFloat("alphaCutoff",n)}set _DoubleSidedEnable(n){let t=this.getDefaultColorShader();t.shaderState.cullMode=n?nt.none:t.shaderState.cullMode}set _SurfaceType(n){let t=this.getDefaultColorShader();n==0?t.blendMode=q.NONE:t.blendMode=q.ALPHA}set _AlphaCutoffEnable(n){n==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Xs=Td([Mr],Xs);var wd=(n,t,e,r)=>{for(var a=t,i=n.length-1,o;i>=0;i--)(o=n[i])&&(a=o(a)||a);return a};let Ui=class extends ut{constructor(){super(...arguments);s(this,"size");s(this,"blockSize");s(this,"walk");s(this,"obs");s(this,"colors");s(this,"aPaths")}onGraphic(t){}};Ui=wd([Tt(Ui,"APatch")],Ui);class Mn{constructor(){s(this,"clipName");s(this,"loopTime");s(this,"startTime");s(this,"stopTime");s(this,"sampleRate");s(this,"useSkeletonPos");s(this,"useSkeletonScale");s(this,"positionCurves",new Map);s(this,"rotationCurves",new Map);s(this,"scaleCurves",new Map);s(this,"floatCurves",new Map)}formBytes(t){if(this.clipName=t.readUTF(),this.loopTime=!t.readInt32(),this.startTime=t.readFloat32(),this.stopTime=t.readFloat32(),this.sampleRate=t.readInt32(),this.useSkeletonPos=t.readInt32()>0,this.useSkeletonScale=t.readInt32()>0,this.useSkeletonPos){let a=t.readInt32();for(let i=0;i<a;i++){let o=new br;o.formBytes(t),this.positionCurves.set(o.path,o)}}let e=t.readInt32();for(let a=0;a<e;a++){let i=new br;i.formBytes(t),this.rotationCurves.set(i.path,i)}if(this.useSkeletonScale){let a=t.readInt32();for(let i=0;i<a;i++){let o=new br;o.formBytes(t),this.scaleCurves.set(o.path,o)}}let r=t.readInt32();for(let a=0;a<r;a++){let i=new br;i.formBytes(t),this.floatCurves.set(i.attribute,i)}}}class br{constructor(t=1){s(this,"path");s(this,"attribute");s(this,"propertys");s(this,"preInfinity");s(this,"postInfinity");s(this,"rotationOrder");s(this,"m_curves");s(this,"k",0);s(this,"_cacheValue");s(this,"_kValue");this.k=t,this.m_curves=[],this.check()}check(){var t;for(let e=0;e<this.k;e++)(t=this.m_curves)[e]||(t[e]=new Pu);switch(this.k){case 1:this._cacheValue=0;break;case 2:this._cacheValue=new Ie;break;case 3:this._cacheValue=new g;break;case 4:this._cacheValue=new j;break}}get totalTime(){return this.m_curves[0].totalTime}addKeyFrame(t){for(let e=0;e<this.k;e++)this.m_curves[e].addKeyFrame(t.getK(e))}removeKeyFrame(t){for(let e=0;e<this.k;e++)this.m_curves[e].removeKeyFrame(t.getK(e))}getValue(t){switch(this.k){case 1:this._cacheValue=this.m_curves[0].getValue(t);break;case 2:this._cacheValue.x=this.m_curves[0].getValue(t),this._cacheValue.y=this.m_curves[1].getValue(t);break;case 3:this._cacheValue.x=this.m_curves[0].getValue(t),this._cacheValue.y=this.m_curves[1].getValue(t),this._cacheValue.z=this.m_curves[2].getValue(t);break;case 4:const e=this.m_curves[0].getCurveFramesExtent(t),r=e.lhsIndex,a=e.rhsIndex;t=e.time;let i=this.m_curves[0].getKey(r),o=this.m_curves[0].getKey(a);t%=this.m_curves[0].totalTime;let l=(t-i.time)/(o.time-i.time);X.HELP_0.set(this.m_curves[0].getKey(r).value,this.m_curves[1].getKey(r).value,this.m_curves[2].getKey(r).value,this.m_curves[3].getKey(r).value),X.HELP_1.set(this.m_curves[0].getKey(a).value,this.m_curves[1].getKey(a).value,this.m_curves[2].getKey(a).value,this.m_curves[3].getKey(a).value),X.HELP_2.slerp(X.HELP_0,X.HELP_1,l),this._cacheValue.x=X.HELP_2.x,this._cacheValue.y=X.HELP_2.y,this._cacheValue.z=X.HELP_2.z,this._cacheValue.w=X.HELP_2.w;break}return this._cacheValue}getKeyCount(){return this.m_curves[0].getKeyCount()}getKey(t){let e=[];for(let r=0;r<this.k;r++)e.push(this.m_curves[r].getKey(t));return e}formBytes(t){this.path=t.readUTF(),this.k=t.readInt32(),this.check(),this.attribute=t.readUTF(),this.propertys=this.attribute.split("."),this.preInfinity=t.readInt32(),this.postInfinity=t.readInt32(),this.rotationOrder=t.readInt32();let e=t.readInt32();for(let r=0;r<e;r++){let a=new Da(0);a.formBytes(t),this.addKeyFrame(a)}}}var Dd=(n=>(n[n.Open=0]="Open",n[n.Closed=1]="Closed",n))(Dd||{}),Vd=(n=>(n[n.kParticleSystemClampVelocityCurveId=322376503]="kParticleSystemClampVelocityCurveId",n[n.kParticleSystemForceCurveId=306581307]="kParticleSystemForceCurveId",n[n.kParticleSystemRotationCurveId=1793934638]="kParticleSystemRotationCurveId",n[n.kParticleSystemRotationBySpeedCurveId=3737431713]="kParticleSystemRotationBySpeedCurveId",n[n.kParticleSystemStartSpeedCurveId=2527743459]="kParticleSystemStartSpeedCurveId",n[n.kParticleSystemSizeCurveId=2368504881]="kParticleSystemSizeCurveId",n[n.kParticleSystemSizeBySpeedCurveId=4085612399]="kParticleSystemSizeBySpeedCurveId",n[n.kParticleSystemVelocityCurveId=3774601268]="kParticleSystemVelocityCurveId",n[n.kParticleSystemUVCurveId=326370691]="kParticleSystemUVCurveId",n[n.kParticleSystemColorGradientId=1494990940]="kParticleSystemColorGradientId",n[n.kParticleSystemColorByVelocityGradientId=1089181156]="kParticleSystemColorByVelocityGradientId",n[n.kParticleSystemMeshSelectionId=3159510623]="kParticleSystemMeshSelectionId",n[n.kParticleSystemUVRowSelectionId=2941263940]="kParticleSystemUVRowSelectionId",n))(Vd||{}),Nd=(n=>(n[n.kEMScalar=0]="kEMScalar",n[n.kEMOptimized=1]="kEMOptimized",n[n.kEMOptimizedMinMax=2]="kEMOptimizedMinMax",n[n.kEMSlow=3]="kEMSlow",n))(Nd||{}),Md=(n=>(n[n.kMMCScalar=0]="kMMCScalar",n[n.kMMCCurve=1]="kMMCCurve",n[n.kMMCTwoCurves=2]="kMMCTwoCurves",n[n.kMMCTwoConstants=3]="kMMCTwoConstants",n))(Md||{});class dr{}s(dr,"BACK",0),s(dr,"FRONT",1),s(dr,"IN",0),s(dr,"OUT",1),s(dr,"INTERSECT",2);const ai=class ai extends Ie{constructor(e=0,r=0){super(e,r);s(this,"u",0);s(this,"v",0);this.u=e,this.v=r}length(){return 0}static getUVSheet(e,r,a){let i=Math.floor(e%(r*a)),o=Math.floor(i/r),l=i%r;return new j(o/r,l/a,1/r,1/a)}};s(ai,"uv_0",new ai);let Ys=ai;class Da{constructor(t=0){s(this,"serializedVersion","2");s(this,"time");s(this,"tangentMode",0);s(this,"weightedMode",0);s(this,"propertyKeyFrame");this.time=t,this.propertyKeyFrame={}}getK(t){return this.propertyKeyFrame[t]}split(t,e,r){switch(t){case V.single:{let a=this.getKeyFrame(0);a[r]=e}break;case V.float:{let a=this.getKeyFrame(0);a[r]=e}break;case V.vector2:{let a=e,i=this.getKeyFrame(0);i[r]=a.x;let o=this.getKeyFrame(1);o[r]=a.y}break;case V.vector3:{let a=e,i=this.getKeyFrame(0);i[r]=a.x;let o=this.getKeyFrame(1);o[r]=a.y;let l=this.getKeyFrame(2);l[r]=a.z}break;case V.vector4:{let a=e,i=this.getKeyFrame(0);i[r]=a.x;let o=this.getKeyFrame(1);o[r]=a.y;let l=this.getKeyFrame(2);l[r]=a.z;let h=this.getKeyFrame(3);h[r]=a.w}break;case V.quaternion:{let a=e,i=this.getKeyFrame(0);i[r]=a.x;let o=this.getKeyFrame(1);o[r]=a.y;let l=this.getKeyFrame(2);l[r]=a.z;let h=this.getKeyFrame(3);h[r]=a.w}break}}getKeyFrame(t){let e=this.propertyKeyFrame[t];return e||(e=new ki,e.time=this.time,e.tangentMode=this.tangentMode,e.weightedMode=this.weightedMode,this.propertyKeyFrame[t]=e),e}formBytes(t){this.time=t.readFloat32();{let{t:e,v:r}=er.parser(t);this.split(e,r,"value")}{let{t:e,v:r}=er.parser(t);this.split(e,r,"inSlope")}{let{t:e,v:r}=er.parser(t);this.split(e,r,"outSlope")}this.tangentMode=t.readInt32(),this.weightedMode=t.readInt32();{let{t:e,v:r}=er.parser(t);this.split(e,r,"inWeight")}{let{t:e,v:r}=er.parser(t);this.split(e,r,"outWeight")}}}class Va{}s(Va,"WalkAble",1);const Zr=class Zr{static SetConst(t){this.EPSILON=t,this.POWER_EPSILON=t*t}};s(Zr,"EPSILON",.1),s(Zr,"POWER_EPSILON",Zr.EPSILON*Zr.EPSILON);let Kr=Zr;const jt=class jt extends g{constructor(e,r,a,i){super(r,a,i,0);s(this,"_pointId",0);this._pointId=e}get id(){return this._pointId}static equalPoint(e,r){return(e.x-r.x)*(e.x-r.x)+(e.y-r.y)*(e.y-r.y)+(e.z-r.z)*(e.z-r.z)<Kr.POWER_EPSILON}static calcDistance(e,r){return jt.CALC_VECTOR3D3.setTo(e.x-r.x,e.y-r.y,e.z-r.z),jt.CALC_VECTOR3D3.length}};s(jt,"CALC_VECTOR3D1",new g),s(jt,"CALC_VECTOR3D2",new g),s(jt,"CALC_VECTOR3D3",new g),s(jt,"CALC_VECTOR3D4",new g),s(jt,"CALC_VECTOR3D5",new g);let It=jt;class kt extends It{constructor(e,r){super(e.id,0,0,0);s(this,"_ownerPoint");s(this,"_ownerEdge");s(this,"radius",0);this._ownerEdge=r,this._ownerPoint=e}get ownerPoint(){return this._ownerPoint}get ownerEdge(){return this._ownerEdge}scalePoint(e=.7){var r=new kt(this._ownerPoint,this._ownerEdge);return r.copyFrom(this),r.decrementBy(this._ownerPoint),r.scaleBy(e),r.radius=r.length,r.incrementBy(this._ownerPoint),r}}const Et=class Et{constructor(t,e){s(this,"_edgeMask",0);s(this,"_edgeSize",0);s(this,"_pointA");s(this,"_pointB");s(this,"_triangleOwners");s(this,"_centerPoint");s(this,"_edgeDirA2B");s(this,"crossPoint");s(this,"fatPointA");s(this,"fatPointB");if(this._pointA=t,this._pointB=e,t.id>=e.id)throw new Error("edge point order error!!!");this._triangleOwners=new Array,this._centerPoint=new g,this._edgeMask=Va.WalkAble,It.CALC_VECTOR3D1.setTo(t.x-e.x,t.y-e.y,t.z-e.z),this._edgeSize=It.CALC_VECTOR3D1.length,this._centerPoint.setTo((t.x+e.x)/2,(t.y+e.y)/2,(t.z+e.z)/2)}get size(){return this._edgeSize}get triangleOwners(){return this._triangleOwners}get centerPoint(){return this._centerPoint}initFatPoints(t){this._edgeDirA2B=this._pointB.subtract(this._pointA),this._edgeDirA2B.normalize(),this.fatPointA=this.fatPointA||new kt(this._pointA,this),this.fatPointB=this.fatPointB||new kt(this._pointB,this),this.fatPointA.radius!=t&&(Et.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B),Et.CALC_FAT_VECTOR.scaleBy(t),Et.CALC_FAT_VECTOR.incrementBy(this._pointA),this.fatPointA.copyFrom(Et.CALC_FAT_VECTOR),this.fatPointA.radius=t),this.fatPointB.radius!=t&&(Et.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B),Et.CALC_FAT_VECTOR.scaleBy(-t),Et.CALC_FAT_VECTOR.incrementBy(this._pointB),this.fatPointB.copyFrom(Et.CALC_FAT_VECTOR),this.fatPointB.radius=t)}getFatPoint(t){return t==this._pointA?this.fatPointA:this.fatPointB}getAnotherFatPoint(t){return t==this._pointA?this.fatPointB:this.fatPointA}getAnotherPoint(t){return t==this._pointA?this._pointB:this._pointA}containsPoint(t){return It.equalPoint(t,this._pointA)?this._pointA:It.equalPoint(t,this._pointB)?this._pointB:null}addTriangleOwners(t){if(t.edges.indexOf(this)==-1)throw new Error("the edge is not belong triangle!!!");this._triangleOwners.indexOf(t)==-1&&this._triangleOwners.push(t)}getPublicPoint(t){return this._pointA==t._pointA||this._pointA==t._pointB?this._pointA:this._pointB==t._pointA||this._pointB==t._pointB?this._pointB:null}getEqualPoint(t){return It.equalPoint(t,this._pointA)?this._pointA:It.equalPoint(t,this._pointB)?this._pointB:null}get pointA(){return this._pointA}get pointB(){return this._pointB}get walkAble(){return(this._edgeMask&Va.WalkAble)==Va.WalkAble}testMask(t){return(this._edgeMask&t)==t}};s(Et,"CALC_FAT_VECTOR",new g);let Hs=Et;const z=class z{constructor(){s(this,"endPoint");s(this,"curPoint");s(this,"rayA");s(this,"rayB");s(this,"rayAPoint");s(this,"rayBPoint");s(this,"cornerPoint");s(this,"cornerEdge")}continuePass(t,e,r){this.resetData(),this.curPoint=t,this.endPoint=e,this.cornerEdge=r}passEdge(t,e,r,a){if((this.rayA==null||this.rayB==null)&&(this.rayA=z.RAY_1,this.rayB=z.RAY_2,this.rayAPoint=t.pointA,this.rayBPoint=t.pointB,this.rayA.setTo(this.rayAPoint.x-this.curPoint.x,0,this.rayAPoint.z-this.curPoint.z),this.rayB.setTo(this.rayBPoint.x-this.curPoint.x,0,this.rayBPoint.z-this.curPoint.z)),a)return this.checkEndPoint(r);if(z.TEST_RAY.setTo(r.x-this.curPoint.x,0,r.z-this.curPoint.z),this.isPointAtCenter(z.TEST_RAY,this.rayA,this.rayB)){this.hasCrossPoint(e.pointA,e.pointB,this.rayAPoint,this.rayA)?(this.rayB.copyFrom(z.TEST_RAY),r instanceof It?this.rayBPoint=r:this.rayBPoint=null):(this.rayA.copyFrom(z.TEST_RAY),r instanceof It?this.rayAPoint=r:this.rayAPoint=null);var i=e.getAnotherPoint(r);z.TEST_RAY.setTo(i.x-this.curPoint.x,0,i.z-this.curPoint.z),(i==this.rayAPoint||i==this.rayBPoint||this.isPointAtCenter(z.TEST_RAY,this.rayA,this.rayB))&&(this.cornerEdge=e)}else{var o;if(z.TEST_RAY_1.copyFrom(e.pointA),z.TEST_RAY_1.decrementBy(this.curPoint),z.TEST_RAY_2.copyFrom(e.pointB),z.TEST_RAY_2.decrementBy(this.curPoint),z.TEST_RAY_1.y=0,z.TEST_RAY_2.y=0,this.isPointAtCenter(this.rayA,z.TEST_RAY_1,z.TEST_RAY_2)||this.isPointAtCenter(this.rayB,z.TEST_RAY_1,z.TEST_RAY_2)?o=!1:o=!0,o)return this.isPointAtCenter(this.rayA,z.TEST_RAY,this.rayB)?this.cornerPoint=this.rayAPoint:this.cornerPoint=this.rayBPoint,this.cornerEdge.crossPoint=this.cornerPoint,!1}return!0}checkEndPoint(t){return z.TEST_RAY.setTo(t.x-this.curPoint.x,0,t.z-this.curPoint.z),this.isPointAtCenter(z.TEST_RAY,this.rayA,this.rayB)?!0:(this.isPointAtCenter(this.rayA,z.TEST_RAY,this.rayB)?this.cornerPoint=this.rayAPoint:this.cornerPoint=this.rayBPoint,this.cornerEdge.crossPoint=this.cornerPoint,!1)}calcCrossEdge(t,e,r){return this.calcCrossPoint(t.fatPointA,t.fatPointB,e,r)}calcCrossPoint(t,e,r,a){z.CALC_CROSS_POINT.copyFrom(e),z.CALC_CROSS_POINT.decrementBy(t);let i=z.CALC_CROSS_POINT.x*a.z-a.x*z.CALC_CROSS_POINT.z;var o=0;return i!=0&&(o=((t.z-r.z)*a.x-(t.x-r.x)*a.z)/i),o>1?o=1:o<0&&(o=0),z.CALC_CROSS_POINT.scaleBy(o),z.CALC_CROSS_POINT.incrementBy(t),z.CALC_CROSS_POINT.clone()}calcCrossPointOut(t,e,r,a){z.CALC_CROSS_POINT.copyFrom(e),z.CALC_CROSS_POINT.decrementBy(t);var i=((t.z-r.z)*a.x-(t.x-r.x)*a.z)/(z.CALC_CROSS_POINT.x*a.z-a.x*z.CALC_CROSS_POINT.z);return i<=1&&i>=0?null:(z.CALC_CROSS_POINT.scaleBy(i),z.CALC_CROSS_POINT.incrementBy(t),z.CALC_CROSS_POINT.clone())}hasCrossPoint(t,e,r,a){z.CALC_CROSS_TEST.copyFrom(e),z.CALC_CROSS_TEST.decrementBy(t);var i=((t.z-r.z)*a.x-(t.x-r.x)*a.z)/(z.CALC_CROSS_TEST.x*a.z-a.x*z.CALC_CROSS_TEST.z);return i<=1&&i>=0}isPointAtCenter(t,e,r){var a=e.crossProduct(t);if(a.length==0&&t.length<e.length)return!0;var i=r.crossProduct(t);return i.length==0&&t.length<r.length?!0:(a.normalize(),i.normalize(),a.incrementBy(i),a.length<.01)}resetData(){this.cornerEdge=null,this.cornerPoint=null,this.curPoint=null,this.rayA=this.rayB=null,this.rayAPoint=this.rayBPoint=null,z.RAY_1.setTo(0,0,0),z.RAY_2.setTo(0,0,0)}};s(z,"RAY_1",new g),s(z,"RAY_2",new g),s(z,"TEST_RAY",new g),s(z,"TEST_RAY_1",new g),s(z,"TEST_RAY_2",new g),s(z,"CALC_CROSS_POINT",new g),s(z,"CALC_CROSS_TEST",new g);let Oi=z;const qt=class qt{constructor(){s(this,"_aiRadius",0);s(this,"_router");s(this,"_result");s(this,"_tempPublicEdgeList",new Array);s(this,"_tempSamePlaneList",new Array);this._router=new Oi}searchPath(t,e,r,a=0){return a<=0&&(a=1),this._aiRadius=a*1.5,this.searchEnable(t,e,r)?(this.search(t,e,r),!0):!1}get path(){return this._result}searchEnable(t,e,r){return!(t==null||e==null||r==null||r[0].plane.classifyPoint(t,Kr.EPSILON)!=dr.INTERSECT||r[r.length-1].plane.classifyPoint(e,Kr.EPSILON)!=dr.INTERSECT)}search(t,e,r){this._tempPublicEdgeList.length=0,this._tempSamePlaneList.length=0;var a=0,i=r.length-1,o,l,h,c;for(a=0;a<i;a++)l=r[a].getPublicEdge(r[a+1]),l.crossPoint=null,l.initFatPoints(this._aiRadius),this._tempPublicEdgeList.push(l),o=r[a],c=o.plane,o=r[a+1],h=o.getEdgeAgainstPoint(l),this._tempSamePlaneList.push(c.classifyPoint(h,Kr.EPSILON)==dr.INTERSECT);this._router.continuePass(t,e,this._tempPublicEdgeList[0]),i=this._tempPublicEdgeList.length;var u,d,f,A;for(a=0;a<i;a++)l=this._tempPublicEdgeList[a],o=r[a+1],A=a==i-1,A?h=e:h=o.getEdgeAgainstPoint(l),f=this._router.passEdge(l,this._tempPublicEdgeList[a+1],h,A),f||(u=this._router.cornerPoint,d=this._router.cornerEdge,a=this._tempPublicEdgeList.indexOf(d),this._router.continuePass(u,e,this._tempPublicEdgeList[a+1]));this.pushAllPathPoint2(t,e),this._result.length>=3&&(this.optimusTerminusFat(),this.optimusByRadius());let p=[];for(let B of this._result)p.push(new g().copyFrom(B));this._result=p}optimusTerminusFat(){var t,e,r;r=this._result[1],r instanceof kt&&(t=r),r=this._result[this._result.length-2],r instanceof kt&&(e=r),t&&(this._result[1]=t.scalePoint()),e&&t!=e&&(this._result[this._result.length-2]=e.scalePoint())}pushAllPathPoint2(t,e){var r=this._tempPublicEdgeList.length,a,i;this._result=new Array,this._result.push(t);for(var o=t,l,h,c,u=0;u<r;u++)if(a=this._tempPublicEdgeList[u],h=null,a.crossPoint)h=this.getFatPoint(a,a.crossPoint),h?this._result.push(h):this._result.push(a.crossPoint),o=a.crossPoint;else{i=null,l=null;for(var d=u+1;d<r&&(i=this._tempPublicEdgeList[d],l=i.crossPoint,!l);d++);l==null&&(l=e),h=this.getFatPoint(a,l),h?this._result.push(h):(l==o?c=l.clone():(qt.CROSS_TEST_DIRECTION.setTo(l.x-o.x,0,l.z-o.z),c=this._router.calcCrossEdge(a,o,qt.CROSS_TEST_DIRECTION)),this._result.push(c))}this._result.push(e)}optimusByRadius(){var t=new Array;t.length=this._result.length;var e=this._result.length-2,r,a,i,o,l,h,c,u,d,f,A,p,B;for(B=0;B<e;B++)c=u=d=null,o=l=h=null,A=!1,p=null,r=this._result[B],a=this._result[B+1],i=this._result[B+2],r instanceof kt&&(o=r),a instanceof kt&&(l=a),i instanceof kt&&(h=i),o&&(c=o.ownerPoint),l&&(u=l.ownerPoint),h&&(d=h.ownerPoint),c&&u&&c==u&&u!=d&&(A=!0),d&&u&&d==u&&c!=u&&(A=!0),A&&(qt.CROSS_TEST_DIRECTION.copyFrom(r),qt.CROSS_TEST_DIRECTION.decrementBy(i),f=l.ownerEdge,A=this._router.hasCrossPoint(f.pointA,f.pointB,i,qt.CROSS_TEST_DIRECTION),A&&(p=this._router.calcCrossPointOut(u,a,i,qt.CROSS_TEST_DIRECTION)),p&&(t[B+1]=p))}getFatPoint(t,e){if(t==null)return null;var r;e instanceof kt&&(r=e);var a;return r?a=r.ownerPoint:a=t.getEqualPoint(e),a==null?null:(r=t.getFatPoint(a),r)}};s(qt,"CROSS_TEST_DIRECTION",new g);let Ks=qt;class js extends ar{constructor(e=1,r=1,a=1){super();s(this,"width");s(this,"height");s(this,"depth");this.width=e,this.height=r,this.depth=a,this.initVertex()}initVertex(){let e=this.width/2,r=this.height/2,a=this.depth/2;this.bounds=new Pe(g.ZERO.clone(),new g(this.width,this.height,this.depth));let i=new Float32Array([-e,r,a,e,r,a,e,r,-a,-e,r,-a,-e,r,a,e,r,-a,e,-r,a,-e,-r,a,-e,-r,-a,e,-r,-a,e,-r,a,-e,-r,-a,-e,-r,a,-e,r,a,-e,r,-a,-e,-r,-a,-e,-r,a,-e,r,-a,e,r,a,e,-r,a,e,-r,-a,e,r,-a,e,r,a,e,-r,-a,e,r,a,-e,r,a,-e,-r,a,-e,-r,a,e,-r,a,e,r,a,e,-r,-a,-e,-r,-a,-e,r,-a,e,r,-a,e,-r,-a,-e,r,-a]),o=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),l=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),h=[0,2,1,3,5,4,6,8,7,9,11,10,12,14,13,15,17,16,18,20,19,21,23,22,24,26,25,27,29,28,30,32,31,33,35,34],c=new Uint16Array(h.reverse());this.setIndices(c),this.setAttribute(k.position,i),this.setAttribute(k.normal,o),this.setAttribute(k.uv,l),this.setAttribute(k.TEXCOORD_1,l),this.addSubGeometry({indexStart:0,indexCount:h.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}var kd=(n=>(n[n.X=0]="X",n[n.Y=1]="Y",n[n.Z=2]="Z",n[n.XY=3]="XY",n[n.XZ=4]="XZ",n[n.YZ=5]="YZ",n[n.XYZ=6]="XYZ",n[n.MAX=7]="MAX",n[n.NONE=8]="NONE",n))(kd||{}),Pd=(n=>(n[n.Local=0]="Local",n[n.Global=1]="Global",n))(Pd||{}),Ld=(n=>(n[n.Scale=0]="Scale",n[n.Rotation=1]="Rotation",n[n.Translation=2]="Translation",n[n.NONE=3]="NONE",n))(Ld||{});const Od=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}));async function Gd(){await C.init();let n=new cd;n.addComponent(bu);let t=new ie,e=t.addComponent(Gi);e.perspective(80,window.innerWidth/window.innerHeight,1,5e3),e.object3D.addComponent(Ju).setCamera(-40,0,10),n.addChild(t);let a=new ie,i=a.addComponent(fa);a.rotationX=60,a.rotationY=180,i.intensity=2,n.addChild(a);const o=new ie;let l=o.addComponent(Be);l.geometry=new js(4,9,1),l.material=new Vr,l.material.baseColor.r=0,l.material.baseColor.g=1,l.material.baseColor.b=0,n.addChild(o);const h=new ie;let c=h.addComponent(Be);c.geometry=new js(1e4,0,1e4),c.material=new Vr,h.transform.y=-4.5,n.addChild(h);let u=new fd;u.scene=n,u.camera=e,C.startRenderView(u)}document.querySelector("#app").innerHTML=`
  <main>
  </main>
`;Gd();
